<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js 引擎(一)]]></title>
    <url>%2F2019%2F08%2F18%2FWeb%E5%89%8D%E7%AB%AF%2Fjs%20%E5%BC%95%E6%93%8E(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[在 Facebook 发布 Hermes 引擎之前，Fabrice Bellard 以及 C 语言专家 Charlie Gordon 公开发布了 QuickJS。 Facebook发布全新JS引擎！专注提高React Native应用的性能 为了提高 Facebook 应用的性能，我们的团队不断改进自己的 JavaScript 代码和平台。在分析性能数据时，我们发现 JavaScript 引擎本身是影响启动性能和应用包体积的重要因素。有了这些数据，我们意识到必须在比 PC 端限制更多的移动环境中优化 JavaScript 性能。尝试了各种方案后，我们构建了一个新的 JavaScript 引擎：Hermes。它旨在提高应用性能，专注于 React Native 应用，并且在市面上那些内存较少、存储速度较慢且计算能力低下的移动设备上都有良好的表现。 主要特点： 字节码预编译 无 JIT 垃圾回收策略 轻量可嵌入的QuickJS引擎重磅开源，它会是下一个V8吗？ 一路开挂的作者 Fabrice Bellard 是一位法国著名的计算机程序员，因 FFmpeg、QEMU 等项目而闻名业内。他也是最快圆周率算法贝拉公式、TCCBOOT 和 TCC 等项目的作者。 QuickJS 支持 ES2019 规范，包括模块，异步生成器和代理，主要特点： 小巧且易于嵌入：只需几个 C 文件，无外部依赖，x86 下一个简单的 hello world 示例程序仅 190 KB 的大小。 具有极低启动时间的快速解释器：在台式 PC 的单核上，在大约 100 秒内运行 ECMAScript 测试套件56000 次测试。运行时实例的完整生命周期在不到 300 微秒的时间内完成。 支持 ES2019 ，包括模块、异步生成器和完整的 Annex B 支持（传统的 Web 兼容性）。 100％的通过了 ECMAScript 测试用例。 可以将 Javascript 源编译为没有外部依赖的可执行文件。 使用引用计数（以减少内存使用并具有确定性行为）的垃圾收集与循环删除。 数学扩展：BigInt，BigFloat，运算符重载，bigint 模式，数学模式。 在 Javascript 中实现的具有上下文着色的命令行解释器。 带有 C 库包装库构建的内置标准库。 PS: 前端性能优化终于走到了 js 引擎的层面。为了更好地地了解引擎技术，我们先来温故一下 js 基础机制：开发做了这么多年，你真的了解JS工作机制吗？ JIT 将 JS 视为一种解释性语言是不对的。以前很多年 JS 的确是解释性的，但最近出现了一些变化，这种假设也随之过时了。许多流行的 JS 引擎为了使 JS 执行更快，引入了一种称为 Just-In-Time 编译的功能。简而言之，这意味着 JS 代码会在执行期间直接编译成机器码（至少 V8 是这样做的），不再有解释这一步。这个流程耗时稍长，但输出的结果性能更强。为了在有限的时间内完成工作，V8 实际上有两个编译器（不算与 WebAssembly 相关的内容）。其中一个是通用的，能够非常快地编译任何 JS 代码，但只输出性能一般的结果；而另一个编译速度有点慢，是用来编译常用代码的，其输出结果性能极高。当然，因为 JS 有动态类型的特性，这些编译器也不好做。所以类型不变的情况下第二个编译器的效果最好，能让你的代码运行起来快得多。 堆和栈 在 JS 代码的执行过程中会分配两个内存区域——调用栈和 堆。第一个性能非常高，因此用于连续执行所提供的函数。每个函数调用在调用栈中创建一个所谓的“框架”，其中包含其局部变量的副本和 this。你可以通过 Chrome 调试器查看它。就像在其他与堆栈类似的数据结构中一样，调用栈的帧被推送或弹出堆栈，具体取决于正在执行或终止的新函数。你可能见过调用栈上限溢出错误，通常是由于某种形式的无限循环导致的。 谈到堆，就像现实生活中一样，JS 堆是存储本地范围之外对象的地方。它比调用栈慢得多。这就是为什么访问本地变量时速度可能会快很多。堆也是存放未被访问或使用的对象的地方，这种对象就是垃圾。有垃圾就要有垃圾回收器。需要时 JS 运行时的垃圾回收器就会激活，清理堆并释放内存。 前端内存相关探索 堆和栈 在前端中，被存储在栈内的数据包括小数值型，string ，boolean 和复杂类型的地址索引。所谓小数值数据(small number), 即长度短于 32 位存储空间的 number 型数据。一些复杂的数据类型，诸如 Array，Object 等，是被存在堆中的。 共享内存 当程序变的过于复杂时，我们希望通过 webworker 来开启新的独立线程，完成独立计算。 开启新的线程伴随而来的问题就是通讯问题。webworker 的 postMessage 可以帮助我们完成通信，但是这种通信机制是将数据从一部分内存空间复制到主线程的内存下。这个赋值过程就会造成性能的消耗。 而共享内存，顾名思义，可以让我们在不同的线程间，共享一块内存，这些现成都可以对内存进行操作，也可以读取这块内存。省去了赋值数据的过程，不言而喻，整个性能会有较大幅度的提升。 使用原始的 postMessage 方法进行数据传输使用，每一个消息内的数据在不同的线程中，都是被克隆一份以后再传输的。数据量越大，数据传输速度越慢。 sharedBufferArray 的消息传递通过共享内存传递的数据，在 worker 中改变了数据以后，主线程的原始数据也被改变了。 main.js 1234567891011121314151617181920var worker = new Worker(&apos;./sharedArrayBufferWorker.js&apos;);worker.onmessage = function(e)&#123; // 传回到主线程已经被计算过的数据 console.log(&quot;e.data&quot;,&quot; -- &quot;, e.data ); // SharedArrayBuffer(3) &#123;&#125; // 和传统的 postMessage 方式对比，发现主线程的原始数据发生了改变 console.log(&quot;int8Array-outer&quot;,&quot; -- &quot;, int8Array ); // Int8Array(3) [2, 3, 4]&#125;;var sharedArrayBuffer = new SharedArrayBuffer(3);var int8Array = new Int8Array(sharedArrayBuffer);int8Array[0] = 1;int8Array[1] = 2;int8Array[2] = 3;worker.postMessage(sharedArrayBuffer); worker.js 12345678910111213onmessage = function(e)&#123; var arrayData = increaseData(e.data); postMessage(arrayData);&#125;;function increaseData(arrayData)&#123; var int8Array = new Int8Array(arrayData); for(let i = 0; i &lt; int8Array.length; i++)&#123; int8Array[i] += 1; &#125; return arrayData;&#125; 前端 Web Workers 到底是什么？ worker线程的使用有一些注意点 同源限制 worker线程执行的脚本文件必须和主线程的脚本文件同源，这是当然的了，总不能允许worker线程到别人电脑上到处读文件吧 文件限制 为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源 DOM操作限制 worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 document、 window等对象，但是可以获取 navigator、 location(只读)、XMLHttpRequest、 setTimeout族等浏览器API。 通信限制 worker线程与主线程不在同一个上下文，不能直接通信，需要通过 postMessage方法来通信。 脚本限制 worker线程不能执行 alert、 confirm，但可以使用 XMLHttpRequest 对象发出ajax请求。 漫谈前端性能 突破 React 应用瓶颈 React 结合 Web worker ? 尝试在 Web worker 中运行 React Virtual DOM 的相关计算，即将 React core 部分移入 Web worker 线程中 ? 还真有人提出类似想法：3092 issue，但是提案被拒绝了，react 选择的是 React Fiber。 但是这个并不妨碍 Web worker 成为 “民间” 的 react 性能解药： React Redux 中间件思想遇见 Web Worker 的灵感（附demo）另外举个例子对比: http://web-perf.github.io/react-worker-dom/]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo & github page 搭建博客]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%85%B6%E4%BB%96%2Fhexo%20%26%20github%20page%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo搭建的GitHub博客搭建搭建过程参考这篇文章：手把手教你使用 Hexo + Github Pages 搭建个人独立博客 Hexo 主题配置建议设置为 next 主题 克隆仓库 12// git clone命令将Next仓库克隆到hexo目录下的themes/nextgit clone https://github.com/theme-next/hexo-theme-next.git themes/next 设置Next主题 12345// 在站点根目录下，设置以下代码：# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next #此处填入你在themes目录下的next主题文件名 个性化设置大致设置过程参见这篇文章： Hexo搭建的GitHub博客之优化大全 开启文章阅读次数功能 第一种方法：LeanCloud (参考这篇文章：https://www.jianshu.com/p/702a7aec4d00) 去 LeanCloud ，创建新应用，创建 Counter 类 修改主题文件 1234leancloud_visitors: enable: true #将原来的false改为true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; 第二种方法： 开启不蒜子统计功能 在主题配置文件中 _config.yml ： 1234567891011121314# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: enable: true site_uv: true #total visitors site_uv_icon: #user-circle site_uv_header: 你是来访的第 site_uv_footer: 位小伙伴 site_pv: false #total views site_pv_icon: eye site_pv_header: 访问次数： site_pv_footer: 次 post_views: false post_views_icon: eye 不过因为域名过期问题，next 默认集成的 valine 脚本无法访问，解决办法参见：hexo博客解决不蒜子统计无法显示问题 开启 valine 评论功能大致设置过程参考这篇文章： Hexo博客使用valine评论系统无效果及终极解决方案 需要特别注意的是： valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突。 解决的办法是：基于LeanCloud开启 valine 评论，基于不蒜子开启文章统计功能。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python]]></title>
    <url>%2F2019%2F08%2F15%2FPython%2FPython%2F</url>
    <content type="text"></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebAssembly]]></title>
    <url>%2F2019%2F08%2F15%2FWebAssembly%2FWebAssembly%2F</url>
    <content type="text"></content>
      <categories>
        <category>WebAssembly</category>
      </categories>
      <tags>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react hooks]]></title>
    <url>%2F2019%2F08%2F15%2FWeb%E5%89%8D%E7%AB%AF%2Freact%20hooks%2F</url>
    <content type="text"><![CDATA[react hookswhat Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 Hook 简介 why react hooks 主要解决以下三个主要的问题： 代码重用：在 hooks 出来之前，常见的代码重用方式是 HOC 和 render props，这两种方式带来的问题是： 你需要解构自己的组件，非常的笨重，同时会带来很深的组件嵌套。 难以重用和共享组件中的与状态相关的逻辑，造成产生很多巨大的组件。 复杂的组件逻辑：在 class 组件中，有许多的 lifecycle 函数，当我们的组件需要处理多个互不相关的 localstate 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面，最终导致逻辑复杂的组件难以开发与维护。 class 组件的困惑： 复杂的模式，如渲染道具和高阶组件。 由于业务变动，函数组件不得不改为类组件 另外还可以参考一下这个回答：如何评价 React v16.7.0-alpha 提出的 Hooks API？ 官方文档： 动机 how useState(0) 返回是个数组形式，useState(0) 代表 count 的初始值是 0，useState 现阶段只能传入一个初始值。useState 类似 setState，你可以看做是异步的，但 useState 必须保证执行顺序一一致，React 为每一次的 useState 调用分配一个空间，通过 useState 调用顺序辨别各个空间。 12345678910const Counter = () =&gt; &#123; const [count, setCount] = useState(0); const increment = () =&gt; setCount(count + 1); return ( &lt;&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt; &lt;/&gt; )&#125; useEffect 可以把 useEffect 视作 componentDidMount、componentDidUpdate 合体。通过 useEffect 的第二个参数告诉 React 用到了哪些外部变量，来决定是否更新时候执行。可以定义多个 useEffect 函数，会一次进行调用。 123useEffect(() =&gt; &#123; // 每次componentDidMount或者componentDidUpdate都会调用这里&#125;) useEffect 可以传入第二个操作来避免性能的损耗，如果第二个参数数组中的成员变量没有变化则会跳过此次改变。如何传入一个空数组 ，说明每次都不改变，那么该 effect 只会在组件 mount 和 unmount 时期执行。 123useEffect(() =&gt; &#123; // 每次componentDidMount会调用这里&#125;,[]) 如果需要在 componentWillUnmount 需要执行一些事件，可以 return 返回时候进行操作。 123456useEffect(() =&gt; &#123; //只有componentDidMount时候调用这里 return () =&gt; &#123; // 只有componentDidMountUnmount时候调用这里 &#125;;&#125;, []) useEffect 模拟 componentDidpdate，useRef是永远不会改变的一个hooks，每次返回值都是相同的。 12345678const mounted = useRef();useEffect(() =&gt; &#123; if(!mounted.current)&#123; mounted.current = true; &#125; else &#123; // 执行 componentDidpdate &#125;&#125;) useLayoutEffect：如果副作用是跟 DOM 相关的，需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。 1234567891011121314function App() &#123; const [width, setWidth] = useState(0); useLayoutEffect(() =&gt; &#123; const title = document.querySelector(&apos;#title&apos;); const titleWidth = title.getBoundingClientRect().width; if (width !== titleWidth) &#123; setWidth(titleWidth); &#125; &#125;); return &lt;div&gt; &lt;h1 id=&quot;title&quot;&gt;hello&lt;/h1&gt; &lt;h2&gt;&#123;width&#125;&lt;/h2&gt; &lt;/div&gt;&#125; useReducer 接收两个参数，一个是 reducer 函数，跟 redux 中的 reducer 是一样的；另外一个是初始的状态值。返回的是一个数组，数组中的第一个元素是状态值，第二个元素是 dispatch 函数。 12345678910111213141516171819202122const reducer = (state, action) =&gt; &#123; switch(action.type) &#123; case &apos;increment&apos;: return &#123;count: state.count + 1&#125;; case &apos;decrement&apos;: return &#123;count: state.count - 1&#125;; case &apos;reset&apos;: return initState; default: return state; &#125;&#125;;function App() &#123; const [state, dispatch] = useReducer(reducer, initState); return &lt;div&gt; &lt;h1&gt;&#123;state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;increment&apos;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;decrement&apos;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;reset&apos;&#125;)&#125;&gt;reset&lt;/button&gt; &lt;/div&gt;&#125; useRef：在函数组件中获取组件或DOM节点的引用。 12345678function App() &#123; const inputRef = useRef(null); return &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;inputRef&#125;/&gt; &lt;button onClick=&#123;() =&gt; inputRef.current.focus()&#125;&gt;focus&lt;/button&gt; &lt;/div&gt;&#125; 自定义 hooks举个🌰custom Hooks 自定义监听窗口大小组件 12345678// 一个显示目前窗口大小的组件function responsiveComponent()&#123; // custom hooks const width = useWindowWidth(); return ( &lt;p&gt;当前窗口的宽度是 &#123;width&#125;&lt;/p&gt; )&#125; custom hooks —— useWindowWidth 窗口调整大小时使用副作用来设置该状态 1234567891011121314import &#123; useState, useEffect&#125; from &apos;react&apos;;// custom hooks to listen window width changefunction useWindowWidth()&#123; const [width, setWidth] = useState(window.innerWidth); useEffect(() =&gt; &#123; const handleResize = ()=&gt;&#123; setWidth(window.innerWidth); &#125; window.addEventListener(&apos;resize&apos;, handleResize); &#125;, [width]); // width 没有变化则不处理 return width;&#125; 此外还可以参考一个有意思的 hooks 库 react-use 限制条件 仅从 React 功能组件调用 hooks。不要从常规 js 函数中调用 hooks。( 还有另一个地方可以调用 hooks—— 你自己的定制 hooks。) 只能在顶层调用，不能在 for 循环、if 条件判断、 函数嵌套中使用。 Ps：译: React hooks: 不是魔法只是数组 一文中有解释为什么 hooks 只能在顶层调用。 原理与实现 [[译] React hooks: 不是魔法，只是数组](http://react-china.org/t/react-hooks/27122) useState 底层实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let state = [];let setters = [];let firstRun = true;let cursor = 0;function createSetter(cursor) &#123; return function setterWithCursor(newVal) &#123; state[cursor] = newVal; &#125;;&#125;// This is the pseudocode for the useState helperexport function useState(initVal) &#123; if (firstRun) &#123; state.push(initVal); setters.push(createSetter(cursor)); firstRun = false; &#125; const setter = setters[cursor]; const value = state[cursor]; cursor++; return [value, setter];&#125;// Our component code that uses hooksfunction RenderFunctionComponent() &#123; const [firstName, setFirstName] = useState(&quot;Rudi&quot;); // cursor: 0 const [lastName, setLastName] = useState(&quot;Yardley&quot;); // cursor: 1 return ( &lt;div&gt; &lt;Button onClick=&#123;() =&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;/Button&gt; &lt;Button onClick=&#123;() =&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;/Button&gt; &lt;/div&gt; );&#125;// This is sort of simulating Reacts rendering cyclefunction MyComponent() &#123; cursor = 0; // resetting the cursor return &lt;RenderFunctionComponent /&gt;; // render&#125;console.log(state); // Pre-render: []MyComponent();console.log(state); // First-render: [&apos;Rudi&apos;, &apos;Yardley&apos;]MyComponent();console.log(state); // Subsequent-render: [&apos;Rudi&apos;, &apos;Yardley&apos;]// click the &apos;Fred&apos; buttonconsole.log(state); // After-click: [&apos;Fred&apos;, &apos;Yardley&apos;] 参考文章 react hooks的诞生 理解 React Hooks 译: React hooks: 不是魔法只是数组 How to fetch data with React Hooks]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
</search>
