<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F01%2FNode.js%2FNode.js%20%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1234title: Node.jsdate: 2019-09-01 14:46:24tags: Node.jscategories: Node.js 如何学习 Node.js 【知乎Live】狼叔：如何正确的学习Node.js]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F31%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JavaScript 面试题集 33 Concepts Every JavaScript Developer Should Know React react 官网 大牛们的思考沉淀 阿里9年，我总结的前端架构演进3大阶段及团队管理心法]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F27%2FPython%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Python%20%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1234title: 深入浅出 Python 模块机制date: 2019-09-01 17:56:24tags: Pythoncategories: Python Python 模块 模块是包括 Python 定义和声明的文件，文件名就是模块名加上 .py 后缀，模块名可以由全局变量 __name__ 得到。 Python 只有一种模块对象类型，所有模块都属于该类型，无论模块是用 Python、C 还是别的语言实现。 什么是 Python 模块简单来说，一个 Python 模块就是一个以 .py 为后缀的文件 ，模块中能定义内容包括：变量、函数、类和可执行代码。 模块类型大致有以下 3 种： Python 内置的模块，即标准库。 Python 带有一个标准模块库，并发布有独立的文档，名为 Python 库参考手册。有一些模块内置于解释器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。这既是为了提高效率，也是为了给系统调用等操作系统原生访问提供接口。 第三方模块，即通过 pip install 的模块。 自定义模块，即用户自己编写的模块。 举个 🌰我们写一个模块 fibo.py ： 1234567891011121314# write Fibonacci series up to ndef fib(n): a, b = 0, 1 while a &lt; n: print(a) a, b = b, a+b# return Fibonacci series up to ndef fib2(n): result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b 模块导入导入模块的方式有以下 2 种： import module 这是模块 完全引入 的方式。 比如 import os 会把 os 下面的所有的变量、函数、类全部引入，通过 os 可以访问模块中的变量或函数，如 os.listdir()。 当然也可以通过 import module as xx 的方式，为模块起一个别名。 from module import func1, func2 这是模块 部分引入 的方式。按需引入需要模块中定义的函数，另一个好处是可以直接在脚本中使用复制后的变量名。 举个🌰现在进入 Python 解释器，导入该模块： 12&gt;&gt;&gt; import fibo&gt;&gt;&gt; 可以看到当前没有任何输出，因为导入模块的操作，只是进入到模块名 fibo 中，并不会直接进入到定义在 fibo 函数内。可以用模块名访问这些函数: 123456789&gt;&gt;&gt; import fibo&gt;&gt;&gt; fibo.fib(10)0112358 模块执行如果需要让一个 .py 文件既当作脚本又能当作模块用，可以使用 __name__ 这个属性。只有当文件被当作脚本执行的时候， __name__ 的值才会是 &#39;__main__&#39;，而模块导入时不会。 下面，我们改造一下上述 fibo 模块，在末尾添加一段代码： 123456789101112131415161718# write Fibonacci series up to ndef fib(n): a, b = 0, 1 while a &lt; n: print(a) a, b = b, a+b# return Fibonacci series up to ndef fib2(n): result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b# 作为脚本来执行模块if __name__ == &apos;__main__&apos; : fib(10) 然后运行 Python 模块： 12345678&gt;&gt;&gt; python fibo.py 0112358 可以看到模块里的代码会被执行，就好像已导入模块一样。 模块加载机制 动态加载模块但是import只能够加载固定名称模块，不能加载动态比如字符串名称模块，比如 str = ‘tools’import str 好了，现在解决了动态加载随意模块的问题了，但是距离成功还有一步之遥，在python里面，加载模块是有缓存的，意思就是说，加载tools.py之后，就算tools.py内容发生改变了，都不会重新加载，还是无法满足我们实时更新加载模块的需求。这里有个比较简单的办法，可以使得模块有需要的时候重新加载，回想之前我们说过，python加载后的模块都会保存在sys.modules里面，我们只需要在重新加载模块之前，把模块从sys.modules里面删除即可。 del sys.modules[‘tools’]import(‘tools’) Python 包 为了帮助组织模块并提供名称层次结构，Python 还引入了包的概念。可以把包看成是文件系统中的目录，并把模块看成是目录中的文件，但请不要对这个类似做过于字面的理解，因为包和模块不是必须来自于文件系统。 与文件系统一样，包通过层次结构进行组织，在包之内除了一般的模块，还可以有子包。 简单地来说，”包“ (package) 是含有 Python 模块的文件夹，不过前提条件是这个文件夹下必须存在 __init__.py 文件。 _init_.py 文件当文件夹下存在 __init__.py 文件时意味着该文件夹是一个包，__init__.py 文件用于组织包，管理各个模块之间的引用、控制包的导入行为。 封装包时确保每个目录都定义了一个 __init__.py 文件，举个🌰： 123456789├── package # 顶层目录├── __init__.py ├── subPackage1 # 子包│ ├── __init__.py │ ├── module1 │ ├── module1 ├── subPackage2 # 子包│ ├── __init__.py │ ├── module2 组织好目录结构和代码后，便可以执行以下 import 语句： 123import package.subPackage1.module1from package.subPackage1 import module1import package.subPackage2.module2 as module2 __init__.py 文件的目的是要包含不同运行级别的包的可选的初始化代码，导入一个包时会先导入的它的 __init__.py 文件并自动运行。 举个🌰，执行语句 import package.subPackage1.module1 时，文件 package/__init__.py 将被导入，建立 package 命名空间的内容，且 package/__init__.py 将在文件 package/subPackage1/__init__.py 导入之前导入。 一般情况下 __init__.py 文件可以为空，但是有的时候也可以在 __init__.py 中导入其他的包或模块： 12# package/subPackage1/__init__.pyfrom . import module1 于是就可以通过 import package.subPackage1 代替 import package.subPackage1.module1 来导入模块了。 包导入使用相对路径名导入包中子模块参考文档 【官方文档】—— 导入系统 Python \init__.py 作用详解 Python源码剖析笔记3-Python执行原理初探]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F21%2FPython%2Fpandas%20%E7%9A%84%20excel%20%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[用 python 做数据分析：pandas 的 excel 应用初探：https://zhuanlan.zhihu.com/p/32338530 Python实现EXCEL常用操作——pandas简介：https://zhuanlan.zhihu.com/p/34541791 XlsxWriter：https://xlsxwriter.readthedocs.io/ python 和 node.js 交互(node.js中执行python函数)：https://blog.csdn.net/qq_23057645/article/details/80967657]]></content>
  </entry>
  <entry>
    <title><![CDATA[js 引擎(一)]]></title>
    <url>%2F2019%2F08%2F18%2FWeb%E5%89%8D%E7%AB%AF%2Fjs%20%E5%BC%95%E6%93%8E(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[在 Facebook 发布 Hermes 引擎之前，Fabrice Bellard 以及 C 语言专家 Charlie Gordon 公开发布了 QuickJS。 Facebook发布全新JS引擎！专注提高React Native应用的性能 为了提高 Facebook 应用的性能，我们的团队不断改进自己的 JavaScript 代码和平台。在分析性能数据时，我们发现 JavaScript 引擎本身是影响启动性能和应用包体积的重要因素。有了这些数据，我们意识到必须在比 PC 端限制更多的移动环境中优化 JavaScript 性能。尝试了各种方案后，我们构建了一个新的 JavaScript 引擎：Hermes。它旨在提高应用性能，专注于 React Native 应用，并且在市面上那些内存较少、存储速度较慢且计算能力低下的移动设备上都有良好的表现。 主要特点： 字节码预编译 无 JIT 垃圾回收策略 轻量可嵌入的QuickJS引擎重磅开源，它会是下一个V8吗？ 一路开挂的作者 Fabrice Bellard 是一位法国著名的计算机程序员，因 FFmpeg、QEMU 等项目而闻名业内。他也是最快圆周率算法贝拉公式、TCCBOOT 和 TCC 等项目的作者。 QuickJS 支持 ES2019 规范，包括模块，异步生成器和代理，主要特点： 小巧且易于嵌入：只需几个 C 文件，无外部依赖，x86 下一个简单的 hello world 示例程序仅 190 KB 的大小。 具有极低启动时间的快速解释器：在台式 PC 的单核上，在大约 100 秒内运行 ECMAScript 测试套件56000 次测试。运行时实例的完整生命周期在不到 300 微秒的时间内完成。 支持 ES2019 ，包括模块、异步生成器和完整的 Annex B 支持（传统的 Web 兼容性）。 100％的通过了 ECMAScript 测试用例。 可以将 Javascript 源编译为没有外部依赖的可执行文件。 使用引用计数（以减少内存使用并具有确定性行为）的垃圾收集与循环删除。 数学扩展：BigInt，BigFloat，运算符重载，bigint 模式，数学模式。 在 Javascript 中实现的具有上下文着色的命令行解释器。 带有 C 库包装库构建的内置标准库。 PS: 前端性能优化终于走到了 js 引擎的层面。为了更好地地了解引擎技术，我们先来温故一下 js 基础机制：开发做了这么多年，你真的了解JS工作机制吗？ JIT 将 JS 视为一种解释性语言是不对的。以前很多年 JS 的确是解释性的，但最近出现了一些变化，这种假设也随之过时了。许多流行的 JS 引擎为了使 JS 执行更快，引入了一种称为 Just-In-Time 编译的功能。简而言之，这意味着 JS 代码会在执行期间直接编译成机器码（至少 V8 是这样做的），不再有解释这一步。这个流程耗时稍长，但输出的结果性能更强。为了在有限的时间内完成工作，V8 实际上有两个编译器（不算与 WebAssembly 相关的内容）。其中一个是通用的，能够非常快地编译任何 JS 代码，但只输出性能一般的结果；而另一个编译速度有点慢，是用来编译常用代码的，其输出结果性能极高。当然，因为 JS 有动态类型的特性，这些编译器也不好做。所以类型不变的情况下第二个编译器的效果最好，能让你的代码运行起来快得多。 堆和栈 在 JS 代码的执行过程中会分配两个内存区域——调用栈和 堆。第一个性能非常高，因此用于连续执行所提供的函数。每个函数调用在调用栈中创建一个所谓的“框架”，其中包含其局部变量的副本和 this。你可以通过 Chrome 调试器查看它。就像在其他与堆栈类似的数据结构中一样，调用栈的帧被推送或弹出堆栈，具体取决于正在执行或终止的新函数。你可能见过调用栈上限溢出错误，通常是由于某种形式的无限循环导致的。 谈到堆，就像现实生活中一样，JS 堆是存储本地范围之外对象的地方。它比调用栈慢得多。这就是为什么访问本地变量时速度可能会快很多。堆也是存放未被访问或使用的对象的地方，这种对象就是垃圾。有垃圾就要有垃圾回收器。需要时 JS 运行时的垃圾回收器就会激活，清理堆并释放内存。 前端内存相关探索 堆和栈 在前端中，被存储在栈内的数据包括小数值型，string ，boolean 和复杂类型的地址索引。所谓小数值数据(small number), 即长度短于 32 位存储空间的 number 型数据。一些复杂的数据类型，诸如 Array，Object 等，是被存在堆中的。 共享内存 当程序变的过于复杂时，我们希望通过 webworker 来开启新的独立线程，完成独立计算。 开启新的线程伴随而来的问题就是通讯问题。webworker 的 postMessage 可以帮助我们完成通信，但是这种通信机制是将数据从一部分内存空间复制到主线程的内存下。这个赋值过程就会造成性能的消耗。 而共享内存，顾名思义，可以让我们在不同的线程间，共享一块内存，这些现成都可以对内存进行操作，也可以读取这块内存。省去了赋值数据的过程，不言而喻，整个性能会有较大幅度的提升。 使用原始的 postMessage 方法进行数据传输使用，每一个消息内的数据在不同的线程中，都是被克隆一份以后再传输的。数据量越大，数据传输速度越慢。 sharedBufferArray 的消息传递通过共享内存传递的数据，在 worker 中改变了数据以后，主线程的原始数据也被改变了。 main.js 1234567891011121314151617181920var worker = new Worker(&apos;./sharedArrayBufferWorker.js&apos;);worker.onmessage = function(e)&#123; // 传回到主线程已经被计算过的数据 console.log(&quot;e.data&quot;,&quot; -- &quot;, e.data ); // SharedArrayBuffer(3) &#123;&#125; // 和传统的 postMessage 方式对比，发现主线程的原始数据发生了改变 console.log(&quot;int8Array-outer&quot;,&quot; -- &quot;, int8Array ); // Int8Array(3) [2, 3, 4]&#125;;var sharedArrayBuffer = new SharedArrayBuffer(3);var int8Array = new Int8Array(sharedArrayBuffer);int8Array[0] = 1;int8Array[1] = 2;int8Array[2] = 3;worker.postMessage(sharedArrayBuffer); worker.js 12345678910111213onmessage = function(e)&#123; var arrayData = increaseData(e.data); postMessage(arrayData);&#125;;function increaseData(arrayData)&#123; var int8Array = new Int8Array(arrayData); for(let i = 0; i &lt; int8Array.length; i++)&#123; int8Array[i] += 1; &#125; return arrayData;&#125; 前端 Web Workers 到底是什么？ worker线程的使用有一些注意点 同源限制 worker线程执行的脚本文件必须和主线程的脚本文件同源，这是当然的了，总不能允许worker线程到别人电脑上到处读文件吧 文件限制 为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源 DOM操作限制 worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 document、 window等对象，但是可以获取 navigator、 location(只读)、XMLHttpRequest、 setTimeout族等浏览器API。 通信限制 worker线程与主线程不在同一个上下文，不能直接通信，需要通过 postMessage方法来通信。 脚本限制 worker线程不能执行 alert、 confirm，但可以使用 XMLHttpRequest 对象发出ajax请求。 漫谈前端性能 突破 React 应用瓶颈 React 结合 Web worker ? 尝试在 Web worker 中运行 React Virtual DOM 的相关计算，即将 React core 部分移入 Web worker 线程中 ? 还真有人提出类似想法：3092 issue，但是提案被拒绝了，react 选择的是 React Fiber。 但是这个并不妨碍 Web worker 成为 “民间” 的 react 性能解药： React Redux 中间件思想遇见 Web Worker 的灵感（附demo）另外举个例子对比: http://web-perf.github.io/react-worker-dom/]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo & github page 搭建博客]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%85%B6%E4%BB%96%2Fhexo%20%26%20github%20page%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建搭建过程参考这篇文章：手把手教你使用 Hexo + Github Pages 搭建个人独立博客 Hexo 主题配置建议设置为 next 主题 克隆仓库 12// git clone命令将Next仓库克隆到hexo目录下的themes/nextgit clone https://github.com/theme-next/hexo-theme-next.git themes/next 设置Next主题 12345// 在站点根目录下，设置以下代码：# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next #此处填入你在themes目录下的next主题文件名 个性化设置大致设置过程参见这篇文章： Hexo搭建的GitHub博客之优化大全 开启文章阅读次数功能 第一种方法：LeanCloud (参考这篇文章：https://www.jianshu.com/p/702a7aec4d00) 去 LeanCloud ，创建新应用，创建 Counter 类 修改主题文件 1234leancloud_visitors: enable: true #将原来的false改为true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; 第二种方法： 开启不蒜子统计功能 在主题配置文件中 _config.yml ： 1234567891011121314# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: enable: true site_uv: true #total visitors site_uv_icon: #user-circle site_uv_header: 你是来访的第 site_uv_footer: 位小伙伴 site_pv: false #total views site_pv_icon: eye site_pv_header: 访问次数： site_pv_footer: 次 post_views: false post_views_icon: eye 不过因为域名过期问题，next 默认集成的 valine 脚本无法访问，解决办法参见：hexo博客解决不蒜子统计无法显示问题 开启 valine 评论功能大致设置过程参考这篇文章： Hexo博客使用valine评论系统无效果及终极解决方案 需要特别注意的是： valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突。 解决的办法是：基于LeanCloud开启 valine 评论，基于不蒜子开启文章统计功能。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python]]></title>
    <url>%2F2019%2F08%2F15%2FPython%2FPython%20%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[基础语法 Python 官网 Python Cookbook Python 从新手到大师 github 资料 数据分析oj 练习平台 pythontip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebAssembly]]></title>
    <url>%2F2019%2F08%2F15%2FWebAssembly%2FWebAssembly%20%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Web端H.265播放器研发解密: https://mp.weixin.qq.com/s/ajLFM8q-4-2hxj-M_ChGdg]]></content>
      <categories>
        <category>WebAssembly</category>
      </categories>
      <tags>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hooks]]></title>
    <url>%2F2019%2F08%2F15%2FWeb%E5%89%8D%E7%AB%AF%2FReact%20Hooks%2F</url>
    <content type="text"><![CDATA[what Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 why react hooks 主要解决以下三个主要的问题： 代码重用：在 hooks 出来之前，常见的代码重用方式是 HOC 和 render props，这两种方式带来的问题是： 你需要解构自己的组件，非常的笨重，同时会带来很深的组件嵌套。 难以重用和共享组件中的与状态相关的逻辑，造成产生很多巨大的组件。 复杂的组件逻辑：在 class 组件中，有许多的 lifecycle 函数，当我们的组件需要处理多个互不相关的 localstate 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面，最终导致逻辑复杂的组件难以开发与维护。 class 组件的困惑： 复杂的模式，如渲染道具和高阶组件。 由于业务变动，函数组件不得不改为类组件 具体可以参考官方文档中对 hooks 引入 动机 的解释，另外还可以参考一下知乎上如何评价 React v16.7.0-alpha 提出的 Hooks API？ 这个问题网友的回答。 how useState(0) 返回是个数组形式，useState(0) 代表 count 的初始值是 0，useState 现阶段只能传入一个初始值。useState 类似 setState，你可以看做是异步的，但 useState 必须保证执行顺序一一致，React 为每一次的 useState 调用分配一个空间，通过 useState 调用顺序辨别各个空间。 12345678910const Counter = () =&gt; &#123; const [count, setCount] = useState(0); const increment = () =&gt; setCount(count + 1); return ( &lt;&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt; &lt;/&gt; )&#125; useEffect 可以把 useEffect 视作 componentDidMount、componentDidUpdate 合体。通过 useEffect 的第二个参数告诉 React 用到了哪些外部变量，来决定是否更新时候执行。可以定义多个 useEffect 函数，会一次进行调用。 123useEffect(() =&gt; &#123; // 每次componentDidMount或者componentDidUpdate都会调用这里&#125;) useEffect 可以传入第二个操作来避免性能的损耗，如果第二个参数数组中的成员变量没有变化则会跳过此次改变。如何传入一个空数组 ，说明每次都不改变，那么该 effect 只会在组件 mount 和 unmount 时期执行。 123useEffect(() =&gt; &#123; // 每次componentDidMount会调用这里&#125;,[]) 如果需要在 componentWillUnmount 需要执行一些事件，可以 return 返回时候进行操作。 123456useEffect(() =&gt; &#123; //只有componentDidMount时候调用这里 return () =&gt; &#123; // 只有componentDidMountUnmount时候调用这里 &#125;;&#125;, []) useEffect 模拟 componentDidpdate，useRef是永远不会改变的一个hooks，每次返回值都是相同的。 12345678const mounted = useRef();useEffect(() =&gt; &#123; if(!mounted.current)&#123; mounted.current = true; &#125; else &#123; // 执行 componentDidpdate &#125;&#125;) useLayoutEffect：如果副作用是跟 DOM 相关的，需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。 1234567891011121314function App() &#123; const [width, setWidth] = useState(0); useLayoutEffect(() =&gt; &#123; const title = document.querySelector(&apos;#title&apos;); const titleWidth = title.getBoundingClientRect().width; if (width !== titleWidth) &#123; setWidth(titleWidth); &#125; &#125;); return &lt;div&gt; &lt;h1 id=&quot;title&quot;&gt;hello&lt;/h1&gt; &lt;h2&gt;&#123;width&#125;&lt;/h2&gt; &lt;/div&gt;&#125; useReducer 接收两个参数，一个是 reducer 函数，跟 redux 中的 reducer 是一样的；另外一个是初始的状态值。返回的是一个数组，数组中的第一个元素是状态值，第二个元素是 dispatch 函数。 12345678910111213141516171819202122const reducer = (state, action) =&gt; &#123; switch(action.type) &#123; case &apos;increment&apos;: return &#123;count: state.count + 1&#125;; case &apos;decrement&apos;: return &#123;count: state.count - 1&#125;; case &apos;reset&apos;: return initState; default: return state; &#125;&#125;;function App() &#123; const [state, dispatch] = useReducer(reducer, initState); return &lt;div&gt; &lt;h1&gt;&#123;state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;increment&apos;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;decrement&apos;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;reset&apos;&#125;)&#125;&gt;reset&lt;/button&gt; &lt;/div&gt;&#125; useRef：在函数组件中获取组件或DOM节点的引用。 12345678function App() &#123; const inputRef = useRef(null); return &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;inputRef&#125;/&gt; &lt;button onClick=&#123;() =&gt; inputRef.current.focus()&#125;&gt;focus&lt;/button&gt; &lt;/div&gt;&#125; useContext：Context 的作用就是对它所包含的组件树提供全局共享数据的一种技术。useReducer 结合useContext，通过 context 把 dispatch 函数提供给组件树中的所有组件使用 ，而不用通过 props 添加回调函数的方式一层层传递。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 定义初始化值const initState = &#123; name: &apos;&apos;, pwd: &apos;&apos;, isLoading: false, error: &apos;&apos;, isLoggedIn: false,&#125;// 定义state[业务]处理逻辑 reducer函数function loginReducer(state, action) &#123; switch(action.type) &#123; case &apos;login&apos;: return &#123; ...state, isLoading: true, error: &apos;&apos;, &#125; case &apos;success&apos;: return &#123; ...state, isLoggedIn: true, isLoading: false, &#125; case &apos;error&apos;: return &#123; ...state, error: action.payload.error, name: &apos;&apos;, pwd: &apos;&apos;, isLoading: false, &#125; default: return state; &#125;&#125;// 定义 context函数const LoginContext = React.createContext();function LoginPage() &#123; const [state, dispatch] = useReducer(loginReducer, initState); const &#123; name, pwd, isLoading, error, isLoggedIn &#125; = state; const login = (event) =&gt; &#123; event.preventDefault(); dispatch(&#123; type: &apos;login&apos; &#125;); login(&#123; name, pwd &#125;) .then(() =&gt; &#123; dispatch(&#123; type: &apos;success&apos; &#125;); &#125;) .catch((error) =&gt; &#123; dispatch(&#123; type: &apos;error&apos; payload: &#123; error: error.message &#125; &#125;); &#125;); &#125; // 利用 context 共享dispatch return ( &lt;LoginContext.Provider value=&#123;dispatch&#125;&gt; &lt;...&gt; &lt;LoginButton /&gt; &lt;/LoginContext.Provider&gt; )&#125;function LoginButton() &#123; // 子组件中直接通过context拿到dispatch，出发reducer操作state const dispatch = useContext(LoginContext); const click = () =&gt; &#123; if (error) &#123; // 子组件可以直接 dispatch action dispatch(&#123; type: &apos;error&apos; payload: &#123; error: error.message &#125; &#125;); &#125; &#125;&#125; 自定义 hooks举个🌰custom Hooks 自定义监听窗口大小组件 12345678// 一个显示目前窗口大小的组件function responsiveComponent()&#123; // custom hooks const width = useWindowWidth(); return ( &lt;p&gt;当前窗口的宽度是 &#123;width&#125;&lt;/p&gt; )&#125; custom hooks —— useWindowWidth 窗口调整大小时使用副作用来设置该状态 1234567891011121314import &#123; useState, useEffect&#125; from &apos;react&apos;;// custom hooks to listen window width changefunction useWindowWidth()&#123; const [width, setWidth] = useState(window.innerWidth); useEffect(() =&gt; &#123; const handleResize = ()=&gt;&#123; setWidth(window.innerWidth); &#125; window.addEventListener(&apos;resize&apos;, handleResize); &#125;, [width]); // width 没有变化则不处理 return width;&#125; 此外还可以参考一个有意思的 hooks 库 react-use 限制条件 仅从 React 功能组件调用 hooks。不要从常规 js 函数中调用 hooks。( 还有另一个地方可以调用 hooks—— 你自己的定制 hooks。) 只能在顶层调用，不能在 for 循环、if 条件判断、 函数嵌套中使用。 Ps：译: React hooks: 不是魔法只是数组 一文中有解释为什么 hooks 只能在顶层调用。 原理与实现 [[译] React hooks: 不是魔法，只是数组](http://react-china.org/t/react-hooks/27122) useState 底层实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let state = [];let setters = [];let firstRun = true;let cursor = 0;function createSetter(cursor) &#123; return function setterWithCursor(newVal) &#123; state[cursor] = newVal; &#125;;&#125;// This is the pseudocode for the useState helperexport function useState(initVal) &#123; if (firstRun) &#123; state.push(initVal); setters.push(createSetter(cursor)); firstRun = false; &#125; const setter = setters[cursor]; const value = state[cursor]; cursor++; return [value, setter];&#125;// Our component code that uses hooksfunction RenderFunctionComponent() &#123; const [firstName, setFirstName] = useState(&quot;Rudi&quot;); // cursor: 0 const [lastName, setLastName] = useState(&quot;Yardley&quot;); // cursor: 1 return ( &lt;div&gt; &lt;Button onClick=&#123;() =&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;/Button&gt; &lt;Button onClick=&#123;() =&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;/Button&gt; &lt;/div&gt; );&#125;// This is sort of simulating Reacts rendering cyclefunction MyComponent() &#123; cursor = 0; // resetting the cursor return &lt;RenderFunctionComponent /&gt;; // render&#125;console.log(state); // Pre-render: []MyComponent();console.log(state); // First-render: [&apos;Rudi&apos;, &apos;Yardley&apos;]MyComponent();console.log(state); // Subsequent-render: [&apos;Rudi&apos;, &apos;Yardley&apos;]// click the &apos;Fred&apos; buttonconsole.log(state); // After-click: [&apos;Fred&apos;, &apos;Yardley&apos;] 参考文章 react hooks的诞生 理解 React Hooks 译: React hooks: 不是魔法只是数组 How to fetch data with React Hooks React Hooks 是不能替代 Redux 的]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
</search>
